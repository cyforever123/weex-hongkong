(function(s) {console.log(s)})('START WEEX HTML5: 0.3.2 Build 20160819');
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _render = __webpack_require__(1);
	
	var _render2 = _interopRequireDefault(_render);
	
	var _root = __webpack_require__(137);
	
	var _root2 = _interopRequireDefault(_root);
	
	var _div = __webpack_require__(138);
	
	var _div2 = _interopRequireDefault(_div);
	
	var _components = __webpack_require__(139);
	
	var _components2 = _interopRequireDefault(_components);
	
	var _api = __webpack_require__(189);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * install components and APIs
	 */
	
	
	_render2.default.install(_root2.default);
	_render2.default.install(_div2.default);
	_render2.default.install(_components2.default);
	_render2.default.install(_api2.default);
	
	exports.default = _render2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib, WebSocket */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Weex;
	
	__webpack_require__(2);
	
	__webpack_require__(6);
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _loader = __webpack_require__(117);
	
	var _utils = __webpack_require__(83);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _bridge = __webpack_require__(118);
	
	var _component = __webpack_require__(122);
	
	var _component2 = _interopRequireDefault(_component);
	
	var _atomic = __webpack_require__(132);
	
	var _atomic2 = _interopRequireDefault(_atomic);
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _register = __webpack_require__(133);
	
	__webpack_require__(134);
	
	__webpack_require__(135);
	
	__webpack_require__(136);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEFAULT_DESIGN_WIDTH = 750;
	
	// gesture
	
	var DEFAULT_SCALE = window.innerWidth / DEFAULT_DESIGN_WIDTH;
	var DEFAULT_ROOT_ID = 'weex';
	var DEFAULT_JSONP_CALLBACK_NAME = 'weexJsonpCallback';
	
	global.WXEnvironment = {
	  weexVersion: _config2.default.weexVersion,
	  appName: lib.env.aliapp ? lib.env.aliapp.appname : null,
	  appVersion: lib.env.aliapp ? lib.env.aliapp.version.val : null,
	  platform: 'Web',
	  osName: lib.env.browser ? lib.env.browser.name : null,
	  osVersion: lib.env.browser ? lib.env.browser.version.val : null,
	  deviceWidth: DEFAULT_DESIGN_WIDTH,
	  deviceHeight: window.innerHeight / DEFAULT_SCALE
	};
	
	var _weexInstance = {};
	
	function noop() {}
	
	;(function initializeWithUrlParams() {
	  // in casperjs the protocol is file.
	  if (location.protocol.match(/file/)) {
	    return;
	  }
	
	  var params = lib.httpurl(location.href).params;
	
	  // set global 'debug' config to true if there's a debug flag in current url.
	  var debug = params['debug'];
	  if (debug === true || debug === 'true') {
	    _config2.default.debug = true;
	  }
	
	  !_config2.default.debug && (console.debug = noop);
	})();
	
	function Weex(options) {
	  if (!(this instanceof Weex)) {
	    return new Weex(options);
	  }
	
	  // Width of the root container. Default is window.innerWidth.
	  this.width = options.width || window.innerWidth;
	  this.bundleUrl = options.bundleUrl || location.href;
	  this.instanceId = options.appId;
	  this.rootId = options.rootId || DEFAULT_ROOT_ID + utils.getRandom(10);
	  this.designWidth = options.designWidth || DEFAULT_DESIGN_WIDTH;
	  this.jsonpCallback = options.jsonpCallback || DEFAULT_JSONP_CALLBACK_NAME;
	  this.source = options.source;
	  this.loader = options.loader;
	  this.embed = options.embed;
	
	  this.data = options.data;
	  this.scale = this.width / this.designWidth;
	  _bridge.receiver.init(this);
	  this.sender = new _bridge.Sender(this);
	
	  _weexInstance[this.instanceId] = this;
	
	  // load bundle.
	  (0, _loader.load)({
	    jsonpCallback: this.jsonpCallback,
	    source: this.source,
	    loader: this.loader
	  }, function (err, appCode) {
	    if (!err) {
	      this.createApp(_config2.default, appCode);
	    } else {
	      console.error('load bundle err:', err);
	    }
	  }.bind(this));
	}
	
	Weex.init = function (options) {
	  if (utils.isArray(options)) {
	    options.forEach(function (config) {
	      new Weex(config);
	    });
	  } else if (utils.getType(options) === 'object') {
	    new Weex(options);
	  }
	};
	
	Weex.getInstance = function (instanceId) {
	  return _weexInstance[instanceId];
	};
	
	Weex.prototype = {
	
	  createApp: function createApp(config, appCode) {
	    var root = document.querySelector('#' + this.rootId);
	    if (!root) {
	      root = document.createElement('div');
	      root.id = this.rootId;
	      document.body.appendChild(root);
	    }
	
	    var instance = window.createInstance(this.instanceId, appCode, {
	      bundleUrl: this.bundleUrl,
	      debug: config.debug
	    }, this.data);
	
	    if (!instance) {
	      return console.error('[h5-render] createInstance error: get void for instance.');
	    }
	
	    if (instance instanceof Error) {
	      return console.error('[h5-render]', instance);
	    }
	
	    if (instance instanceof Promise) {
	      return instance.then(function (res) {
	        this.appInstance = res;
	        // Weex._instances[this.instanceId] = this.root
	      }).catch(function (err) {
	        console.error('[h5-render]', err);
	      });
	    }
	
	    this.appInstance = instance;
	
	    // Do not destroy instance before unload, because in most browser
	    // press back button to back to this page will not refresh
	    // the window and the instance will not be recreated then.
	    // window.addEventListener('beforeunload', function (e) {
	    // })
	  },
	
	  getComponentManager: function getComponentManager() {
	    if (!this._componentManager) {
	      this._componentManager = _componentManager2.default.getInstance(this.instanceId);
	    }
	    return this._componentManager;
	  },
	
	  getRoot: function getRoot() {
	    return document.querySelector('#' + this.rootId);
	  }
	};
	
	Weex.stopTheWorld = function (instanceId) {
	  if (!instanceId) {
	    return Object.keys(_weexInstance).map(function (instanceId) {
	      Weex.stopTheWorld(instanceId);
	    });
	  }
	  window.destroyInstance(instanceId);
	}
	
	// for weex-toolkit.
	;(function startRefreshController() {
	  if (location.protocol.match(/file/)) {
	    return;
	  }
	  if (location.search.indexOf('hot-reload_controller') === -1) {
	    return;
	  }
	  if (typeof WebSocket === 'undefined') {
	    console.info('auto refresh need WebSocket support');
	    return;
	  }
	  var host = location.hostname;
	  var port = 8082;
	  var client = new WebSocket('ws://' + host + ':' + port + '/', 'echo-protocol');
	  client.onerror = function () {
	    console.log('refresh controller websocket connection error');
	  };
	  client.onmessage = function (e) {
	    console.log('Received: \'' + e.data + '\'');
	    if (e.data === 'refresh') {
	      location.reload();
	    }
	  };
	})();
	
	(0, _register.bind)(Weex);
	
	utils.extend(Weex, {
	  Component: _component2.default,
	  Atomic: _atomic2.default,
	  ComponentManager: _componentManager2.default,
	  utils: utils,
	  config: _config2.default
	});
	
	global.weex = Weex;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./base.css", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./base.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "* {\n  margin: 0;\n  padding: 0;\n  text-size-adjust: none;\n}\n\nul, ol {\n  list-style: none;\n}\n\n.weex-container {\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  flex-shrink: 0;\n  align-items: stretch;\n  box-align: stretch;\n  align-content: flex-start;\n  position: relative;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n  min-width: 0;\n}\n\n.weex-element {\n  box-sizing: border-box;\n  position: relative;\n  flex-shrink: 0;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n  min-width: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(7);
	
	var _init = __webpack_require__(76);
	
	var _init2 = _interopRequireDefault(_init);
	
	var _config = __webpack_require__(77);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _vdom = __webpack_require__(112);
	
	var _methods = __webpack_require__(113);
	
	var methods = _interopRequireWildcard(_methods);
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import { subversion } from '../../../package.json'
	
	
	var config = {
	  Document: _vdom.Document, Element: _vdom.Element, Comment: _vdom.Comment, Listener: _componentManager2.default, frameworks: _config2.default,
	  sendTasks: function sendTasks() {
	    var _global;
	
	    (_global = global).callNative.apply(_global, arguments);
	  }
	};
	// import init from '../../runtime/init'
	
	
	var runtime = (0, _init2.default)(config);
	
	// const { native, transformer } = subversion
	
	var _loop = function _loop(methodName) {
	  global[methodName] = function () {
	    var ret = runtime[methodName].apply(runtime, arguments);
	    if (ret instanceof Error) {
	      console.error(ret.toString());
	    }
	    return ret;
	  };
	};
	
	for (var methodName in runtime) {
	  _loop(methodName);
	}
	
	// global.frameworkVersion = native
	// global.transformVersion = transformer
	
	/**
	 * register methods
	 */
	global.registerMethods(methods);

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isPlainObject = exports.isObject = exports.toArray = exports.bind = exports.hasOwn = exports.remove = exports.def = exports.extend = undefined;
	
	var _utils = __webpack_require__(8);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _utils.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _utils.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _utils.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _utils.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _utils.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _utils.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isPlainObject;
	  }
	});
	
	__webpack_require__(9);

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.extend = extend;
	exports.def = def;
	exports.remove = remove;
	exports.hasOwn = hasOwn;
	exports.bind = bind;
	exports.toArray = toArray;
	exports.isObject = isObject;
	exports.isPlainObject = isPlainObject;
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(target) {
	  for (var _len = arguments.length, src = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    src[_key - 1] = arguments[_key];
	  }
	
	  if (typeof Object.assign === 'function') {
	    Object.assign.apply(Object, [target].concat(src));
	  } else {
	    var first = src.shift();
	    for (var key in first) {
	      target[key] = first[key];
	    }
	    if (src.length) {
	      extend.apply(undefined, [target].concat(src));
	    }
	  }
	  return target;
	}
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Remove an item from an array
	 *
	 * @param {Array} arr
	 * @param {*} item
	 */
	
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// fix Promise Problem on JSContext of iOS7~8
	// @see https://bugs.webkit.org/show_bug.cgi?id=135866
	// global.Promise = null
	__webpack_require__(10);
	__webpack_require__(30);
	__webpack_require__(56);
	__webpack_require__(60);

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(11)
	  , test    = {};
	test[__webpack_require__(13)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(17)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(12)
	  , TAG = __webpack_require__(13)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(14)('wks')
	  , uid        = __webpack_require__(16)
	  , Symbol     = __webpack_require__(15).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(15)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , hide      = __webpack_require__(18)
	  , has       = __webpack_require__(28)
	  , SRC       = __webpack_require__(16)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(29).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(19)
	  , createDesc = __webpack_require__(27);
	module.exports = __webpack_require__(23) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(26)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){
	  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(24)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , document = __webpack_require__(15).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(21);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(31)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(34)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(32)
	  , defined   = __webpack_require__(33);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(35)
	  , $export        = __webpack_require__(36)
	  , redefine       = __webpack_require__(17)
	  , hide           = __webpack_require__(18)
	  , has            = __webpack_require__(28)
	  , Iterators      = __webpack_require__(39)
	  , $iterCreate    = __webpack_require__(40)
	  , setToStringTag = __webpack_require__(53)
	  , getPrototypeOf = __webpack_require__(54)
	  , ITERATOR       = __webpack_require__(13)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , core      = __webpack_require__(29)
	  , hide      = __webpack_require__(18)
	  , redefine  = __webpack_require__(17)
	  , ctx       = __webpack_require__(37)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(38);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(41)
	  , descriptor     = __webpack_require__(27)
	  , setToStringTag = __webpack_require__(53)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(18)(IteratorPrototype, __webpack_require__(13)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(42)
	  , enumBugKeys = __webpack_require__(51)
	  , IE_PROTO    = __webpack_require__(50)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(25)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(52).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(19)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(43);
	
	module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(44)
	  , enumBugKeys = __webpack_require__(51);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(28)
	  , toIObject    = __webpack_require__(45)
	  , arrayIndexOf = __webpack_require__(47)(false)
	  , IE_PROTO     = __webpack_require__(50)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(46)
	  , defined = __webpack_require__(33);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(12);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(45)
	  , toLength  = __webpack_require__(48)
	  , toIndex   = __webpack_require__(49);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(32)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(32)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(14)('keys')
	  , uid    = __webpack_require__(16);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 51 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(15).document && document.documentElement;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(19).f
	  , has = __webpack_require__(28)
	  , TAG = __webpack_require__(13)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(28)
	  , toObject    = __webpack_require__(55)
	  , IE_PROTO    = __webpack_require__(50)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(33);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(57)
	  , redefine      = __webpack_require__(17)
	  , global        = __webpack_require__(15)
	  , hide          = __webpack_require__(18)
	  , Iterators     = __webpack_require__(39)
	  , wks           = __webpack_require__(13)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(58)
	  , step             = __webpack_require__(59)
	  , Iterators        = __webpack_require__(39)
	  , toIObject        = __webpack_require__(45);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(34)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(13)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(18)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(35)
	  , global             = __webpack_require__(15)
	  , ctx                = __webpack_require__(37)
	  , classof            = __webpack_require__(11)
	  , $export            = __webpack_require__(36)
	  , isObject           = __webpack_require__(21)
	  , anObject           = __webpack_require__(20)
	  , aFunction          = __webpack_require__(38)
	  , anInstance         = __webpack_require__(61)
	  , forOf              = __webpack_require__(62)
	  , setProto           = __webpack_require__(66).set
	  , speciesConstructor = __webpack_require__(69)
	  , task               = __webpack_require__(70).set
	  , microtask          = __webpack_require__(72)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(73)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(53)($Promise, PROMISE);
	__webpack_require__(74)(PROMISE);
	Wrapper = __webpack_require__(29)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(75)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(37)
	  , call        = __webpack_require__(63)
	  , isArrayIter = __webpack_require__(64)
	  , anObject    = __webpack_require__(20)
	  , toLength    = __webpack_require__(48)
	  , getIterFn   = __webpack_require__(65)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(20);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(39)
	  , ITERATOR   = __webpack_require__(13)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(11)
	  , ITERATOR  = __webpack_require__(13)('iterator')
	  , Iterators = __webpack_require__(39);
	module.exports = __webpack_require__(29).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(21)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(37)(Function.call, __webpack_require__(67).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(68)
	  , createDesc     = __webpack_require__(27)
	  , toIObject      = __webpack_require__(45)
	  , toPrimitive    = __webpack_require__(26)
	  , has            = __webpack_require__(28)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(20)
	  , aFunction = __webpack_require__(38)
	  , SPECIES   = __webpack_require__(13)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(37)
	  , invoke             = __webpack_require__(71)
	  , html               = __webpack_require__(52)
	  , cel                = __webpack_require__(25)
	  , global             = __webpack_require__(15)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(12)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 71 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , macrotask = __webpack_require__(70).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(12)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(17);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(15)
	  , dP          = __webpack_require__(19)
	  , DESCRIPTORS = __webpack_require__(23)
	  , SPECIES     = __webpack_require__(13)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(13)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = init;
	var frameworks = void 0;
	
	var versionRegExp = /^\/\/ *(\{[^\}]*\}) *\r?\n/;
	
	function checkVersion(code) {
	  var info = void 0;
	  var result = versionRegExp.exec(code);
	  if (result) {
	    try {
	      info = JSON.parse(result[1]);
	    } catch (e) {}
	  }
	  return info;
	}
	
	var instanceMap = {};
	
	function createInstance(id, code, config, data) {
	  var info = instanceMap[id];
	  if (!info) {
	    info = checkVersion(code) || {};
	    if (!frameworks[info.framework]) {
	      info.framework = 'Weex';
	    }
	    instanceMap[id] = info;
	    config = config || {};
	    config.bundleVersion = info.version;
	    console.debug('[JS Framework] create an ' + info.framework + '@' + config.bundleVersion + ' instance from ' + config.bundleVersion);
	    return frameworks[info.framework].createInstance(id, code, config, data);
	  }
	  return new Error('invalid instance id "' + id + '"');
	}
	
	var methods = {
	  createInstance: createInstance
	};
	
	function genInit(methodName) {
	  methods[methodName] = function () {
	    for (var name in frameworks) {
	      var framework = frameworks[name];
	      if (framework && framework[methodName]) {
	        framework[methodName].apply(framework, arguments);
	      }
	    }
	  };
	}
	
	function genInstance(methodName) {
	  methods[methodName] = function () {
	    var id = arguments.length <= 0 ? undefined : arguments[0];
	    var info = instanceMap[id];
	    if (info && frameworks[info.framework]) {
	      var _frameworks$info$fram;
	
	      return (_frameworks$info$fram = frameworks[info.framework])[methodName].apply(_frameworks$info$fram, arguments);
	    }
	    return new Error('invalid instance id "' + id + '"');
	  };
	}
	
	function adaptInstance(methodName, nativeMethodName) {
	  methods[nativeMethodName] = function () {
	    var id = arguments.length <= 0 ? undefined : arguments[0];
	    var info = instanceMap[id];
	    if (info && frameworks[info.framework]) {
	      var _frameworks$info$fram2;
	
	      return (_frameworks$info$fram2 = frameworks[info.framework])[methodName].apply(_frameworks$info$fram2, arguments);
	    }
	    return new Error('invalid instance id "' + id + '"');
	  };
	}
	
	function init(config) {
	  frameworks = config.frameworks;
	  for (var name in frameworks) {
	    var framework = frameworks[name];
	    framework.init(config);
	  }
	
	  ;['destroyInstance', 'refreshInstance', 'receiveTasks', 'getRoot'].forEach(genInstance);['registerComponents', 'registerModules', 'registerMethods'].forEach(genInit);
	
	  adaptInstance('receiveTasks', 'callJS');
	
	  return methods;
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _default = __webpack_require__(78);
	
	var Weex = _interopRequireWildcard(_default);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = {
	  Weex: Weex
	}; // built by npm run build:config

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(79);
	
	Object.defineProperty(exports, 'createInstance', {
	  enumerable: true,
	  get: function get() {
	    return _create.createInstance;
	  }
	});
	
	var _life = __webpack_require__(108);
	
	Object.defineProperty(exports, 'init', {
	  enumerable: true,
	  get: function get() {
	    return _life.init;
	  }
	});
	Object.defineProperty(exports, 'refreshInstance', {
	  enumerable: true,
	  get: function get() {
	    return _life.refreshInstance;
	  }
	});
	Object.defineProperty(exports, 'destroyInstance', {
	  enumerable: true,
	  get: function get() {
	    return _life.destroyInstance;
	  }
	});
	
	var _register = __webpack_require__(109);
	
	Object.defineProperty(exports, 'registerComponents', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerComponents;
	  }
	});
	Object.defineProperty(exports, 'registerModules', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerModules;
	  }
	});
	Object.defineProperty(exports, 'registerMethods', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerMethods;
	  }
	});
	
	var _bridge = __webpack_require__(110);
	
	Object.defineProperty(exports, 'receiveTasks', {
	  enumerable: true,
	  get: function get() {
	    return _bridge.receiveTasks;
	  }
	});
	
	var _misc = __webpack_require__(111);
	
	Object.defineProperty(exports, 'getRoot', {
	  enumerable: true,
	  get: function get() {
	    return _misc.getRoot;
	  }
	});

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createInstance = createInstance;
	
	var _app = __webpack_require__(80);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _map = __webpack_require__(107);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * create a Weex instance
	 *
	 * @param  {string} instanceId
	 * @param  {string} code
	 * @param  {object} [options] option `HAS_LOG` enable print log
	 * @param  {object} [data]
	 */
	function createInstance(instanceId, code, options, data) {
	  var instance = _map.instanceMap[instanceId];
	  options = options || {};
	
	  var result = void 0;
	  if (!instance) {
	    instance = new _app2.default(instanceId, options);
	    _map.instanceMap[instanceId] = instance;
	    result = instance.init(code, data);
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	
	  return result || instance;
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ctrl = __webpack_require__(81);
	
	var ctrl = _interopRequireWildcard(_ctrl);
	
	var _utils = __webpack_require__(83);
	
	var _instance = __webpack_require__(105);
	
	var _instance2 = _interopRequireDefault(_instance);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	(0, _utils.extend)(_instance2.default.prototype, ctrl); /**
	                                                         * @fileOverview
	                                                         * Weex instance constructor & definition
	                                                         */


	exports.default = _instance2.default;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _init = __webpack_require__(82);
	
	Object.defineProperty(exports, 'init', {
	  enumerable: true,
	  get: function get() {
	    return _init.init;
	  }
	});
	
	var _misc = __webpack_require__(104);
	
	Object.defineProperty(exports, 'updateActions', {
	  enumerable: true,
	  get: function get() {
	    return _misc.updateActions;
	  }
	});
	Object.defineProperty(exports, 'destroy', {
	  enumerable: true,
	  get: function get() {
	    return _misc.destroy;
	  }
	});
	Object.defineProperty(exports, 'getRootElement', {
	  enumerable: true,
	  get: function get() {
	    return _misc.getRootElement;
	  }
	});
	Object.defineProperty(exports, 'fireEvent', {
	  enumerable: true,
	  get: function get() {
	    return _misc.fireEvent;
	  }
	});
	Object.defineProperty(exports, 'callback', {
	  enumerable: true,
	  get: function get() {
	    return _misc.callback;
	  }
	});
	Object.defineProperty(exports, 'refreshData', {
	  enumerable: true,
	  get: function get() {
	    return _misc.refreshData;
	  }
	});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init = init;
	
	var _utils = __webpack_require__(83);
	
	var _bundle = __webpack_require__(87);
	
	/**
	 * @fileOverview
	 * instance controls from native
	 *
	 * - init bundle
	 * - fire event
	 * - callback
	 * - destroy
	 *
	 * corresponded with the API of instance manager (framework.js)
	 */
	
	function init(code, data) {
	  var _this = this;
	
	  console.debug('[JS Framework] Intialize an instance with:\n', data);
	
	  var result = void 0;
	  // @see: lib/app/bundle.js
	  var bundleDefine = (0, _utils.bind)(_bundle.define, this);
	  var bundleBootstrap = function bundleBootstrap(name, config, _data) {
	    result = (0, _bundle.bootstrap)(_this, name, config, _data || data);
	    _this.updateActions();
	    _this.doc.listener.createFinish();
	    console.debug('[JS Framework] After intialized an instance(' + _this.id + ')');
	  };
	
	  // backward(register/render)
	  var bundleRegister = (0, _utils.bind)(_bundle.register, this);
	  var bundleRender = function bundleRender(name, _data) {
	    result = (0, _bundle.bootstrap)(_this, name, {}, _data);
	  };
	
	  var bundleRequire = function bundleRequire(name) {
	    return function (_data) {
	      result = (0, _bundle.bootstrap)(_this, name, {}, _data);
	    };
	  };
	
	  var bundleDocument = this.doc;
	
	  var functionBody = void 0;
	  /* istanbul ignore if */
	  if (typeof code === 'function') {
	    // `function () {...}` -> `{...}`
	    // not very strict
	    functionBody = code.toString().substr(12);
	  } else if (code) {
	    functionBody = code.toString();
	  }
	
	  var _global = global;
	  var WXEnvironment = _global.WXEnvironment;
	
	
	  if (WXEnvironment) {
	    var fn = new Function('define', 'require', 'document', 'bootstrap', 'register', 'render', '__weex_define__', // alias for define
	    '__weex_bootstrap__', // alias for bootstrap
	    functionBody);
	
	    fn(bundleDefine, bundleRequire, bundleDocument, bundleBootstrap, bundleRegister, bundleRender, bundleDefine, bundleBootstrap);
	  }
	
	  return result;
	}

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* global Image */
	
	'use strict';
	
	// const WEAPP_STYLE_ID = 'weapp-style'
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.vendors = exports.slice = exports.isArray = exports.typof = exports.isPlainObject = exports.isObject = exports.toArray = exports.bind = exports.hasOwn = exports.remove = exports.def = exports.extend = exports.frameUpdater = undefined;
	
	var _util = __webpack_require__(84);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _util.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _util.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _util.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _util.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _util.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _util.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _util.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _util.isPlainObject;
	  }
	});
	Object.defineProperty(exports, 'typof', {
	  enumerable: true,
	  get: function get() {
	    return _util.typof;
	  }
	});
	exports.getType = getType;
	exports.appendStyle = appendStyle;
	exports.getUniqueFromArray = getUniqueFromArray;
	exports.detectWebp = detectWebp;
	exports.detectSticky = detectSticky;
	exports.getRandom = getRandom;
	exports.getRgb = getRgb;
	exports.loopArray = loopArray;
	exports.throttle = throttle;
	
	var _frameUpdater = __webpack_require__(85);
	
	var _frameUpdater2 = _interopRequireDefault(_frameUpdater);
	
	var _array = __webpack_require__(86);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.frameUpdater = _frameUpdater2.default;
	exports.isArray = _array.isArray;
	exports.slice = _array.slice;
	var vendors = exports.vendors = ['ms', 'moz', 'webkit', 'o'];
	
	var _isWebpSupported = false;(function isSupportWebp() {
	  try {
	    (function () {
	      var webP = new Image();
	      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdA' + 'SoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
	      webP.onload = function () {
	        if (webP.height === 2) {
	          _isWebpSupported = true;
	        }
	      };
	    })();
	  } catch (e) {
	    // do nothing.
	  }
	})();
	
	var _isStickySupported = false;(function isSupportSticky() {
	  var element = document.createElement('div');
	  var elementStyle = element.style;
	  elementStyle.cssText = vendors.concat(['']).map(function (vendor) {
	    return 'position:' + (vendor ? '-' + vendor + '-' : '') + 'sticky';
	  }).join(';') + ';';
	  _isStickySupported = elementStyle.position.indexOf('sticky') !== -1;
	})();
	
	// export function extend (to, from) {
	//   for (const key in from) {
	//     to[key] = from[key]
	//   }
	//   return to
	// }
	
	// export function isPlainObject (obj) {
	//   return Object.prototype.toString.call(obj)
	//     .slice(8, -1).toLowerCase() === 'object'
	// }
	
	function getType(obj) {
	  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
	}
	
	function appendStyle(css, styleId, replace) {
	  var style = document.getElementById(styleId);
	  if (style && replace) {
	    style.parentNode.removeChild(style);
	    style = null;
	  }
	  if (!style) {
	    style = document.createElement('style');
	    style.type = 'text/css';
	    styleId && (style.id = styleId);
	    document.getElementsByTagName('head')[0].appendChild(style);
	  }
	  style.appendChild(document.createTextNode(css));
	}
	
	function getUniqueFromArray(arr) {
	  if (!(0, _array.isArray)(arr)) {
	    return [];
	  }
	  var res = [];
	  var unique = {};
	  var val = void 0;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    val = arr[i];
	    if (unique[val]) {
	      continue;
	    }
	    unique[val] = true;
	    res.push(val);
	  }
	  return res;
	}
	
	function detectWebp() {
	  return _isWebpSupported;
	}
	
	function detectSticky() {
	  return _isStickySupported;
	}
	
	function getRandom(num) {
	  var _defaultNum = 10;
	  if (typeof num !== 'number' || num <= 0) {
	    num = _defaultNum;
	  }
	  var _max = Math.pow(10, num);
	  return Math.floor(Date.now() + Math.random() * _max) % _max;
	}
	
	function getRgb(color) {
	  var match = void 0;
	  color = color + '';
	  match = color.match(/#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/);
	  if (match) {
	    return {
	      r: parseInt(match[1], 16),
	      g: parseInt(match[2], 16),
	      b: parseInt(match[3], 16)
	    };
	  }
	  match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
	  if (match) {
	    return {
	      r: parseInt(match[1]),
	      g: parseInt(match[2]),
	      b: parseInt(match[3])
	    };
	  }
	}
	
	// direction: 'l' | 'r', default is 'r'
	// num: how many times to loop, should be a positive integer
	function loopArray(arr, num, direction) {
	  if (!(0, _array.isArray)(arr)) {
	    return;
	  }
	  var isLeft = (direction + '').toLowerCase() === 'l';
	  var len = arr.length;
	  num = num % len;
	  if (num < 0) {
	    num = -num;
	    isLeft = !isLeft;
	  }
	  if (num === 0) {
	    return arr;
	  }
	  var lp = void 0,
	      rp = void 0;
	  if (isLeft) {
	    lp = arr.slice(0, num);
	    rp = arr.slice(num);
	  } else {
	    lp = arr.slice(0, len - num);
	    rp = arr.slice(len - num);
	  }
	  return rp.concat(lp);
	}
	
	function throttle(func, wait) {
	  var result = void 0;
	  var timerId = null;
	  var previous = 0;
	  var context = void 0;
	  var args = void 0;
	  var later = function later() {
	    previous = Date.now();
	    timerId = null;
	    result = func.apply(context, args);
	  };
	  return function () {
	    var now = Date.now();
	    var remaining = wait - (now - previous);
	    context = this;
	    args = Array.prototype.slice.call(arguments);
	    if (remaining <= 0) {
	      clearTimeout(timerId);
	      timerId = null;
	      previous = now;
	      result = func.apply(context, args);
	    } else if (!timerId) {
	      timerId = setTimeout(later, remaining);
	    }
	    return result;
	  };
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(8);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _utils.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _utils.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _utils.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _utils.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _utils.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _utils.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isPlainObject;
	  }
	});
	exports.isReserved = isReserved;
	exports.cached = cached;
	exports.typof = typof;
	
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	// can we use __proto__?
	var hasProto = exports.hasProto = '__proto__' in {};
	
	var _Set = void 0;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  exports._Set = _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  exports._Set = _Set = function _Set() {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	exports._Set = _Set;
	
	/**
	 * Create a cached version of a pure function.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	var camelize = exports.camelize = cached(function (str) {
	  return str.replace(camelizeRE, toUpper);
	});
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	var hyphenate = exports.hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	function typof(v) {
	  var s = Object.prototype.toString.call(v);
	  return s.substring(8, s.length - 1).toLowerCase();
	}

/***/ },
/* 85 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (calllback) {
	  setTimeout(calllback, 16);
	};
	
	var rafId = void 0;
	var observers = [];
	var paused = false;
	
	exports.default = {
	  start: function start() {
	    if (rafId) {
	      return;
	    }
	
	    rafId = raf(function runLoop() {
	      if (!paused) {
	        for (var i = 0; i < observers.length; i++) {
	          observers[i]();
	        }
	        raf(runLoop);
	      }
	    });
	  },
	
	  isActive: function isActive() {
	    return !paused;
	  },
	
	  pause: function pause() {
	    paused = true;
	    rafId = undefined;
	  },
	
	  resume: function resume() {
	    paused = false;
	    this.start();
	  },
	
	  addUpdateObserver: function addUpdateObserver(observeMethod) {
	    observers.push(observeMethod);
	  }
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isArray = isArray;
	exports.slice = slice;
	function isArray(arr) {
	  return Array.isArray ? Array.isArray(arr) : Object.prototype.toString.call(arr) === '[object Array]';
	}
	
	function slice(arr, start, end) {
	  if (isArray(arr)) {
	    return arr.slice(start, end);
	  }
	  var slice = Array.prototype.slice;
	  return slice.call(arr, start, end);
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _bootstrap = __webpack_require__(88);
	
	Object.defineProperty(exports, 'bootstrap', {
	  enumerable: true,
	  get: function get() {
	    return _bootstrap.bootstrap;
	  }
	});
	
	var _define = __webpack_require__(103);
	
	Object.defineProperty(exports, 'clearCommonModules', {
	  enumerable: true,
	  get: function get() {
	    return _define.clearCommonModules;
	  }
	});
	Object.defineProperty(exports, 'define', {
	  enumerable: true,
	  get: function get() {
	    return _define.define;
	  }
	});
	Object.defineProperty(exports, 'register', {
	  enumerable: true,
	  get: function get() {
	    return _define.register;
	  }
	});

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bootstrap = bootstrap;
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _utils = __webpack_require__(83);
	
	var _misc = __webpack_require__(102);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import * as downgrade from '../downgrade'
	function bootstrap(app, name, config, data) {
	  console.debug('[JS Framework] bootstrap for ' + name);
	
	  var cleanName = void 0;
	
	  if ((0, _misc.isWeexComponent)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	  } else if ((0, _misc.isNpmModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	    // check if define by old 'define' method
	    /* istanbul ignore if */
	    if (!app.customComponentMap[cleanName]) {
	      return new Error('It\'s not a component: ' + name);
	    }
	  } else {
	    return new Error('Wrong component name: ' + name);
	  }
	
	  config = (0, _utils.isPlainObject)(config) ? config : {};
	
	  console.log('transformerVersion: ' + config.transformerVersion + ', ' + ('available transformerVersion: ' + global.transformVersion));
	
	  // if (typeof config.transformerVersion === 'string' &&
	  //   typeof global.transformerVersion === 'string' &&
	  //   !semver.satisfies(config.transformerVersion,
	  //     global.transformerVersion)) {
	  //   return new Error(`JS Bundle version: ${config.transformerVersion} ` +
	  //     `not compatible with ${global.transformerVersion}`)
	  // }
	
	  // const _checkDowngrade = downgrade.check(config.downgrade)
	  /* istanbul ignore if */
	  // if (_checkDowngrade.isDowngrade) {
	  //   app.callTasks([{
	  //     module: 'instanceWrap',
	  //     method: 'error',
	  //     args: [
	  //       _checkDowngrade.errorType,
	  //       _checkDowngrade.code,
	  //       _checkDowngrade.errorMessage
	  //     ]
	  //   }])
	  //   return new Error(`Downgrade[${_checkDowngrade.code}]: ${_checkDowngrade.errorMessage}`)
	  // }
	
	  app.vm = new _vm2.default(cleanName, null, { _app: app }, null, data);
	} // import semver from 'semver'

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Vm;
	
	var _util = __webpack_require__(84);
	
	var _state = __webpack_require__(90);
	
	var _compiler = __webpack_require__(96);
	
	var _events = __webpack_require__(100);
	
	var _register = __webpack_require__(101);
	
	/**
	 * ViewModel constructor
	 *
	 * @param {string} type
	 * @param {object} options    component options
	 * @param {object} parentVm   which contains _app
	 * @param {object} parentEl   root element or frag block
	 * @param {object} mergedData external data
	 * @param {object} externalEvents external events
	 */
	function Vm(type, options, parentVm, parentEl, mergedData, externalEvents) {
	  this._parent = parentVm._realParent ? parentVm._realParent : parentVm;
	  this._app = parentVm._app;
	  parentVm._childrenVms && parentVm._childrenVms.push(this);
	
	  if (!options) {
	    options = this._app.customComponentMap[type] || {};
	  }
	  var data = options.data || {};
	
	  this._options = options;
	  this._methods = options.methods || {};
	  this._computed = options.computed || {};
	  this._css = options.style || {};
	  this._ids = {};
	  this._vmEvents = {};
	  this._childrenVms = [];
	  this._type = type;
	
	  // bind events and lifecycles
	  (0, _events.initEvents)(this, externalEvents);
	
	  console.debug('[JS Framework] "init" lifecycle in Vm(' + this._type + ')');
	  this.$emit('hook:init');
	  this._inited = true;
	
	  // proxy data and methods
	  // observe data and add this to vms
	  this._data = typeof data === 'function' ? data() : data;
	  if (mergedData) {
	    (0, _util.extend)(this._data, mergedData);
	  }
	  (0, _state.initState)(this);
	
	  console.debug('[JS Framework] "created" lifecycle in Vm(' + this._type + ')');
	  this.$emit('hook:created');
	  this._created = true;
	
	  // backward old ready entry
	  if (options.methods && options.methods.ready) {
	    console.warn('"exports.methods.ready" is deprecated, ' + 'please use "exports.created" instead');
	    options.methods.ready.call(this);
	  }
	
	  // if no parentElement then specify the documentElement
	  this._parentEl = parentEl || this._app.doc.documentElement;
	  (0, _compiler.build)(this);
	} /**
	   * @fileOverview
	   * ViewModel Constructor & definition
	   */
	
	(0, _events.mixinEvents)(Vm.prototype);
	
	(0, _util.extend)(Vm, {
	  registerModules: _register.registerModules,
	  registerMethods: _register.registerMethods
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.initState = initState;
	exports.initData = initData;
	exports.initComputed = initComputed;
	exports.initMethods = initMethods;
	
	var _watcher = __webpack_require__(91);
	
	var _watcher2 = _interopRequireDefault(_watcher);
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _observer = __webpack_require__(94);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	
	function initState(vm) {
	  vm._watchers = [];
	  initData(vm);
	  initComputed(vm);
	  initMethods(vm);
	}
	
	function initData(vm) {
	  var data = vm._data;
	
	  if (!(0, _util.isPlainObject)(data)) {
	    data = {};
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var i = keys.length;
	  while (i--) {
	    (0, _observer.proxy)(vm, keys[i]);
	  }
	  // observe data
	  (0, _observer.observe)(data, vm);
	}
	
	function noop() {}
	
	function initComputed(vm) {
	  var computed = vm._computed;
	  if (computed) {
	    for (var key in computed) {
	      var userDef = computed[key];
	      var def = {
	        enumerable: true,
	        configurable: true
	      };
	      if (typeof userDef === 'function') {
	        def.get = makeComputedGetter(userDef, vm);
	        def.set = noop;
	      } else {
	        def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, vm) : (0, _util.bind)(userDef.get, vm) : noop;
	        def.set = userDef.set ? (0, _util.bind)(userDef.set, vm) : noop;
	      }
	      Object.defineProperty(vm, key, def);
	    }
	  }
	}
	
	function makeComputedGetter(getter, owner) {
	  var watcher = new _watcher2.default(owner, getter, null, {
	    lazy: true
	  });
	  return function computedGetter() {
	    if (watcher.dirty) {
	      watcher.evaluate();
	    }
	    if (_dep2.default.target) {
	      watcher.depend();
	    }
	    return watcher.value;
	  };
	}
	
	function initMethods(vm) {
	  var methods = vm._methods;
	  if (methods) {
	    for (var key in methods) {
	      vm[key] = methods[key];
	    }
	  }
	}

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Watcher;
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	
	var uid = 0;
	// import { pushWatcher } from './batcher'
	
	var prevTarget = void 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    (0, _util.extend)(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _util._Set();
	  this.newDepIds = new _util._Set();
	  // parse expression for getter
	  if (isFn) {
	    this.getter = expOrFn;
	  } else {
	    this.getter = (0, _util.parsePath)(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && (0, _util.warn)('Failed watching path: ' + expOrFn + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var value = this.getter.call(this.vm, this.vm);
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  prevTarget = _dep2.default.target;
	  _dep2.default.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  _dep2.default.target = prevTarget;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else {
	    this.run();
	  }
	  // } else if (this.sync) {
	  //   this.run()
	  // } else {
	  //   // if queued, only overwrite shallow with non-shallow,
	  //   // but not the other way around.
	  //   this.shallow = this.queued
	  //     ? shallow
	  //       ? this.shallow
	  //       : false
	  //     : !!shallow
	  //   this.queued = true
	  //   pushWatcher(this)
	  // }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    ((0, _util.isObject)(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      this.cb.call(this.vm, value, oldValue);
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = _dep2.default.target;
	  this.value = this.get();
	  this.dirty = false;
	  _dep2.default.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      (0, _util.remove)(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 * @param {Set} seen
	 */
	
	var seenObjects = new _util._Set();
	function traverse(val, seen) {
	  var i = void 0,
	      keys = void 0,
	      isA = void 0,
	      isO = void 0;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  isA = Array.isArray(val);
	  isO = (0, _util.isObject)(val);
	  if (isA || isO) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) {
	        traverse(val[i], seen);
	      }
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) {
	        traverse(val[keys[i]], seen);
	      }
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)))

/***/ },
/* 92 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Dep;
	
	var _util = __webpack_require__(84);
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	
	/* eslint-disable */
	
	function Dep() {
	  this.id = uid++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  (0, _util.remove)(this.subs, sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Observer = Observer;
	exports.observe = observe;
	exports.defineReactive = defineReactive;
	exports.set = set;
	exports.del = del;
	exports.proxy = proxy;
	exports.unproxy = unproxy;
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _array = __webpack_require__(95);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var arrayKeys = Object.getOwnPropertyNames(_array.arrayMethods);
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	/* eslint-disable */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new _dep2.default();
	  (0, _util.def)(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = _util.hasProto ? protoAugment : copyAugment;
	    augment(value, _array.arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  for (var key in obj) {
	    this.convert(key, obj[key]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  (0, _util.remove)(this.vms, vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    (0, _util.def)(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!(0, _util.isObject)(value)) {
	    return;
	  }
	  var ob = void 0;
	  if ((0, _util.hasOwn)(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if ((Array.isArray(value) || (0, _util.isPlainObject)(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new _dep2.default();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (_dep2.default.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @public
	 */
	
	function set(obj, key, val) {
	  if (Array.isArray(obj)) {
	    return obj.splice(key, 1, val);
	  }
	  if ((0, _util.hasOwn)(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      proxy(vm, key);
	      vm.$forceUpdate();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!(0, _util.hasOwn)(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj.$forceUpdate();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      unproxy(vm, key);
	      vm.$forceUpdate();
	    }
	  }
	}
	
	var KEY_WORDS = ['$index', '$value', '$event'];
	function proxy(vm, key) {
	  if (KEY_WORDS.indexOf(key) > -1 || !(0, _util.isReserved)(key)) {
	    Object.defineProperty(vm, key, {
	      configurable: true,
	      enumerable: true,
	      get: function proxyGetter() {
	        return vm._data[key];
	      },
	      set: function proxySetter(val) {
	        vm._data[key] = val;
	      }
	    });
	  }
	}
	
	function unproxy(vm, key) {
	  if (!(0, _util.isReserved)(key)) {
	    delete vm[key];
	  }
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.arrayMethods = undefined;
	
	var _util = __webpack_require__(84);
	
	var arrayProto = Array.prototype; /* eslint-disable */
	
	var arrayMethods = exports.arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  (0, _util.def)(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted = void 0;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	(0, _util.def)(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = index + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index.
	 *
	 * @param {Number} index
	 * @param {*} val
	 */
	
	(0, _util.def)(arrayProto, '$remove', function $remove(index) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  if (typeof index !== 'number') {
	    index = this.indexOf(index);
	  }
	  if (index > -1) {
	    this.splice(index, 1);
	  }
	});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.build = build;
	
	var _util = __webpack_require__(84);
	
	var _state = __webpack_require__(90);
	
	var _directive = __webpack_require__(97);
	
	var _domHelper = __webpack_require__(99);
	
	/**
	 * build(externalDirs)
	 *   createVm()
	 *   merge(externalDirs, dirs)
	 *   compile(template, parentNode)
	 *     if (type is content) create contentNode
	 *     else if (dirs have v-for) foreach -> create context
	 *       -> compile(templateWithoutFor, parentNode): diff(list) onchange
	 *     else if (dirs have v-if) assert
	 *       -> compile(templateWithoutIf, parentNode): toggle(shown) onchange
	 *     else if (type is dynamic)
	 *       -> compile(templateWithoutDynamicType, parentNode): watch(type) onchange
	 *     else if (type is custom)
	 *       addChildVm(vm, parentVm)
	 *       build(externalDirs)
	 *       foreach childNodes -> compile(childNode, template)
	 *     else if (type is native)
	 *       set(dirs): update(id/attr/style/class) onchange
	 *       append(template, parentNode)
	 *       foreach childNodes -> compile(childNode, template)
	 */
	/**
	 * @fileOverview
	 * ViewModel template parser & data-binding process
	 *
	 * required:
	 * index.js: Vm
	 * dom-helper.js: createElement, createBlock
	 * dom-helper.js: attachTarget, moveTarget, removeTarget
	 * directive.js: bindElement, bindSubVm, setId, watch
	 * events.js: $on
	 */
	
	function build(vm) {
	  var opt = vm._options || {};
	  var template = opt.template || {};
	
	  if (opt.replace) {
	    if (template.children && template.children.length === 1) {
	      compile(vm, template.children[0], vm._parentEl);
	    } else {
	      compile(vm, template.children, vm._parentEl);
	    }
	  } else {
	    compile(vm, template, vm._parentEl);
	  }
	
	  console.debug('[JS Framework] "ready" lifecycle in Vm(' + vm._type + ')');
	  vm.$emit('hook:ready');
	  vm._ready = true;
	}
	
	/**
	 * Generate elements by child or children and append to parent elements.
	 * Root element info would be merged if has. The first argument may be an array
	 * if the root element with options.replace has not only one child.
	 *
	 * @param {object|array} target
	 * @param {object}       dest
	 * @param {object}       meta
	 */
	function compile(vm, target, dest, meta) {
	  var app = vm._app || {};
	
	  if (app.lastSignal === -1) {
	    return;
	  }
	
	  if (targetIsFragment(target)) {
	    compileFragment(vm, target, dest, meta);
	    return;
	  }
	  meta = meta || {};
	  if (targetIsContent(target)) {
	    console.debug('[JS Framework] compile "content" block by', target);
	    vm._content = (0, _domHelper.createBlock)(vm, dest);
	    return;
	  }
	
	  if (targetNeedCheckRepeat(target, meta)) {
	    console.debug('[JS Framework] compile "repeat" logic by', target);
	    compileRepeat(vm, target, dest);
	    return;
	  }
	  if (targetNeedCheckShown(target, meta)) {
	    console.debug('[JS Framework] compile "if" logic by', target);
	    compileShown(vm, target, dest, meta);
	    return;
	  }
	  var typeGetter = meta.type || target.type;
	  if (targetNeedCheckType(typeGetter, meta)) {
	    compileType(vm, target, dest, typeGetter, meta);
	    return;
	  }
	  var type = typeGetter;
	  var component = targetIsComposed(vm, target, type);
	  if (component) {
	    console.debug('[JS Framework] compile composed component by', target);
	    compileCustomComponent(vm, component, target, dest, type, meta);
	    return;
	  }
	  console.debug('[JS Framework] compile native component by', target);
	  compileNativeComponent(vm, target, dest, type);
	}
	
	/**
	 * Check if target is a fragment (an array).
	 *
	 * @param  {object}  target
	 * @return {boolean}
	 */
	function targetIsFragment(target) {
	  return Array.isArray(target);
	}
	
	/**
	 * Check if target type is content/slot.
	 *
	 * @param  {object}  target
	 * @return {boolean}
	 */
	function targetIsContent(target) {
	  return target.type === 'content' || target.type === 'slot';
	}
	
	/**
	 * Check if target need to compile by a list.
	 *
	 * @param  {object}  target
	 * @param  {object}  meta
	 * @return {boolean}
	 */
	function targetNeedCheckRepeat(target, meta) {
	  return !meta.hasOwnProperty('repeat') && target.repeat;
	}
	
	/**
	 * Check if target need to compile by a boolean value.
	 *
	 * @param  {object}  target
	 * @param  {object}  meta
	 * @return {boolean}
	 */
	function targetNeedCheckShown(target, meta) {
	  return !meta.hasOwnProperty('shown') && target.shown;
	}
	
	/**
	 * Check if target need to compile by a dynamic type.
	 *
	 * @param  {string|function} typeGetter
	 * @param  {object}          meta
	 * @return {boolean}
	 */
	function targetNeedCheckType(typeGetter, meta) {
	  return typeof typeGetter === 'function' && !meta.hasOwnProperty('type');
	}
	
	/**
	 * Check if this kind of component is composed.
	 *
	 * @param  {string}  type
	 * @return {boolean}
	 */
	function targetIsComposed(vm, target, type) {
	  var component = void 0;
	  if (vm._app && vm._app.customComponentMap) {
	    component = vm._app.customComponentMap[type];
	  }
	  if (vm._options && vm._options.components) {
	    component = vm._options.components[type];
	  }
	  if (target.component) {
	    component = component || {};
	  }
	  return component;
	}
	
	/**
	 * Compile a list of targets.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {object} meta
	 */
	function compileFragment(vm, target, dest, meta) {
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	  target.forEach(function (child) {
	    compile(vm, child, fragBlock, meta);
	  });
	}
	
	/**
	 * Compile a target with repeat directive.
	 *
	 * @param {object} target
	 * @param {object} dest
	 */
	function compileRepeat(vm, target, dest) {
	  var repeat = target.repeat;
	  var oldStyle = typeof repeat === 'function';
	  var getter = repeat.getter || repeat.expression || repeat;
	  if (typeof getter !== 'function') {
	    getter = function getter() {
	      return [];
	    };
	  }
	  var key = repeat.key || '$index';
	  var value = repeat.value || '$value';
	  var trackBy = repeat.trackBy || target.trackBy || target.attr && target.attr.trackBy;
	
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	  fragBlock.children = [];
	  fragBlock.data = [];
	  fragBlock.vms = [];
	
	  bindRepeat(vm, target, fragBlock, { getter: getter, key: key, value: value, trackBy: trackBy, oldStyle: oldStyle });
	}
	
	/**
	 * Compile a target with if directive.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {object} meta
	 */
	function compileShown(vm, target, dest, meta) {
	  var newMeta = { shown: true };
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	
	  if (dest.element && dest.children) {
	    dest.children.push(fragBlock);
	  }
	
	  if (meta.repeat) {
	    newMeta.repeat = meta.repeat;
	  }
	
	  bindShown(vm, target, fragBlock, newMeta);
	}
	
	/**
	 * Compile a target with dynamic component type.
	 *
	 * @param {object}   target
	 * @param {object}   dest
	 * @param {function} typeGetter
	 */
	function compileType(vm, target, dest, typeGetter, meta) {
	  var type = typeGetter.call(vm);
	  var newMeta = (0, _util.extend)({ type: type }, meta);
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	
	  if (dest.element && dest.children) {
	    dest.children.push(fragBlock);
	  }
	
	  (0, _directive.watch)(vm, typeGetter, function (value) {
	    var newMeta = (0, _util.extend)({ type: value }, meta);
	    (0, _domHelper.removeTarget)(vm, fragBlock, true);
	    compile(vm, target, fragBlock, newMeta);
	  });
	
	  compile(vm, target, fragBlock, newMeta);
	}
	
	/**
	 * Compile a composed component.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {string} type
	 */
	function compileCustomComponent(vm, component, target, dest, type, meta) {
	  var Ctor = vm.constructor;
	  var subVm = new Ctor(type, component, vm, dest, undefined, {
	    'hook:init': function hookInit() {
	      (0, _directive.setId)(vm, null, target.id, this);
	      // bind template earlier because of lifecycle issues
	      this._externalBinding = {
	        parent: vm,
	        template: target
	      };
	    },
	    'hook:created': function hookCreated() {
	      (0, _directive.bindSubVm)(vm, this, target, meta.repeat);
	    },
	    'hook:ready': function hookReady() {
	      if (this._content) {
	        compileChildren(vm, target, this._content);
	      }
	    }
	  });
	  (0, _directive.bindSubVmAfterInitialized)(vm, subVm, target);
	}
	
	/**
	 * Generate element from template and attach to the dest if needed.
	 * The time to attach depends on whether the mode status is node or tree.
	 *
	 * @param {object} template
	 * @param {object} dest
	 * @param {string} type
	 */
	function compileNativeComponent(vm, template, dest, type) {
	  (0, _directive.applyNaitveComponentOptions)(template);
	
	  var element = void 0;
	  if (dest.ref === '_documentElement') {
	    // if its parent is documentElement then it's a body
	    console.debug('[JS Framework] compile to create body for ' + type);
	    element = (0, _domHelper.createBody)(vm, type);
	  } else {
	    console.debug('[JS Framework] compile to create element for ' + type);
	    element = (0, _domHelper.createElement)(vm, type);
	  }
	
	  if (!vm._rootEl) {
	    vm._rootEl = element;
	    // bind event earlier because of lifecycle issues
	    var binding = vm._externalBinding || {};
	    var target = binding.template;
	    var parentVm = binding.parent;
	    if (target && target.events && parentVm && element) {
	      for (var _type in target.events) {
	        var handler = parentVm[target.events[_type]];
	        if (handler) {
	          element.addEvent(_type, (0, _util.bind)(handler, parentVm));
	        }
	      }
	    }
	  }
	
	  (0, _directive.bindElement)(vm, element, template);
	
	  if (template.attr && template.attr.append) {
	    // backward, append prop in attr
	    template.append = template.attr.append;
	  }
	
	  if (template.append) {
	    // give the append attribute for ios adaptation
	    element.attr = element.attr || {};
	    element.attr.append = template.append;
	  }
	
	  var treeMode = template.append === 'tree';
	  var app = vm._app || {};
	  if (app.lastSignal !== -1 && !treeMode) {
	    console.debug('[JS Framework] compile to append single node for', element);
	    app.lastSignal = (0, _domHelper.attachTarget)(vm, element, dest);
	  }
	  if (app.lastSignal !== -1) {
	    compileChildren(vm, template, element);
	  }
	  if (app.lastSignal !== -1 && treeMode) {
	    console.debug('[JS Framework] compile to append whole tree for', element);
	    app.lastSignal = (0, _domHelper.attachTarget)(vm, element, dest);
	  }
	}
	
	/**
	 * Set all children to a certain parent element.
	 *
	 * @param {object} template
	 * @param {object} dest
	 */
	function compileChildren(vm, template, dest) {
	  var app = vm._app || {};
	  var children = template.children;
	  if (children && children.length) {
	    children.every(function (child) {
	      compile(vm, child, dest);
	      return app.lastSignal !== -1;
	    });
	  }
	}
	
	/**
	 * Watch the list update and refresh the changes.
	 *
	 * @param {object} target
	 * @param {object} fragBlock {vms, data, children}
	 * @param {object} info      {getter, key, value, trackBy, oldStyle}
	 */
	function bindRepeat(vm, target, fragBlock, info) {
	  var vms = fragBlock.vms;
	  var children = fragBlock.children;
	  var getter = info.getter;
	  var trackBy = info.trackBy;
	  var oldStyle = info.oldStyle;
	
	  var keyName = info.key;
	  var valueName = info.value;
	
	  function compileItem(item, index, context) {
	    var mergedData = void 0;
	    if (oldStyle) {
	      mergedData = item;
	      if ((0, _util.isObject)(item)) {
	        mergedData[keyName] = index;
	        if (!mergedData.hasOwnProperty('INDEX')) {
	          Object.defineProperty(mergedData, 'INDEX', {
	            value: function value() {
	              console.warn('[JS Framework] "INDEX" in repeat is deprecated, ' + 'please use "$index" instead');
	            }
	          });
	        }
	      } else {
	        console.warn('[JS Framework] Each list item must be an object in old-style repeat, ' + 'please use `repeat={{v in list}}` instead.');
	        mergedData = {};
	        mergedData[keyName] = index;
	        mergedData[valueName] = item;
	      }
	    } else {
	      mergedData = {};
	      mergedData[keyName] = index;
	      mergedData[valueName] = item;
	    }
	    var newContext = mergeContext(context, mergedData);
	    vms.push(newContext);
	    compile(newContext, target, fragBlock, { repeat: item });
	  }
	
	  var list = watchBlock(vm, fragBlock, getter, 'repeat', function (data) {
	    console.debug('[JS Framework] the "repeat" item has changed', data);
	    if (!fragBlock) {
	      return;
	    }
	
	    var oldChildren = children.slice();
	    var oldVms = vms.slice();
	    var oldData = fragBlock.data.slice();
	    // 1. collect all new refs track by
	    var trackMap = {};
	    var reusedMap = {};
	    data.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      /* istanbul ignore if */
	      if (key == null || key === '') {
	        return;
	      }
	      trackMap[key] = item;
	    });
	
	    // 2. remove unused element foreach old item
	    var reusedList = [];
	    oldData.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      if (trackMap.hasOwnProperty(key)) {
	        reusedMap[key] = {
	          item: item, index: index, key: key,
	          target: oldChildren[index],
	          vm: oldVms[index]
	        };
	        reusedList.push(item);
	      } else {
	        (0, _domHelper.removeTarget)(vm, oldChildren[index]);
	      }
	    });
	
	    // 3. create new element foreach new item
	    children.length = 0;
	    vms.length = 0;
	    fragBlock.data = data.slice();
	    fragBlock.updateMark = fragBlock.start;
	
	    data.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      var reused = reusedMap[key];
	      if (reused) {
	        if (reused.item === reusedList[0]) {
	          reusedList.shift();
	        } else {
	          reusedList.$remove(reused.item);
	          (0, _domHelper.moveTarget)(vm, reused.target, fragBlock.updateMark, true);
	        }
	        children.push(reused.target);
	        vms.push(reused.vm);
	        if (oldStyle) {
	          reused.vm = item;
	        } else {
	          reused.vm[valueName] = item;
	        }
	        reused.vm[keyName] = index;
	        fragBlock.updateMark = reused.target;
	      } else {
	        compileItem(item, index, vm);
	      }
	    });
	
	    delete fragBlock.updateMark;
	  });
	
	  fragBlock.data = list.slice(0);
	  list.forEach(function (item, index) {
	    compileItem(item, index, vm);
	  });
	}
	
	/**
	 * Watch the display update and add/remove the element.
	 *
	 * @param  {object} target
	 * @param  {object} fragBlock
	 * @param  {object} context
	 */
	function bindShown(vm, target, fragBlock, meta) {
	  var display = watchBlock(vm, fragBlock, target.shown, 'shown', function (display) {
	    console.debug('[JS Framework] the "if" item was changed', display);
	
	    if (!fragBlock || !!fragBlock.display === !!display) {
	      return;
	    }
	    fragBlock.display = !!display;
	    if (display) {
	      compile(vm, target, fragBlock, meta);
	    } else {
	      (0, _domHelper.removeTarget)(vm, fragBlock, true);
	    }
	  });
	
	  fragBlock.display = !!display;
	  if (display) {
	    compile(vm, target, fragBlock, meta);
	  }
	}
	
	/**
	 * Watch calc value changes and append certain type action to differ.
	 * It is used for if or repeat data-binding generator.
	 *
	 * @param  {object}   fragBlock
	 * @param  {function} calc
	 * @param  {string}   type
	 * @param  {function} handler
	 * @return {any}      init value of calc
	 */
	function watchBlock(vm, fragBlock, calc, type, handler) {
	  var differ = vm && vm._app && vm._app.differ;
	  var config = {};
	  var depth = (fragBlock.element.depth || 0) + 1;
	
	  return (0, _directive.watch)(vm, calc, function (value) {
	    config.latestValue = value;
	    if (differ && !config.recorded) {
	      differ.append(type, depth, fragBlock.blockId, function () {
	        var latestValue = config.latestValue;
	        handler(latestValue);
	        config.recorded = false;
	        config.latestValue = undefined;
	      });
	    }
	    config.recorded = true;
	  });
	}
	
	/**
	 * Clone a context and merge certain data.
	 *
	 * @param  {object} mergedData
	 * @return {object}
	 */
	function mergeContext(context, mergedData) {
	  var newContext = Object.create(context);
	  newContext._data = mergedData;
	  (0, _state.initData)(newContext);
	  (0, _state.initComputed)(newContext);
	  newContext._realParent = context;
	  return newContext;
	}

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                   * @fileOverview
	                                                                                                                                                                                                                                                   * Directive Parser
	                                                                                                                                                                                                                                                   */
	
	exports.applyNaitveComponentOptions = applyNaitveComponentOptions;
	exports.bindElement = bindElement;
	exports.bindSubVm = bindSubVm;
	exports.bindSubVmAfterInitialized = bindSubVmAfterInitialized;
	exports.setId = setId;
	exports.watch = watch;
	
	var _util = __webpack_require__(84);
	
	var _watcher = __webpack_require__(91);
	
	var _watcher2 = _interopRequireDefault(_watcher);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var nativeComponentMap = _config2.default.nativeComponentMap;
	
	
	var SETTERS = {
	  attr: 'setAttr',
	  style: 'setStyle',
	  event: 'addEvent'
	};
	
	/**
	 * apply the native component's options(specified by template.type)
	 * to the template
	 */
	function applyNaitveComponentOptions(template) {
	  var type = template.type;
	
	  var options = nativeComponentMap[type];
	
	  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	    for (var key in options) {
	      if (template[key] == null) {
	        template[key] = options[key];
	      } else if ((0, _util.typof)(template[key]) === 'object' && (0, _util.typof)(options[key]) === 'object') {
	        for (var subkey in options[key]) {
	          if (template[key][subkey] == null) {
	            template[key][subkey] = options[key][subkey];
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * bind all id, attr, classnames, style, events to an element
	 */
	function bindElement(vm, el, template) {
	  setId(vm, el, template.id, vm);
	  setAttr(vm, el, template.attr);
	  setClass(vm, el, template.classList);
	  setStyle(vm, el, template.style);
	  bindEvents(vm, el, template.events);
	}
	
	/**
	 * bind all props to sub vm and bind all style, events to the root element
	 * of the sub vm if it doesn't have a replaced multi-node fragment
	 */
	function bindSubVm(vm, subVm, template, repeatItem) {
	  subVm = subVm || {};
	  template = template || {};
	
	  var options = subVm._options || {};
	
	  // bind props
	  var props = options.props;
	
	  if (Array.isArray(props)) {
	    props = props.reduce(function (result, value) {
	      result[value] = true;
	      return result;
	    }, {});
	  }
	
	  mergeProps(repeatItem, props, vm, subVm);
	  mergeProps(template.attr, props, vm, subVm);
	}
	
	function bindSubVmAfterInitialized(vm, subVm, template) {
	  mergeClassStyle(template.classList, vm, subVm);
	  mergeStyle(template.style, vm, subVm);
	}
	
	function mergeProps(target, props, vm, subVm) {
	  if (!target) {
	    return;
	  }
	
	  var _loop = function _loop(key) {
	    if (!props || props[key]) {
	      var value = target[key];
	      if (typeof value === 'function') {
	        var returnValue = watch(vm, value, function (v) {
	          subVm[key] = v;
	        });
	        subVm[key] = returnValue;
	      } else {
	        subVm[key] = value;
	      }
	    }
	  };
	
	  for (var key in target) {
	    _loop(key);
	  }
	}
	
	function mergeStyle(target, vm, subVm) {
	  var _loop2 = function _loop2(key) {
	    var value = target[key];
	    if (typeof value === 'function') {
	      var returnValue = watch(vm, value, function (v) {
	        if (subVm._rootEl) {
	          subVm._rootEl.setStyle(key, v);
	        }
	      });
	      subVm._rootEl.setStyle(key, returnValue);
	    } else {
	      if (subVm._rootEl) {
	        subVm._rootEl.setStyle(key, value);
	      }
	    }
	  };
	
	  for (var key in target) {
	    _loop2(key);
	  }
	}
	
	function mergeClassStyle(target, vm, subVm) {
	  var css = vm._options && vm._options.style || {};
	
	  /* istanbul ignore if */
	  if (!subVm._rootEl) {
	    return;
	  }
	
	  if (typeof target === 'function') {
	    var _value = watch(vm, target, function (v) {
	      setClassStyle(subVm._rootEl, css, v);
	    });
	    setClassStyle(subVm._rootEl, css, _value);
	  } else if (target != null) {
	    setClassStyle(subVm._rootEl, css, target);
	  }
	}
	
	/**
	 * bind id to an element
	 * each id is unique in a whole vm
	 */
	function setId(vm, el, id, target) {
	  var map = Object.create(null);
	
	  Object.defineProperties(map, {
	    vm: {
	      value: target,
	      writable: false,
	      configurable: false
	    },
	    el: {
	      get: function get() {
	        return el || target._rootEl;
	      },
	      configurable: false
	    }
	  });
	
	  if (typeof id === 'function') {
	    var handler = id;
	    id = handler.call(vm);
	    if (id) {
	      vm._ids[id] = map;
	    }
	    watch(vm, handler, function (newId) {
	      if (newId) {
	        vm._ids[newId] = map;
	      }
	    });
	  } else if (id && typeof id === 'string') {
	    vm._ids[id] = map;
	  }
	}
	
	/**
	 * bind attr to an element
	 */
	function setAttr(vm, el, attr) {
	  bindDir(vm, el, 'attr', attr);
	}
	
	function setClassStyle(el, css, classList) {
	  var classStyle = {};
	  var length = classList.length;
	
	  for (var i = 0; i < length; i++) {
	    var style = css[classList[i]];
	    if (style) {
	      for (var key in style) {
	        classStyle[key] = style[key];
	      }
	    }
	  }
	  el.setClassStyle(classStyle);
	}
	
	/**
	 * bind classnames to an element
	 */
	function setClass(vm, el, classList) {
	  if (typeof classList !== 'function' && !Array.isArray(classList)) {
	    return;
	  }
	  if (Array.isArray(classList) && !classList.length) {
	    el.setClassStyle({});
	    return;
	  }
	
	  var style = vm._options && vm._options.style || {};
	  if (typeof classList === 'function') {
	    var _value2 = watch(vm, classList, function (v) {
	      setClassStyle(el, style, v);
	    });
	    setClassStyle(el, style, _value2);
	  } else {
	    setClassStyle(el, style, classList);
	  }
	}
	
	/**
	 * bind style to an element
	 */
	function setStyle(vm, el, style) {
	  bindDir(vm, el, 'style', style);
	}
	
	/**
	 * add an event type and handler to an element and generate a dom update
	 */
	function setEvent(vm, el, type, handler) {
	  el.addEvent(type, (0, _util.bind)(handler, vm));
	}
	
	/**
	 * add all events of an element
	 */
	function bindEvents(vm, el, events) {
	  if (!events) {
	    return;
	  }
	  var keys = Object.keys(events);
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    var handler = events[key];
	    if (typeof handler === 'string') {
	      handler = vm[handler];
	      /* istanbul ignore if */
	      if (!handler) {
	        console.debug('[JS Framework] The method "' + handler + '" is not defined.');
	      }
	    }
	    setEvent(vm, el, key, handler);
	  }
	}
	
	/**
	 * set a series of members as a kind of an element
	 * for example: style, attr, ...
	 * if the value is a function then bind the data changes
	 */
	function bindDir(vm, el, name, data) {
	  if (!data) {
	    return;
	  }
	  var keys = Object.keys(data);
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    var _value3 = data[key];
	    if (typeof _value3 === 'function') {
	      bindKey(vm, el, name, key, _value3);
	    } else {
	      el[SETTERS[name]](key, _value3);
	    }
	  }
	}
	
	/**
	 * bind data changes to a certain key to a name series in an element
	 */
	function bindKey(vm, el, name, key, calc) {
	  var methodName = SETTERS[name];
	  // watch the calc, and returns a value by calc.call()
	  var value = watch(vm, calc, function (value) {
	    function handler() {
	      el[methodName](key, value);
	    }
	    var differ = vm && vm._app && vm._app.differ;
	    if (differ) {
	      differ.append('element', el.depth, el.ref, handler);
	    } else {
	      handler();
	    }
	  });
	
	  el[methodName](key, value);
	}
	
	/**
	 * watch a calc function and callback if the calc value changes
	 */
	function watch(vm, calc, callback) {
	  var watcher = new _watcher2.default(vm, calc, function (value, oldValue) {
	    /* istanbul ignore if */
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && value === oldValue) {
	      return;
	    }
	    callback(value);
	  });
	
	  return watcher.value;
	}

/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  nativeComponentMap: {
	    text: true,
	    image: true,
	    container: true,
	    slider: {
	      type: 'slider',
	      append: 'tree'
	    },
	    cell: {
	      type: 'cell',
	      append: 'tree'
	    }
	  }
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.createBody = createBody;
	exports.createElement = createElement;
	exports.createBlock = createBlock;
	exports.attachTarget = attachTarget;
	exports.moveTarget = moveTarget;
	exports.removeTarget = removeTarget;
	/**
	 * @fileOverview Document & Element Helpers.
	 *
	 * required:
	 * Document#: createElement, createComment, getRef
	 * Element#: appendChild, insertBefore, removeChild, nextSibling
	 */
	
	/**
	 * Create a body by type
	 * Using this._app.doc
	 *
	 * @param  {string} type
	 */
	function createBody(vm, type) {
	  var doc = vm._app.doc;
	  return doc.createBody(type);
	}
	
	/**
	 * Create an element by type
	 * Using this._app.doc
	 *
	 * @param  {string} type
	 */
	function createElement(vm, type) {
	  var doc = vm._app.doc;
	  return doc.createElement(type);
	}
	
	/**
	 * Create and return a frag block for an element.
	 * The frag block has a starter, ender and the element itself.
	 *
	 * @param  {object} element
	 */
	function createBlock(vm, element) {
	  var start = createBlockStart(vm);
	  var end = createBlockEnd(vm);
	  var blockId = lastestBlockId++;
	  if (element.element) {
	    var updateMark = element.updateMark;
	    if (updateMark) {
	      if (updateMark.element) {
	        updateMark = updateMark.end;
	      }
	      element.element.insertAfter(end, updateMark);
	      element.element.insertAfter(start, updateMark);
	      element.updateMark = end;
	    } else {
	      element.element.insertBefore(start, element.end);
	      element.element.insertBefore(end, element.end);
	    }
	    element = element.element;
	  } else {
	    element.appendChild(start);
	    element.appendChild(end);
	  }
	  return { start: start, end: end, element: element, blockId: blockId };
	}
	
	var lastestBlockId = 1;
	
	/**
	 * Create and return a block starter.
	 * Using this._app.doc
	 */
	function createBlockStart(vm) {
	  var doc = vm._app.doc;
	  var anchor = doc.createComment('start');
	  return anchor;
	}
	
	/**
	 * Create and return a block ender.
	 * Using this._app.doc
	 */
	function createBlockEnd(vm) {
	  var doc = vm._app.doc;
	  var anchor = doc.createComment('end');
	  return anchor;
	}
	
	/**
	 * Attach target to a certain dest using appendChild by default.
	 * If the dest is a frag block then insert before the ender.
	 * If the target is a frag block then attach the starter and ender in order.
	 *
	 * @param  {object} target
	 * @param  {object} dest
	 */
	function attachTarget(vm, target, dest) {
	  if (dest.element) {
	    var before = dest.end;
	    var after = dest.updateMark;
	    // push new target for watch list update later
	    if (dest.children) {
	      dest.children.push(target);
	    }
	    // for check repeat case
	    if (after) {
	      var signal = moveTarget(vm, target, after);
	      dest.updateMark = target.element ? target.end : target;
	      return signal;
	    } else if (target.element) {
	      dest.element.insertBefore(target.start, before);
	      dest.element.insertBefore(target.end, before);
	    } else {
	      return dest.element.insertBefore(target, before);
	    }
	  } else {
	    if (target.element) {
	      dest.appendChild(target.start);
	      dest.appendChild(target.end);
	    } else {
	      return dest.appendChild(target);
	    }
	  }
	}
	
	/**
	 * Move target before a certain element. The target maybe block or element.
	 *
	 * @param  {object} target
	 * @param  {object} before
	 */
	function moveTarget(vm, target, after) {
	  if (target.element) {
	    return moveBlock(target, after);
	  }
	  return moveElement(target, after);
	}
	
	/**
	 * Move element before a certain element.
	 *
	 * @param  {object} element
	 * @param  {object} before
	 */
	function moveElement(element, after) {
	  var parent = after.parentNode;
	  if (parent) {
	    return parent.insertAfter(element, after);
	  }
	}
	
	/**
	 * Move all elements of the block before a certain element.
	 *
	 * @param  {object} fragBlock
	 * @param  {object} before
	 */
	function moveBlock(fragBlock, after) {
	  var parent = after.parentNode;
	
	  if (parent) {
	    var _ret = function () {
	      var el = fragBlock.start;
	      var signal = void 0;
	      var group = [el];
	
	      while (el && el !== fragBlock.end) {
	        el = el.nextSibling;
	        group.push(el);
	      }
	
	      var temp = after;
	      group.every(function (el) {
	        signal = parent.insertAfter(el, temp);
	        temp = el;
	        return signal !== -1;
	      });
	
	      return {
	        v: signal
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	}
	
	/**
	 * Remove target from DOM tree.
	 * If the target is a frag block then call _removeBlock
	 *
	 * @param  {object} target
	 */
	function removeTarget(vm, target) {
	  var preserveBlock = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	  if (target.element) {
	    removeBlock(target, preserveBlock);
	  } else {
	    removeElement(target);
	  }
	}
	
	/**
	 * Remove a certain element.
	 * Using this._app.doc
	 *
	 * @param  {object} target
	 */
	function removeElement(target) {
	  var parent = target.parentNode;
	
	  if (parent) {
	    parent.removeChild(target);
	  }
	}
	
	/**
	 * Remove a frag block.
	 * The second param decides whether the block self should be removed too.
	 *
	 * @param  {object}  fragBlock
	 * @param  {Boolean} preserveBlock=false
	 */
	function removeBlock(fragBlock) {
	  var preserveBlock = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  var result = [];
	  var el = fragBlock.start.nextSibling;
	
	  while (el && el !== fragBlock.end) {
	    result.push(el);
	    el = el.nextSibling;
	  }
	
	  if (!preserveBlock) {
	    removeElement(fragBlock.start);
	  }
	  result.forEach(function (el) {
	    removeElement(el);
	  });
	  if (!preserveBlock) {
	    removeElement(fragBlock.end);
	  }
	}

/***/ },
/* 100 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.$emit = $emit;
	exports.$dispatch = $dispatch;
	exports.$broadcast = $broadcast;
	exports.$on = $on;
	exports.$off = $off;
	exports.initEvents = initEvents;
	exports.mixinEvents = mixinEvents;
	function Evt(type, detail) {
	  if (detail instanceof Evt) {
	    return detail;
	  }
	
	  this.timestamp = Date.now();
	  this.detail = detail;
	  this.type = type;
	
	  var shouldStop = false;
	  this.stop = function () {
	    shouldStop = true;
	  };
	  this.hasStopped = function () {
	    return shouldStop;
	  };
	}
	
	function $emit(type, detail) {
	  var _this = this;
	
	  var events = this._vmEvents;
	  var handlerList = events[type];
	  if (handlerList) {
	    (function () {
	      var evt = new Evt(type, detail);
	      handlerList.forEach(function (handler) {
	        handler.call(_this, evt);
	      });
	    })();
	  }
	}
	
	function $dispatch(type, detail) {
	  var evt = new Evt(type, detail);
	  this.$emit(type, evt);
	
	  if (!evt.hasStopped() && this._parent && this._parent.$dispatch) {
	    this._parent.$dispatch(type, evt);
	  }
	}
	
	function $broadcast(type, detail) {
	  var evt = new Evt(type, detail);
	  this.$emit(type, evt);
	
	  if (!evt.hasStopped() && this._childrenVms) {
	    this._childrenVms.forEach(function (subVm) {
	      subVm.$broadcast(type, evt);
	    });
	  }
	}
	
	function $on(type, handler) {
	  if (!type || typeof handler !== 'function') {
	    return;
	  }
	  var events = this._vmEvents;
	  var handlerList = events[type] || [];
	  handlerList.push(handler);
	  events[type] = handlerList;
	
	  // fixed old version lifecycle design
	  if (type === 'hook:ready' && this._ready) {
	    this.$emit('hook:ready');
	  }
	}
	
	function $off(type, handler) {
	  if (!type) {
	    return;
	  }
	  var events = this._vmEvents;
	  if (!handler) {
	    delete events[type];
	    return;
	  }
	  var handlerList = events[type];
	  if (!handlerList) {
	    return;
	  }
	  handlerList.$remove(handler);
	}
	
	var LIFE_CYCLE_TYPES = ['init', 'created', 'ready'];
	
	function initEvents(vm, externalEvents) {
	  var options = vm._options || {};
	  var events = options.events || {};
	  for (var type1 in events) {
	    vm.$on(type1, events[type1]);
	  }
	  for (var type2 in externalEvents) {
	    vm.$on(type2, externalEvents[type2]);
	  }
	  LIFE_CYCLE_TYPES.forEach(function (type) {
	    vm.$on('hook:' + type, options[type]);
	  });
	}
	
	function mixinEvents(vm) {
	  vm.$emit = $emit;
	  vm.$dispatch = $dispatch;
	  vm.$broadcast = $broadcast;
	  vm.$on = $on;
	  vm.$off = $off;
	}

/***/ },
/* 101 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.clearModules = clearModules;
	exports.getModule = getModule;
	exports.requireModule = requireModule;
	exports.registerModules = registerModules;
	exports.registerMethods = registerMethods;
	exports.requireComponent = requireComponent;
	exports.registerComponent = registerComponent;
	var nativeModules = {};
	
	function assignModules(modules, ifReplace) {
	  var _loop = function _loop(moduleName) {
	    // init `modules[moduleName][]`
	    var methods = nativeModules[moduleName];
	    if (!methods) {
	      methods = {};
	      nativeModules[moduleName] = methods;
	    }
	
	    // push each non-existed new method
	    modules[moduleName].forEach(function (method) {
	      if (typeof method === 'string') {
	        method = {
	          name: method
	        };
	      }
	
	      if (!methods[method.name] || ifReplace) {
	        methods[method.name] = method;
	      }
	    });
	  };
	
	  for (var moduleName in modules) {
	    _loop(moduleName);
	  }
	}
	
	function assignApis(Ctor, apis) {
	  var p = Ctor.prototype;
	
	  for (var apiName in apis) {
	    if (!p.hasOwnProperty(apiName)) {
	      p[apiName] = apis[apiName];
	    }
	  }
	}
	
	function clearModules() {
	  nativeModules = {};
	}
	
	function getModule(moduleName) {
	  return nativeModules[moduleName];
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function requireModule(moduleName) {
	  var _this = this;
	
	  var methods = nativeModules[moduleName];
	  var target = {};
	
	  var _loop2 = function _loop2(methodName) {
	    target[methodName] = function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      return _this.callTasks({
	        module: moduleName,
	        method: methodName,
	        args: args
	      });
	    };
	  };
	
	  for (var methodName in methods) {
	    _loop2(methodName);
	  }
	
	  return target;
	}
	
	/**
	 * @context Vm
	 */
	function registerModules(modules, ifReplace) {
	  assignModules(modules, ifReplace);
	}
	
	/**
	 * @context Vm
	 */
	function registerMethods(apis) {
	  assignApis(this, apis);
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function requireComponent(name) {
	  var customComponentMap = this.customComponentMap;
	
	  return customComponentMap[name];
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function registerComponent(name, def) {
	  var customComponentMap = this.customComponentMap;
	
	
	  if (customComponentMap[name]) {
	    console.error('[JS Framework] define a component(' + name + ') that already exists');
	    return;
	  }
	
	  customComponentMap[name] = def;
	}

/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removeWeexPrefix = removeWeexPrefix;
	exports.removeJSSurfix = removeJSSurfix;
	var WEEX_COMPONENT_REG = /^@weex-component\//;
	var WEEX_MODULE_REG = /^@weex-module\//;
	var NORMAL_MODULE_REG = /^\.{1,2}\//;
	var JS_SURFIX_REG = /\.js$/;
	
	var isWeexComponent = exports.isWeexComponent = function isWeexComponent(name) {
	  return !!name.match(WEEX_COMPONENT_REG);
	};
	var isWeexModule = exports.isWeexModule = function isWeexModule(name) {
	  return !!name.match(WEEX_MODULE_REG);
	};
	var isNormalModule = exports.isNormalModule = function isNormalModule(name) {
	  return !!name.match(NORMAL_MODULE_REG);
	};
	var isNpmModule = exports.isNpmModule = function isNpmModule(name) {
	  return !isWeexComponent(name) && !isWeexModule(name) && !isNormalModule(name);
	};
	
	function removeWeexPrefix(str) {
	  return str.replace(WEEX_COMPONENT_REG, '').replace(WEEX_MODULE_REG, '');
	}
	
	function removeJSSurfix(str) {
	  return str.replace(JS_SURFIX_REG, '');
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.define = undefined;
	exports.clearCommonModules = clearCommonModules;
	exports.register = register;
	
	var _util = __webpack_require__(84);
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _misc = __webpack_require__(102);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	var commonModules = {};
	
	function clearCommonModules() {
	  commonModules = {};
	}
	
	// define(name, factory) for primary usage
	// or
	// define(name, deps, factory) for compatibility
	// Notice: DO NOT use function define() {},
	// it will cause error after builded by webpack
	var define = exports.define = function define(name, deps, factory) {
	  var _this = this;
	
	  console.debug('[JS Framework] define a component ' + name);
	
	  if ((0, _util.typof)(deps) === 'function') {
	    factory = deps;
	    deps = [];
	  }
	
	  var _require = function _require(name) {
	    var cleanName = void 0;
	
	    if ((0, _misc.isWeexComponent)(name)) {
	      cleanName = (0, _misc.removeWeexPrefix)(name);
	      return _this.requireComponent(cleanName);
	    }
	    if ((0, _misc.isWeexModule)(name)) {
	      cleanName = (0, _misc.removeWeexPrefix)(name);
	      return _this.requireModule(cleanName);
	    }
	    if ((0, _misc.isNormalModule)(name)) {
	      cleanName = (0, _misc.removeJSSurfix)(name);
	      return commonModules[name];
	    }
	    if ((0, _misc.isNpmModule)(name)) {
	      cleanName = (0, _misc.removeJSSurfix)(name);
	      return commonModules[name];
	    }
	  };
	  var _module = { exports: {} };
	
	  var cleanName = void 0;
	  if ((0, _misc.isWeexComponent)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    this.registerComponent(cleanName, _module.exports);
	  } else if ((0, _misc.isWeexModule)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    _vm2.default.registerModules(_defineProperty({}, cleanName, _module.exports));
	  } else if ((0, _misc.isNormalModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    commonModules[cleanName] = _module.exports;
	  } else if ((0, _misc.isNpmModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    var exports = _module.exports;
	    if (exports.template || exports.style || exports.methods) {
	      // downgrade to old define method (define('componentName', factory))
	      // the exports contain one key of template, style or methods
	      // but it has risk!!!
	      this.registerComponent(cleanName, exports);
	    } else {
	      commonModules[cleanName] = _module.exports;
	    }
	  }
	};
	
	/**
	 * @deprecated
	 */
	function register(type, options) {
	  console.warn('[JS Framework] Register is deprecated, please install lastest transformer.');
	  this.registerComponent(type, options);
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateActions = updateActions;
	exports.destroy = destroy;
	exports.getRootElement = getRootElement;
	exports.fireEvent = fireEvent;
	exports.callback = callback;
	exports.refreshData = refreshData;
	
	var _util = __webpack_require__(84);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileOverview
	                                                                                                                                                                                                     * instance controls from native
	                                                                                                                                                                                                     *
	                                                                                                                                                                                                     * - fire event
	                                                                                                                                                                                                     * - callback
	                                                                                                                                                                                                     * - destroy
	                                                                                                                                                                                                     *
	                                                                                                                                                                                                     * corresponded with the API of instance manager (framework.js)
	                                                                                                                                                                                                     */
	
	
	function updateActions() {
	  this.differ.flush();
	  var tasks = [];
	  if (this.doc && this.doc.listener && this.doc.listener.updates.length) {
	    tasks.push.apply(tasks, _toConsumableArray(this.doc.listener.updates));
	    this.doc.listener.updates = [];
	  }
	  if (tasks.length) {
	    return this.callTasks(tasks);
	  }
	}
	
	function destroy() {
	  console.debug('[JS Framework] Destory an instance(' + this.id + ')');
	
	  this.id = '';
	  this.options = null;
	  this.blocks = null;
	  this.vm = null;
	  this.doc = null;
	  this.customComponentMap = null;
	  this.callbacks = null;
	}
	
	function getRootElement() {
	  var doc = this.doc || {};
	  var body = doc.body || {};
	  return body.toJSON ? body.toJSON() : {};
	}
	
	function fireEvent(ref, type, e, domChanges) {
	  var _this = this;
	
	  console.debug('[JS Framework] Fire a "' + type + '" event on an element(' + ref + ') in instance(' + this.id + ')');
	  if (Array.isArray(ref)) {
	    ref.some(function (ref) {
	      return _this.fireEvent(ref, type, e) !== false;
	    });
	    return;
	  }
	
	  var el = this.doc.getRef(ref);
	
	  if (el) {
	    this.doc.close();
	    var result = this.doc.fireEvent(el, type, e, domChanges);
	    this.updateActions();
	    this.doc.listener.updateFinish();
	    this.doc.open();
	    return result;
	  }
	
	  return new Error('invalid element reference "' + ref + '"');
	}
	
	function callback(callbackId, data, ifKeepAlive) {
	  console.debug('[JS Framework] Invoke a callback(' + callbackId + ') with', data, 'in instance(' + this.id + ')');
	
	  var callback = this.callbacks[callbackId];
	
	  if (typeof callback === 'function') {
	    this.doc.close();
	    callback(data); // data is already a object, @see: lib/runtime/index.js
	
	    if (typeof ifKeepAlive === 'undefined' || ifKeepAlive === false) {
	      this.callbacks[callbackId] = undefined;
	    }
	
	    this.updateActions();
	    this.doc.listener.updateFinish();
	    this.doc.open();
	    return;
	  }
	
	  return new Error('invalid callback id "' + callbackId + '"');
	}
	
	function refreshData(data) {
	  console.debug('[JS Framework] Refresh with', data, 'in instance[' + this.id + ']');
	
	  var vm = this.vm;
	
	  if (vm && data) {
	    this.doc.close();
	    if (typeof vm.refreshData === 'function') {
	      vm.refreshData(data);
	    } else {
	      (0, _util.extend)(vm, data);
	    }
	    this.updateActions();
	    this.doc.listener.refreshFinish();
	    this.doc.open();
	    return;
	  }
	
	  return new Error('invalid data "' + data + '"');
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = AppInstance;
	
	var _util = __webpack_require__(84);
	
	var _differ = __webpack_require__(106);
	
	var _differ2 = _interopRequireDefault(_differ);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _register = __webpack_require__(101);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function AppInstance(instanceId, options) {
	  this.id = instanceId;
	  this.options = options || {};
	  this.vm = null;
	  this.customComponentMap = {};
	  this.callbacks = {};
	  this.doc = new _config2.default.Document(instanceId, this.options.bundleUrl, null, _config2.default.Listener);
	  this.differ = new _differ2.default(instanceId);
	  this.uid = 0;
	}
	
	function normalize(app, v) {
	  var type = (0, _util.typof)(v);
	
	  switch (type) {
	    case 'undefined':
	    case 'null':
	      return '';
	    case 'regexp':
	      return v.toString();
	    case 'date':
	      return v.toISOString();
	    case 'number':
	    case 'string':
	    case 'boolean':
	    case 'array':
	    case 'object':
	      if (v instanceof _config2.default.Element) {
	        return v.ref;
	      }
	      return v;
	    case 'function':
	      app.callbacks[++app.uid] = v;
	      return app.uid.toString();
	    default:
	      return JSON.stringify(v);
	  }
	}
	
	AppInstance.prototype.callTasks = function (tasks) {
	  var _this = this;
	
	  if ((0, _util.typof)(tasks) !== 'array') {
	    tasks = [tasks];
	  }
	
	  tasks.forEach(function (task) {
	    task.args = task.args.map(function (arg) {
	      return normalize(_this, arg);
	    });
	  });
	
	  return _config2.default.sendTasks(this.id, tasks, '-1');
	};
	
	(0, _util.extend)(AppInstance.prototype, {
	  registerComponent: _register.registerComponent,
	  requireComponent: _register.requireComponent,
	  requireModule: _register.requireModule
	});

/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Differ = function () {
	  function Differ(id) {
	    _classCallCheck(this, Differ);
	
	    this.id = id;
	    this.map = [];
	    this.hooks = [];
	  }
	
	  _createClass(Differ, [{
	    key: 'isEmpty',
	    value: function isEmpty() {
	      return this.map.length === 0;
	    }
	  }, {
	    key: 'append',
	    value: function append(type, depth, ref, handler) {
	      var _this = this;
	
	      if (!this.hasTimer) {
	        this.hasTimer = true;
	        setTimeout(function () {
	          _this.hasTimer = false;
	          _this.flush(true);
	        }, 0);
	      }
	      var map = this.map;
	      if (!map[depth]) {
	        map[depth] = {};
	      }
	      var group = map[depth];
	      if (!group[type]) {
	        group[type] = {};
	      }
	      if (type === 'element') {
	        if (!group[type][ref]) {
	          group[type][ref] = [];
	        }
	        group[type][ref].push(handler);
	      } else {
	        group[type][ref] = handler;
	      }
	    }
	  }, {
	    key: 'flush',
	    value: function flush(isTimeout) {
	      var map = this.map.slice();
	      this.map.length = 0;
	      map.forEach(function (group) {
	        callTypeMap(group, 'repeat');
	        callTypeMap(group, 'shown');
	        callTypeList(group, 'element');
	      });
	
	      var hooks = this.hooks.slice();
	      this.hooks.length = 0;
	      hooks.forEach(function (fn) {
	        fn();
	      });
	
	      if (!this.isEmpty()) {
	        this.flush();
	      }
	    }
	  }, {
	    key: 'then',
	    value: function then(fn) {
	      this.hooks.push(fn);
	    }
	  }]);
	
	  return Differ;
	}();
	
	exports.default = Differ;
	
	
	function callTypeMap(group, type) {
	  var map = group[type];
	  for (var ref in map) {
	    map[ref]();
	  }
	}
	
	function callTypeList(group, type) {
	  var map = group[type];
	  for (var ref in map) {
	    var list = map[ref];
	    list.forEach(function (handler) {
	      handler();
	    });
	  }
	}

/***/ },
/* 107 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var instanceMap = exports.instanceMap = {};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init = init;
	exports.refreshInstance = refreshInstance;
	exports.destroyInstance = destroyInstance;
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _map = __webpack_require__(107);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(cfg) {
	  _config2.default.Document = cfg.Document;
	  _config2.default.Element = cfg.Element;
	  _config2.default.Comment = cfg.Comment;
	  _config2.default.sendTasks = cfg.sendTasks;
	  _config2.default.Listener = cfg.Listener;
	}
	
	/**
	 * refresh a Weex instance
	 *
	 * @param  {string} instanceId
	 * @param  {object} data
	 */
	function refreshInstance(instanceId, data) {
	  var instance = _map.instanceMap[instanceId];
	  var result = void 0;
	  if (instance) {
	    result = instance.refreshData(data);
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	  return result;
	}
	
	/**
	 * destroy a Weex instance
	 * @param  {string} instanceId
	 */
	function destroyInstance(instanceId) {
	  var instance = _map.instanceMap[instanceId];
	  if (!instance) {
	    return new Error('invalid instance id "' + instanceId + '"');
	  }
	
	  instance.destroy();
	  delete _map.instanceMap[instanceId];
	  return _map.instanceMap;
	}

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.registerComponents = registerComponents;
	exports.registerModules = registerModules;
	exports.registerMethods = registerMethods;
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var nativeComponentMap = _config2.default.nativeComponentMap;
	
	/**
	 * register the name of each native component
	 * @param  {array} components array of name
	 */
	
	function registerComponents(components) {
	  if (Array.isArray(components)) {
	    components.forEach(function register(name) {
	      /* istanbul ignore if */
	      if (!name) {
	        return;
	      }
	      if (typeof name === 'string') {
	        nativeComponentMap[name] = true;
	      } else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && typeof name.type === 'string') {
	        nativeComponentMap[name.type] = name;
	      }
	    });
	  }
	}
	
	/**
	 * register the name and methods of each module
	 * @param  {object} modules a object of modules
	 */
	function registerModules(modules) {
	  if ((typeof modules === 'undefined' ? 'undefined' : _typeof(modules)) === 'object') {
	    _vm2.default.registerModules(modules);
	  }
	}
	
	/**
	 * register the name and methods of each api
	 * @param  {object} apis a object of apis
	 */
	function registerMethods(apis) {
	  if ((typeof apis === 'undefined' ? 'undefined' : _typeof(apis)) === 'object') {
	    _vm2.default.registerMethods(apis);
	  }
	}
	global.registerMethods = registerMethods;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.receiveTasks = receiveTasks;
	
	var _map = __webpack_require__(107);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var jsHandlers = {
	  fireEvent: function fireEvent(instanceId, ref, type, data, domChanges) {
	    var instance = _map.instanceMap[instanceId];
	    return instance.fireEvent(ref, type, data, domChanges);
	  },
	
	  callback: function callback(instanceId, funcId, data, ifLast) {
	    var instance = _map.instanceMap[instanceId];
	    return instance.callback(funcId, data, ifLast);
	  }
	};
	
	/**
	 * accept calls from native (event or callback)
	 *
	 * @param  {string} instanceId
	 * @param  {array} tasks list with `method` and `args`
	 */
	function receiveTasks(instanceId, tasks) {
	  var instance = _map.instanceMap[instanceId];
	  if (instance && Array.isArray(tasks)) {
	    var _ret = function () {
	      var results = [];
	      tasks.forEach(function (task) {
	        var handler = jsHandlers[task.method];
	        var args = [].concat(_toConsumableArray(task.args));
	        if (typeof handler === 'function') {
	          args.unshift(instanceId);
	          results.push(handler.apply(undefined, _toConsumableArray(args)));
	        }
	      });
	      return {
	        v: results
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	  return new Error('invalid instance id "' + instanceId + '" or tasks');
	}

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getRoot = getRoot;
	
	var _map = __webpack_require__(107);
	
	/**
	 * get a whole element tree of an instance
	 * for debugging
	 * @param  {string} instanceId
	 * @return {object} a virtual dom tree
	 */
	function getRoot(instanceId) {
	  var instance = _map.instanceMap[instanceId];
	  var result = void 0;
	  if (instance) {
	    result = instance.getRootElement();
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	  return result;
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.instanceMap = undefined;
	exports.Document = Document;
	exports.Node = Node;
	exports.Element = Element;
	exports.Comment = Comment;
	
	var _utils = __webpack_require__(8);
	
	var DEFAULT_TAG_NAME = 'div'; /**
	                               * @fileOverview
	                               * A simple virtual dom implementation
	                               */
	// import { extend } from '../shared'
	
	
	var instanceMap = exports.instanceMap = {};
	var nextNodeRef = 1;
	
	function Document(id, url, handler, Listener) {
	  id = id ? id.toString() : '';
	  this.id = id;
	  this.URL = url;
	
	  instanceMap[id] = this;
	  this.nodeMap = {};
	  Listener && (this.listener = new Listener(id, handler || genCallTasks(id)));
	  this.createDocumentElement();
	}
	
	function genCallTasks(id) {
	  return function (tasks) {
	    if (!Array.isArray(tasks)) {
	      tasks = [tasks];
	    }
	    return callNative(id, tasks, '-1');
	  };
	}
	
	Document.prototype.destroy = function () {
	  delete this.listener;
	  delete this.nodeMap;
	  delete instanceMap[this.id];
	};
	
	Document.prototype.open = function () {
	  this.listener.batched = false;
	};
	
	Document.prototype.close = function () {
	  this.listener.batched = true;
	};
	
	Document.prototype.createDocumentElement = function () {
	  var _this = this;
	
	  if (!this.documentElement) {
	    var el = new Element('document');
	    el.docId = this.id;
	    el.ownerDocument = this;
	    el.role = 'documentElement';
	    el.depth = 0;
	    el.ref = '_documentElement';
	    this.nodeMap._documentElement = el;
	    this.documentElement = el;
	    el.appendChild = function (node) {
	      appendBody(_this, node);
	    };
	    el.insertBefore = function (node, before) {
	      appendBody(_this, node, before);
	    };
	  }
	
	  return this.documentElement;
	};
	
	function appendBody(doc, node, before) {
	  var documentElement = doc.documentElement;
	
	
	  if (documentElement.pureChildren.length > 0 || node.parentNode) {
	    return;
	  }
	  var children = documentElement.children;
	  var beforeIndex = children.indexOf(before);
	  if (beforeIndex < 0) {
	    children.push(node);
	  } else {
	    children.splice(beforeIndex, 0, node);
	  }
	
	  if (node.nodeType === 1) {
	    if (node.role === 'body') {
	      node.docId = doc.id;
	      node.ownerDocument = doc;
	      node.parentNode = documentElement;
	    } else {
	      node.children.forEach(function (child) {
	        child.parentNode = node;
	      });
	      setBody(doc, node);
	      node.docId = doc.id;
	      node.ownerDocument = doc;
	      linkParent(node, documentElement);
	      delete doc.nodeMap[node.nodeId];
	    }
	    documentElement.pureChildren.push(node);
	    doc.listener.createBody(node);
	  } else {
	    node.parentNode = documentElement;
	    doc.nodeMap[node.ref] = node;
	  }
	}
	
	function setBody(doc, el) {
	  el.role = 'body';
	  el.depth = 1;
	  delete doc.nodeMap[el.nodeId];
	  el.ref = '_root';
	  doc.nodeMap._root = el;
	  doc.body = el;
	}
	
	Document.prototype.createBody = function (type, props) {
	  if (!this.body) {
	    var el = new Element(type, props);
	    setBody(this, el);
	  }
	
	  return this.body;
	};
	
	Document.prototype.createElement = function (tagName, props) {
	  return new Element(tagName, props);
	};
	
	Document.prototype.createComment = function (text) {
	  return new Comment(text);
	};
	
	Document.prototype.fireEvent = function (el, type, e, domChanges) {
	  if (!el) {
	    return;
	  }
	  e = e || {};
	  e.type = type;
	  e.target = el;
	  e.timestamp = Date.now();
	  if (domChanges) {
	    updateElement(el, domChanges);
	  }
	  return el.fireEvent(type, e);
	};
	
	Document.prototype.getRef = function (ref) {
	  return this.nodeMap[ref];
	};
	
	function updateElement(el, changes) {
	  var attrs = changes.attrs || {};
	  for (var name in attrs) {
	    el.setAttr(name, attrs[name], true);
	  }
	  var style = changes.style || {};
	  for (var _name in style) {
	    el.setStyle(_name, style[_name], true);
	  }
	}
	
	function Node() {
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.children = [];
	  this.pureChildren = [];
	  this.parentNode = null;
	  this.nextSibling = null;
	  this.previousSibling = null;
	}
	
	Node.prototype.destroy = function () {
	  var doc = instanceMap[this.docId];
	  if (doc) {
	    delete this.docId;
	    delete doc.nodeMap[this.nodeId];
	  }
	  this.children.forEach(function (child) {
	    child.destroy();
	  });
	};
	
	function Element() {
	  var type = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_TAG_NAME : arguments[0];
	  var props = arguments[1];
	
	  props = props || {};
	  this.nodeType = 1;
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.type = type;
	  this.attr = props.attr || {};
	  this.classStyle = props.classStyle || {};
	  this.style = props.style || {};
	  this.event = {};
	  this.children = [];
	  this.pureChildren = [];
	}
	
	Element.prototype = new Node();
	
	Element.prototype.appendChild = function (node) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.length, true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      insertIndex(node, this.pureChildren, this.pureChildren.length);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, -1);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.length, true);
	    if (node.nodeType === 1) {
	      var index = moveIndex(node, this.pureChildren, this.pureChildren.length);
	      if (this.docId && index >= 0) {
	        var _listener = instanceMap[this.docId].listener;
	        return _listener.moveElement(node.ref, this.ref, index);
	      }
	    }
	  }
	};
	
	Element.prototype.insertBefore = function (node, before) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (node === before || node.nextSibling === before) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.indexOf(before), true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      var pureBefore = nextElement(before);
	      var index = insertIndex(node, this.pureChildren, pureBefore ? this.pureChildren.indexOf(pureBefore) : this.pureChildren.length);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, index);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.indexOf(before), true);
	    if (node.nodeType === 1) {
	      var _pureBefore = nextElement(before);
	      var _index = moveIndex(node, this.pureChildren, _pureBefore ? this.pureChildren.indexOf(_pureBefore) : this.pureChildren.length);
	      if (this.docId && _index >= 0) {
	        var _listener2 = instanceMap[this.docId].listener;
	        return _listener2.moveElement(node.ref, this.ref, _index);
	      }
	    }
	  }
	};
	
	Element.prototype.insertAfter = function (node, after) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (node === after || node.previousSibling === after) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.indexOf(after) + 1, true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      var index = insertIndex(node, this.pureChildren, this.pureChildren.indexOf(previousElement(after)) + 1);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, index);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.indexOf(after) + 1, true);
	    if (node.nodeType === 1) {
	      var _index2 = moveIndex(node, this.pureChildren, this.pureChildren.indexOf(previousElement(after)) + 1);
	      if (this.docId && _index2 >= 0) {
	        var _listener3 = instanceMap[this.docId].listener;
	        return _listener3.moveElement(node.ref, this.ref, _index2);
	      }
	    }
	  }
	};
	
	Element.prototype.removeChild = function (node, preserved) {
	  if (node.parentNode) {
	    removeIndex(node, this.children, true);
	    if (node.nodeType === 1) {
	      removeIndex(node, this.pureChildren);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        listener.removeElement(node.ref);
	      }
	    }
	  }
	  if (!preserved) {
	    node.destroy();
	  }
	};
	
	Element.prototype.clear = function () {
	  var _this2 = this;
	
	  if (this.docId) {
	    (function () {
	      var listener = instanceMap[_this2.docId].listener;
	      _this2.pureChildren.forEach(function (node) {
	        listener.removeElement(node.ref);
	      });
	    })();
	  }
	  this.children.forEach(function (node) {
	    node.destroy();
	  });
	  this.children.length = 0;
	  this.pureChildren.length = 0;
	};
	
	function nextElement(node) {
	  while (node) {
	    if (node.nodeType === 1) {
	      return node;
	    }
	    node = node.nextSibling;
	  }
	}
	
	function previousElement(node) {
	  while (node) {
	    if (node.nodeType === 1) {
	      return node;
	    }
	    node = node.previousSibling;
	  }
	}
	
	function linkParent(node, parent) {
	  node.parentNode = parent;
	  if (parent.docId) {
	    node.docId = parent.docId;
	    node.ownerDocument = parent.ownerDocument;
	    node.ownerDocument.nodeMap[node.nodeId] = node;
	    node.depth = parent.depth + 1;
	  }
	  node.children.forEach(function (child) {
	    linkParent(child, node);
	  });
	}
	
	function registerNode(docId, node) {
	  var doc = instanceMap[docId];
	  doc.nodeMap[node.nodeId] = node;
	}
	
	function insertIndex(target, list, newIndex, changeSibling) {
	  if (newIndex < 0) {
	    newIndex = 0;
	  }
	  var before = list[newIndex - 1];
	  var after = list[newIndex];
	  list.splice(newIndex, 0, target);
	  if (changeSibling) {
	    before && (before.nextSibling = target);
	    target.previousSibling = before;
	    target.nextSibling = after;
	    after && (after.previousSibling = target);
	  }
	  return newIndex;
	}
	
	function moveIndex(target, list, newIndex, changeSibling) {
	  var index = list.indexOf(target);
	  if (index < 0) {
	    return -1;
	  }
	  if (changeSibling) {
	    var before = list[index - 1];
	    var after = list[index + 1];
	    before && (before.nextSibling = after);
	    after && (after.previousSibling = before);
	  }
	  list.splice(index, 1);
	  var newIndexAfter = newIndex;
	  if (index <= newIndex) {
	    newIndexAfter = newIndex - 1;
	  }
	  var beforeNew = list[newIndexAfter - 1];
	  var afterNew = list[newIndexAfter];
	  list.splice(newIndexAfter, 0, target);
	  if (changeSibling) {
	    beforeNew && (beforeNew.nextSibling = target);
	    target.previousSibling = beforeNew;
	    target.nextSibling = afterNew;
	    afterNew && (afterNew.previousSibling = target);
	  }
	  if (index === newIndexAfter) {
	    return -1;
	  }
	  return newIndex;
	}
	
	function removeIndex(target, list, changeSibling) {
	  var index = list.indexOf(target);
	  if (index < 0) {
	    return;
	  }
	  if (changeSibling) {
	    var before = list[index - 1];
	    var after = list[index + 1];
	    before && (before.nextSibling = after);
	    after && (after.previousSibling = before);
	  }
	  list.splice(index, 1);
	}
	
	Element.prototype.setAttr = function (key, value, silent) {
	  if (this.attr[key] === value) {
	    return;
	  }
	  this.attr[key] = value;
	  if (!silent && this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setAttr(this.ref, key, value);
	  }
	};
	
	Element.prototype.setStyle = function (key, value, silent) {
	  if (this.style[key] === value) {
	    return;
	  }
	  this.style[key] = value;
	  if (!silent && this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setStyle(this.ref, key, value);
	  }
	};
	
	Element.prototype.setClassStyle = function (classStyle) {
	  this.classStyle = classStyle;
	  if (this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setStyles(this.ref, this.toStyle());
	  }
	};
	
	Element.prototype.addEvent = function (type, handler) {
	  if (!this.event[type]) {
	    this.event[type] = handler;
	    if (this.docId) {
	      var listener = instanceMap[this.docId].listener;
	      listener.addEvent(this.ref, type);
	    }
	  }
	};
	
	Element.prototype.removeEvent = function (type) {
	  if (this.event[type]) {
	    delete this.event[type];
	    if (this.docId) {
	      var listener = instanceMap[this.docId].listener;
	      listener.removeEvent(this.ref, type);
	    }
	  }
	};
	
	Element.prototype.fireEvent = function (type, e) {
	  var handler = this.event[type];
	  if (handler) {
	    return handler.call(this, e);
	  }
	};
	
	Element.prototype.toStyle = function () {
	  return (0, _utils.extend)({}, this.classStyle, this.style);
	};
	
	Element.prototype.toJSON = function () {
	  var result = {
	    ref: this.ref.toString(),
	    type: this.type,
	    attr: this.attr,
	    style: this.toStyle()
	  };
	  var event = Object.keys(this.event);
	  if (event.length) {
	    result.event = event;
	  }
	  if (this.pureChildren.length) {
	    result.children = this.pureChildren.map(function (child) {
	      return child.toJSON();
	    });
	  }
	  return result;
	};
	
	Element.prototype.toString = function () {
	  return '<' + this.type + ' attr=' + JSON.stringify(this.attr) + ' style=' + JSON.stringify(this.toStyle()) + '>' + this.pureChildren.map(function (child) {
	    return child.toString();
	  }).join('') + '</' + this.type + '>';
	};
	
	function Comment(value) {
	  this.nodeType = 8;
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.type = 'comment';
	  this.value = value;
	  this.children = [];
	  this.pureChildren = [];
	}
	
	Comment.prototype = new Node();
	
	Comment.prototype.toString = function () {
	  return '<!-- ' + this.value + ' -->';
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.$ = $;
	exports.$el = $el;
	exports.$vm = $vm;
	exports.$renderThen = $renderThen;
	exports.$scrollTo = $scrollTo;
	exports.$transition = $transition;
	exports.$getConfig = $getConfig;
	exports.$sendHttp = $sendHttp;
	exports.$openURL = $openURL;
	exports.$setTitle = $setTitle;
	exports.$call = $call;
	
	var _util = __webpack_require__(84);
	
	/**
	 * ==========================================================
	 * common
	 * ==========================================================
	 */
	
	/**
	 * @deprecated use $vm instead
	 * find the vm by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Vm}
	 */
	function $(id) {
	  console.warn('[JS Framework] Vm#$ is deprecated, please use Vm#$vm instead');
	  var info = this._ids[id];
	  if (info) {
	    return info.vm;
	  }
	}
	
	/**
	 * find the element by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Element}
	 */
	/**
	 * @fileOverview The api for invoking with "$" prefix
	 */
	function $el(id) {
	  var info = this._ids[id];
	  if (info) {
	    return info.el;
	  }
	}
	
	/**
	 * find the vm of the custom component by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Vm}
	 */
	function $vm(id) {
	  var info = this._ids[id];
	  if (info) {
	    return info.vm;
	  }
	}
	
	/**
	 * Fire when differ rendering finished
	 *
	 * @param  {Function} fn
	 */
	function $renderThen(fn) {
	  var app = this._app;
	  var differ = app.differ;
	  return differ.then(function () {
	    fn();
	  });
	}
	
	/**
	 * scroll an element specified by id into view,
	 * moreover specify a number of offset optionally
	 * @param  {string} id
	 * @param  {number} offset
	 */
	function $scrollTo(id, offset) {
	  console.warn('[JS Framework] Vm#$scrollTo is deprecated, ' + 'please use "require(\'@weex-module/dom\')' + '.scrollTo(el, options)" instead');
	  var el = this.$el(id);
	  if (el) {
	    var dom = this._app.requireModule('dom');
	    dom.scrollToElement(el.ref, { offset: offset });
	  }
	}
	
	/**
	 * perform transition animation on an element specified by id
	 * @param  {string}   id
	 * @param  {object}   options
	 * @param  {object}   options.styles
	 * @param  {object}   options.duration(ms)
	 * @param  {object}   [options.timingFunction]
	 * @param  {object}   [options.delay=0(ms)]
	 * @param  {Function} callback
	 */
	function $transition(id, options, callback) {
	  var _this = this;
	
	  var el = this.$el(id);
	  if (el && options && options.styles) {
	    var animation = this._app.requireModule('animation');
	    animation.transition(el.ref, options, function () {
	      _this._setStyle(el, options.styles);
	      callback && callback.apply(undefined, arguments);
	    });
	  }
	}
	
	/**
	 * get some config
	 * @return {object} some config for app instance
	 * @property {string} bundleUrl
	 * @property {boolean} debug
	 * @property {object} env
	 * @property {string} env.weexVersion(ex. 1.0.0)
	 * @property {string} env.appName(ex. TB/TM)
	 * @property {string} env.appVersion(ex. 5.0.0)
	 * @property {string} env.platform(ex. iOS/Android)
	 * @property {string} env.osVersion(ex. 7.0.0)
	 * @property {string} env.deviceModel **native only**
	 * @property {number} env.[deviceWidth=750]
	 * @property {number} env.deviceHeight
	 */
	function $getConfig(callback) {
	  var config = (0, _util.extend)({
	    env: global.WXEnvironment || {}
	  }, this._app.options);
	  if ((0, _util.typof)(callback) === 'function') {
	    console.warn('[JS Framework] the callback of Vm#$getConfig(callback) is deprecated, ' + 'this api now can directly RETURN config info.');
	    callback(config);
	  }
	  return config;
	}
	
	/**
	 * @deprecated
	 * request network via http protocol
	 * @param  {object}   params
	 * @param  {Function} callback
	 */
	function $sendHttp(params, callback) {
	  console.warn('[JS Framework] Vm#$sendHttp is deprecated, ' + 'please use "require(\'@weex-module/stream\')' + '.sendHttp(params, callback)" instead');
	  var stream = this._app.requireModule('stream');
	  stream.sendHttp(params, callback);
	}
	
	/**
	 * @deprecated
	 * open a url
	 * @param  {string} url
	 */
	function $openURL(url) {
	  console.warn('[JS Framework] Vm#$openURL is deprecated, ' + 'please use "require(\'@weex-module/event\')' + '.openURL(url)" instead');
	  var event = this._app.requireModule('event');
	  event.openURL(url);
	}
	
	/**
	 * @deprecated
	 * set a title for page
	 * @param  {string} title
	 */
	function $setTitle(title) {
	  console.warn('[JS Framework] Vm#$setTitle is deprecated, ' + 'please use "require(\'@weex-module/pageInfo\')' + '.setTitle(title)" instead');
	  var pageInfo = this._app.requireModule('pageInfo');
	  pageInfo.setTitle(title);
	}
	
	/**
	 * @deprecated use "require('@weex-module/moduleName') instead"
	 * invoke a native method by specifing the name of module and method
	 * @param  {string} moduleName
	 * @param  {string} methodName
	 * @param  {...*} the rest arguments
	 */
	function $call(moduleName, methodName) {
	  console.warn('[JS Framework] Vm#$call is deprecated, ' + 'please use "require(\'@weex-module/moduleName\')" instead');
	  var module = this._app.requireModule(moduleName);
	  if (module && module[methodName]) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    module[methodName].apply(module, args);
	  }
	}

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* global Event */
	
	'use strict';
	
	// const FrameUpdater = require('./frameUpdater')
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ComponentManager;
	
	var _appearWatcher = __webpack_require__(115);
	
	var _utils = __webpack_require__(83);
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	// const lazyload = require('./lazyload')
	// const animation = require('./animation')
	
	var RENDERING_INDENT = 800;
	
	var _instanceMap = {};
	var typeMap = {};
	var scrollableTypes = ['scroller', 'hscroller', 'vscroller', 'list', 'hlist', 'vlist'];
	
	function ComponentManager(id) {
	  this.id = id;
	  this.batched = false;
	  this.updates = [];
	  this.componentMap = {};
	  _instanceMap[this.id] = this;
	}
	
	ComponentManager.getInstance = function (instanceId) {
	  return _instanceMap[instanceId];
	};
	
	ComponentManager.registerComponent = function (type, definition) {
	  typeMap[type] = definition;
	};
	
	ComponentManager.getScrollableTypes = function () {
	  return scrollableTypes;
	};
	
	ComponentManager.prototype = {
	  getWeexInstance: function getWeexInstance() {
	    if (!this._weexInstance) {
	      this._weexInstance = global.weex ? global.weex.getInstance(this.id) : null;
	    }
	    return this._weexInstance;
	  },
	
	
	  // Fire a event 'renderbegin'/'renderend' on body element.
	  rendering: function rendering() {
	    function _renderingEnd() {
	      // get weex instance root
	      window.dispatchEvent(new Event('renderend'));
	      this._renderingTimer = null;
	    }
	    if (this._renderingTimer) {
	      clearTimeout(this._renderingTimer);
	      this._renderingTimer = setTimeout(_renderingEnd.bind(this), RENDERING_INDENT);
	    } else {
	      window.dispatchEvent(new Event('renderbegin'));
	      this._renderingTimer = setTimeout(_renderingEnd.bind(this), RENDERING_INDENT);
	    }
	  },
	  getComponent: function getComponent(ref) {
	    return this.componentMap[ref];
	  },
	  removeComponent: function removeComponent(ref) {
	    var self = this;
	    if (!ref || !this.componentMap[ref]) {
	      return;
	    }
	    // remove from this.componentMap cursively
	    (function _removeCursively(_ref) {
	      var child = self.componentMap[_ref];
	      var listeners = child._listeners;
	      var children = child.data.children;
	      if (children && children.length) {
	        for (var i = 0, l = children.length; i < l; i++) {
	          _removeCursively(children[i].ref);
	        }
	      }
	      // remove events from _ref component
	      if (listeners) {
	        for (var type in listeners) {
	          child.node.removeEventListener(type, listeners[type]);
	        }
	      }
	      delete child._listeners;
	      delete child.node._listeners;
	      // remove _ref component
	      delete self.componentMap[_ref];
	    })(ref);
	  },
	  createElement: function createElement(data, nodeType) {
	    var ComponentType = typeMap[data.type];
	    if (!ComponentType) {
	      ComponentType = typeMap['div'];
	    }
	
	    data.instanceId = this.id;
	    data.scale = this.getWeexInstance().scale;
	    var component = new ComponentType(data, nodeType);
	    var ref = data.ref;
	    this.componentMap[ref] = component;
	    component.node.setAttribute('data-ref', ref);
	
	    return component;
	  },
	
	
	  /**
	   * createBody: generate root component
	   * @param  {object} element
	   */
	  createBody: function createBody(element) {
	    console.log('[h5-render] createBody', element);
	    if (this.componentMap['_root']) {
	      return;
	    }
	    element = element.toJSON();
	
	    var nodeType = element.type;
	    element.type = 'root';
	    element.rootId = this.getWeexInstance().rootId;
	    element.ref = '_root';
	
	    var root = this.createElement(element, nodeType);
	    var body = document.querySelector('#' + this.getWeexInstance().rootId) || document.body;
	    body.appendChild(root.node);
	    root._appended = true;
	
	    this.handleAppend(root);
	  },
	  appendChild: function appendChild(parentRef, data) {
	    var parent = this.componentMap[parentRef];
	
	    if (this.componentMap[data.ref] || !parent) {
	      return;
	    }
	
	    if (parentRef === '_root' && !parent) {
	      parent = this.createElement({
	        type: 'root',
	        rootId: this.getWeexInstance().rootId,
	        ref: '_root'
	      });
	      parent._appended = true;
	    }
	
	    var child = parent.appendChild(data);
	
	    // In some parent component the implementation of method
	    // appendChild didn't return the component at all, therefor
	    // child maybe a undefined object.
	    if (child) {
	      child.parentRef = parentRef;
	    }
	
	    if (child && parent._appended) {
	      this.handleAppend(child);
	    }
	  },
	
	
	  // appendChildren (ref, elements) {
	  //   for (let i = 0; i < elements.length; i++) {
	  //     this.appendChild(ref, elements[i])
	  //   }
	  // },
	
	  removeElement: function removeElement(ref) {
	    var _this = this;
	
	    if ((0, _utils.isArray)(ref)) {
	      return ref.map(function (r) {
	        return _this.removeElement(r);
	      });
	    }
	    var component = this.componentMap[ref];
	    // fire event for rendering dom on body elment.
	    this.rendering();
	
	    if (component && component.parentRef) {
	      var parent = this.componentMap[component.parentRef];
	      component.onRemove && component.onRemove();
	      parent.removeChild(component);
	    } else if (!component) {
	      console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    } else {
	      console.error('[h5-render] parent component \'' + component.parentRef + '\' does not exist.');
	    }
	  },
	  moveElement: function moveElement(ref, parentRef, index) {
	    var component = this.componentMap[ref];
	    var newParent = this.componentMap[parentRef];
	    var oldParentRef = component.parentRef;
	    var children = void 0,
	        before = void 0,
	        i = void 0,
	        l = void 0;
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    if (!newParent) {
	      return console.error('[h5-render] parent component \'' + parentRef + '\' does not exist.');
	    }
	
	    if (index < -1) {
	      index = -1;
	      return console.error('[h5-render] index cannot be less than -1.');
	    }
	
	    // fire event for rendering.
	    this.rendering();
	
	    children = newParent.data.children;
	    if (children && children.length && index !== -1 && index < children.length) {
	      before = this.componentMap[newParent.data.children[index].ref];
	    }
	
	    // remove from oldParent.data.children
	    if (oldParentRef && this.componentMap[oldParentRef]) {
	      children = this.componentMap[oldParentRef].data.children;
	      if (children && children.length) {
	        for (i = 0, l = children.length; i < l; i++) {
	          if (children[i].ref === ref) {
	            break;
	          }
	        }
	        if (l > i) {
	          children.splice(i, 1);
	        }
	      }
	    }
	
	    newParent.insertBefore(component, before);
	
	    component.onMove && component.onMove(parentRef, index);
	  },
	  insertBefore: function insertBefore(ref, data) {
	    var child = void 0,
	        parent = void 0;
	    var before = this.componentMap[ref];
	    child = this.componentMap[data.ref];
	    before && (parent = this.componentMap[before.parentRef]);
	    if (child || !parent || !before) {
	      return;
	    }
	
	    child = this.createElement(data);
	    if (child) {
	      child.parentRef = before.parentRef;
	      parent.insertBefore(child, before);
	    } else {
	      return;
	    }
	
	    if (this.componentMap[before.parentRef]._appended) {
	      this.handleAppend(child);
	    }
	  },
	
	
	  /**
	   * addElement
	   * If index is larget than any child's index, the
	   * element will be appended behind.
	   * @param {string} parentRef
	   * @param {obj} element (data of the component)
	   * @param {number} index
	   */
	  addElement: function addElement(element, parentRef, index) {
	    // fire event for rendering dom on body elment.
	    element = element.toJSON();
	    this.rendering();
	
	    var parent = this.componentMap[parentRef];
	    if (!parent) {
	      return;
	    }
	    var children = parent.data.children;
	    // -1 means append as the last.
	    if (index < -1) {
	      index = -1;
	      return console.error('[h5-render] index cannot be less than -1.');
	    }
	    if (children && children.length && children.length > index && index !== -1) {
	      this.insertBefore(children[index].ref, element);
	    } else {
	      this.appendChild(parentRef, element);
	    }
	  },
	  addEvent: function addEvent(ref, type) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.bindEvents([type]);
	  },
	  removeEvent: function removeEvent(ref, type) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.unbindEvents([type]);
	  },
	  setAttr: function setAttr(ref, key, value) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateAttrs(_defineProperty({}, key, value));
	    // if (component.data.type === 'image' && key === 'src') {
	    //  component.fire
	    //  lazyload.startIfNeeded(component)
	    // }
	  },
	  setStyle: function setStyle(ref, key, value) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateStyle(_defineProperty({}, key, value));
	  },
	  setStyles: function setStyles(ref, style) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateStyle(style);
	  },
	  handleAppend: function handleAppend(component) {
	    component._appended = true;
	    component.onAppend && component.onAppend();
	
	    // invoke onAppend on children recursively
	    var children = component.data.children;
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = this.componentMap[children[i].ref];
	        if (child) {
	          this.handleAppend(child);
	        }
	      }
	    }
	
	    // watch appear/disappear of the component if needed
	    (0, _appearWatcher.watchIfNeeded)(component);
	
	    // do lazyload if needed
	    component.fireLazyload();
	    // lazyload.startIfNeeded(component);
	  },
	  createFinish: function createFinish(callback) {
	    // TODO
	  },
	  updateFinish: function updateFinish(callback) {
	    // TODO
	  },
	  refreshFinish: function refreshFinish(callback) {
	    // TODO
	  }
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.watchIfNeeded = watchIfNeeded;
	
	var _utils = __webpack_require__(83);
	
	var componentsInScroller = [];
	var componentsOutOfScroller = [];
	var listened = false;
	var direction = 'up';
	var scrollY = 0;
	
	function watchIfNeeded(component) {
	  if (needWatch(component)) {
	    if (component.isInScrollable()) {
	      componentsInScroller.push(component);
	    } else {
	      componentsOutOfScroller.push(component);
	    }
	    if (!listened) {
	      listened = true;
	      // const handler = throttle(onScroll, 25)
	      var handler = throttle(onScroll, 100);
	      window.addEventListener('scroll', handler, false);
	    }
	  }
	}
	
	function needWatch(component) {
	  var events = component.data.event;
	  if (events && (events.indexOf('appear') !== -1 || events.indexOf('disappear') !== -1)) {
	    return true;
	  }
	  return false;
	}
	
	function onScroll(e) {
	  // If the scroll event is dispatched from a scrollable component
	  // implemented through scrollerjs, then the appear/disappear events
	  // should be treated specially by handleScrollerScroll.
	  if (e.originalType === 'scrolling') {
	    handleScrollerScroll(e);
	  } else {
	    handleWindowScroll();
	  }
	}
	
	function handleScrollerScroll(e) {
	  var cmps = componentsInScroller;
	  var len = cmps.length;
	  direction = e.direction;
	  for (var i = 0; i < len; i++) {
	    var component = cmps[i];
	    var appear = isComponentInScrollerAppear(component);
	    if (appear && !component._appear) {
	      component._appear = true;
	      fireEvent(component, 'appear');
	    } else if (!appear && component._appear) {
	      component._appear = false;
	      fireEvent(component, 'disappear');
	    }
	  }
	}
	
	function handleWindowScroll() {
	  var y = window.scrollY;
	  direction = y >= scrollY ? 'up' : 'down';
	  scrollY = y;
	
	  var len = componentsOutOfScroller.length;
	  if (len === 0) {
	    return;
	  }
	  for (var i = 0; i < len; i++) {
	    var component = componentsOutOfScroller[i];
	    var appear = isComponentInWindow(component);
	    if (appear && !component._appear) {
	      component._appear = true;
	      fireEvent(component, 'appear');
	    } else if (!appear && component._appear) {
	      component._appear = false;
	      fireEvent(component, 'disappear');
	    }
	  }
	}
	
	function isComponentInScrollerAppear(component) {
	  var parentScroller = component._parentScroller;
	  var cmpRect = component.node.getBoundingClientRect();
	  if (!isComponentInWindow(component)) {
	    return false;
	  }
	  while (parentScroller) {
	    var parentRect = parentScroller.node.getBoundingClientRect();
	    if (!(cmpRect.right > parentRect.left && cmpRect.left < parentRect.right && cmpRect.bottom > parentRect.top && cmpRect.top < parentRect.bottom)) {
	      return false;
	    }
	    parentScroller = parentScroller._parentScroller;
	  }
	  return true;
	}
	
	function isComponentInWindow(component) {
	  var rect = component.node.getBoundingClientRect();
	  return rect.right > 0 && rect.left < window.innerWidth && rect.bottom > 0 && rect.top < window.innerHeight;
	}
	
	function fireEvent(component, type) {
	  var evt = document.createEvent('HTMLEvents');
	  var data = { direction: direction };
	  evt.initEvent(type, false, false);
	  evt.data = data;
	  (0, _utils.extend)(evt, data);
	  component.node.dispatchEvent(evt);
	}
	
	function throttle(func, wait) {
	  var context = void 0,
	      args = void 0,
	      result = void 0;
	  var timeout = null;
	  var previous = 0;
	  var later = function later() {
	    previous = Date.now();
	    timeout = null;
	    result = func.apply(context, args);
	  };
	  return function () {
	    var now = Date.now();
	    var remaining = wait - (now - previous);
	    context = this;
	    args = arguments;
	    if (remaining <= 0) {
	      clearTimeout(timeout);
	      timeout = null;
	      previous = now;
	      result = func.apply(context, args);
	    } else if (!timeout) {
	      timeout = setTimeout(later, remaining);
	    }
	    return result;
	  };
	}

/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var config = {
	  weexVersion: '0.5.0',
	  debug: false,
	  validRoots: ['div', 'list', 'vlist', 'scroller']
	};
	
	exports.default = config;

/***/ },
/* 117 */
/***/ function(module, exports) {

	/* global XMLHttpRequest */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.load = load;
	exports.registerLoader = registerLoader;
	function loadByXHR(config, callback) {
	  if (!config.source) {
	    callback(new Error('xhr loader: missing config.source.'));
	  }
	  var xhr = new XMLHttpRequest();
	  xhr.open('GET', config.source);
	  xhr.onload = function () {
	    callback(null, this.responseText);
	  };
	  xhr.onerror = function (error) {
	    callback(error);
	  };
	  xhr.send();
	}
	
	function loadByJsonp(config, callback) {
	  if (!config.source) {
	    callback(new Error('jsonp loader: missing config.source.'));
	  }
	  var callbackName = config.jsonpCallback || 'weexJsonpCallback';
	  window[callbackName] = function (code) {
	    if (code) {
	      callback(null, code);
	    } else {
	      callback(new Error('load by jsonp error'));
	    }
	  };
	  var script = document.createElement('script');
	  script.src = decodeURIComponent(config.source);
	  script.type = 'text/javascript';
	  document.body.appendChild(script);
	}
	
	function loadBySourceCode(config, callback) {
	  // src is the jsbundle.
	  // no need to fetch from anywhere.
	  if (config.source) {
	    callback(null, config.source);
	  } else {
	    callback(new Error('source code laoder: missing config.source.'));
	  }
	}
	
	var callbackMap = {
	  xhr: loadByXHR,
	  jsonp: loadByJsonp,
	  source: loadBySourceCode
	};
	
	function load(options, callback) {
	  var loadFn = callbackMap[options.loader];
	  loadFn(options, callback);
	}
	
	function registerLoader(name, loaderFunc) {
	  if (typeof loaderFunc === 'function') {
	    callbackMap[name] = loaderFunc;
	  }
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Sender = exports.receiver = exports.protocol = undefined;
	
	var _protocol = __webpack_require__(119);
	
	var _protocol2 = _interopRequireDefault(_protocol);
	
	var _receiver = __webpack_require__(120);
	
	var _receiver2 = _interopRequireDefault(_receiver);
	
	var _sender = __webpack_require__(121);
	
	var _sender2 = _interopRequireDefault(_sender);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.protocol = _protocol2.default;
	exports.receiver = _receiver2.default;
	exports.Sender = _sender2.default;

/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	
	  // weex instances
	  _instances: {},
	
	  // api meta info
	  _meta: {},
	
	  // Weex.registerApiModule used this to register and access apiModules.
	  apiModule: {},
	
	  // get the api method meta info array for the module.
	  getApiModuleMeta: function getApiModuleMeta(moduleName) {
	    var metaObj = {};
	    metaObj[moduleName] = this._meta[moduleName];
	    return metaObj;
	  },
	
	  // Set meta info for a api module.
	  // If there is a same named api, just replace it.
	  // opts:
	  // - metaObj: meta object like
	  // {
	  //    dom: [{
	  //      name: 'addElement',
	  //      args: ['string', 'object']
	  //    }]
	  // }
	  setApiModuleMeta: function setApiModuleMeta(metaObj) {
	    var moduleName = void 0;
	    for (var k in metaObj) {
	      if (metaObj.hasOwnProperty(k)) {
	        moduleName = k;
	      }
	    }
	    var metaArray = this._meta[moduleName];
	    if (!metaArray) {
	      this._meta[moduleName] = metaObj[moduleName];
	    } else {
	      (function () {
	        var nameObj = {};
	        metaObj[moduleName].forEach(function (api) {
	          nameObj[api.name] = api;
	        });
	        metaArray.forEach(function (api, i) {
	          if (nameObj[api.name]) {
	            metaArray[i] = nameObj[api.name];
	            delete nameObj[api.name];
	          }
	        });
	        for (var _k in metaObj) {
	          if (metaObj.hasOwnProperty(_k)) {
	            metaArray.push(metaObj[_k]);
	          }
	        }
	      })();
	    }
	    this._meta[moduleName] = metaObj[moduleName];
	  },
	
	  // Set meta info for a single api.
	  // opts:
	  //  - moduleName: api module name.
	  //  - meta: a meta object like:
	  //  {
	  //    name: 'addElement',
	  //    args: ['string', 'object']
	  //  }
	  setApiMeta: function setApiMeta(moduleName, meta) {
	    var metaArray = this._meta[moduleName];
	    if (!metaArray) {
	      this._meta[moduleName] = [meta];
	    } else {
	      var metaIdx = -1;
	      metaArray.forEach(function (api, i) {
	        var name = void 0; // todo
	        if (meta.name === name) {
	          metaIdx = i;
	        }
	      });
	      if (metaIdx !== -1) {
	        metaArray[metaIdx] = meta;
	      } else {
	        metaArray.push(meta);
	      }
	    }
	  }
	};
	
	// _registerModules([{
	//   modal: [{
	//     name: 'toast',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'alert',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'confirm',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'prompt',
	//     args: ['object', 'function']
	//   }]
	// }, {
	//   animation: [{
	//     name: 'transition',
	//     args: ['string', 'object', 'function']
	//   }]
	// }])

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _protocol = __webpack_require__(119);
	
	var _protocol2 = _interopRequireDefault(_protocol);
	
	var _utils = __webpack_require__(83);
	
	var _sender = __webpack_require__(121);
	
	var _sender2 = _interopRequireDefault(_sender);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var callQueue = [];
	// Need a task counter?
	// When frameUpdater is not activated, tasks will not be push
	// into callQueue and there will be no trace for situation of
	// execution of tasks.
	
	// give 10ms for call handling, and rest 6ms for others
	var MAX_TIME_FOR_EACH_FRAME = 10;
	
	// callNative: jsFramework will call this method to talk to
	// this renderer.
	// params:
	//  - instanceId: string.
	//  - tasks: array of object.
	//  - callbackId: number.
	function callNative(instanceId, tasks, callbackId) {
	  var calls = [];
	  if (typeof tasks === 'string') {
	    try {
	      calls = JSON.parse(tasks);
	    } catch (e) {
	      console.error('invalid tasks:', tasks);
	    }
	  } else if ((0, _utils.isArray)(tasks)) {
	    calls = tasks;
	  }
	  var len = calls.length;
	  calls[len - 1].callbackId = !callbackId && callbackId !== 0 ? -1 : callbackId;
	  // To solve the problem of callapp, the two-way time loop rule must
	  // be replaced by calling directly except the situation of page loading.
	  // 2015-11-03
	  for (var i = 0; i < len; i++) {
	    if (_utils.frameUpdater.isActive()) {
	      callQueue.push({
	        instanceId: instanceId,
	        call: calls[i]
	      });
	    } else {
	      processCall(instanceId, calls[i]);
	    }
	  }
	}
	
	function processCallQueue() {
	  var len = callQueue.length;
	  if (len === 0) {
	    return;
	  }
	  var start = Date.now();
	  var elapsed = 0;
	
	  while (--len >= 0 && elapsed < MAX_TIME_FOR_EACH_FRAME) {
	    var callObj = callQueue.shift();
	    processCall(callObj.instanceId, callObj.call);
	    elapsed = Date.now() - start;
	  }
	}
	
	function processCall(instanceId, call) {
	  var moduleName = call.module;
	  var methodName = call.method;
	  var module = void 0,
	      method = void 0;
	  var args = call.args || call.arguments || [];
	
	  if (!(module = _protocol2.default.apiModule[moduleName])) {
	    return;
	  }
	  if (!(method = module[methodName])) {
	    return;
	  }
	
	  method.apply(global.weex.getInstance(instanceId), args);
	
	  var callbackId = call.callbackId;
	  if ((callbackId || callbackId === 0 || callbackId === '0') && callbackId !== '-1' && callbackId !== -1) {
	    performNextTick(instanceId, callbackId);
	  }
	}
	
	function performNextTick(instanceId, callbackId) {
	  _sender2.default.getSender(instanceId).performCallback(callbackId);
	}
	
	function nativeLog() {
	  if (_config2.default.debug) {
	    if (arguments[0].match(/^perf/)) {
	      console.info.apply(console, arguments);
	      return;
	    }
	    console.debug.apply(console, arguments);
	  }
	}
	
	function exportsBridgeMethodsToGlobal() {
	  global.callNative = callNative;
	  global.nativeLog = nativeLog;
	}
	
	exports.default = {
	  init: function init() {
	    // process callQueue every 16 milliseconds.
	    _utils.frameUpdater.addUpdateObserver(processCallQueue);
	    _utils.frameUpdater.start();
	
	    // exports methods to global(window).
	    exportsBridgeMethodsToGlobal();
	  }
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sender;
	
	var _utils = __webpack_require__(83);
	
	var _senderMap = {};
	
	function Sender(instance) {
	  if (!(this instanceof Sender)) {
	    return new Sender(instance);
	  }
	  this.instanceId = instance.instanceId;
	  this.weexInstance = instance;
	  _senderMap[this.instanceId] = this;
	}
	
	function _send(instanceId, msg) {
	  callJS(instanceId, [msg]);
	}
	
	Sender.getSender = function (instanceId) {
	  return _senderMap[instanceId];
	};
	
	Sender.prototype = {
	
	  // perform a callback to jsframework.
	  performCallback: function performCallback(callbackId, data, keepAlive) {
	    var args = [callbackId];
	    data && args.push(data);
	    keepAlive && args.push(keepAlive);
	    _send(this.instanceId, {
	      method: 'callback',
	      args: args
	    });
	  },
	
	  fireEvent: function fireEvent(ref, type, func, event) {
	    func.extra && (0, _utils.extend)(event, func.extra());
	    _send(this.instanceId, {
	      method: 'fireEvent',
	      args: [ref, type, event, func.updator && func.updator()]
	    });
	  }
	
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Component;
	
	var _utils = __webpack_require__(83);
	
	var _dom = __webpack_require__(123);
	
	var _operate = __webpack_require__(124);
	
	var operate = _interopRequireWildcard(_operate);
	
	var _position = __webpack_require__(126);
	
	var position = _interopRequireWildcard(_position);
	
	var _flexbox = __webpack_require__(128);
	
	var _flexbox2 = _interopRequireDefault(_flexbox);
	
	var _lazyload = __webpack_require__(129);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function hasIntersection(rect, ctRect) {
	  return rect.left < ctRect.right && rect.right > ctRect.left && rect.top < ctRect.bottom && rect.bottom > ctRect.top;
	}
	
	function Component(data, nodeType) {
	  this.data = data;
	  this.node = this.create(nodeType);
	  this.createChildren();
	  this.updateAttrs(this.data.attr || {});
	  // issue: when add element to a list in lifetime hook 'ready', the
	  // styles is set to the classStyle, not style. This is a issue
	  // that jsframework should do something about.
	  var classStyle = this.data.classStyle;
	  classStyle && this.updateStyle(this.data.classStyle);
	  this.updateStyle(this.data.style || {});
	  this.bindEvents(this.data.event || []);
	}
	
	Component.prototype = {
	  getComponentManager: function getComponentManager() {
	    return _dom.ComponentManager.getInstance(this.data.instanceId);
	  },
	  getWeexInstance: function getWeexInstance() {
	    return this.getComponentManager().getWeexInstance();
	  },
	  getParent: function getParent() {
	    return this.getComponentManager().componentMap[this.parentRef];
	  },
	  getParentScroller: function getParentScroller() {
	    if (this.isInScrollable()) {
	      return this._parentScroller;
	    }
	    return null;
	  },
	  getRootScroller: function getRootScroller() {
	    if (this.isInScrollable()) {
	      var scroller = this._parentScroller;
	      var parent = scroller._parentScroller;
	      while (parent) {
	        scroller = parent;
	        parent = scroller._parentScroller;
	      }
	      return scroller;
	    }
	    return null;
	  },
	  getRootContainer: function getRootContainer() {
	    var root = this.getWeexInstance().getRoot() || document.body;
	    return root;
	  },
	  isScrollable: function isScrollable() {
	    var t = this.data.type;
	    return _dom.ComponentManager.getScrollableTypes().indexOf(t) !== -1;
	  },
	  isInScrollable: function isInScrollable() {
	    if (typeof this._isInScrollable === 'boolean') {
	      return this._isInScrollable;
	    }
	    var parent = this.getParent();
	    if (parent && typeof parent._isInScrollable !== 'boolean' && !parent.isScrollable()) {
	      if (parent.data.ref === '_root') {
	        this._isInScrollable = false;
	        return false;
	      }
	      this._isInScrollable = parent.isInScrollable();
	      this._parentScroller = parent._parentScroller;
	      return this._isInScrollable;
	    }
	    if (parent && typeof parent._isInScrollable === 'boolean') {
	      this._isInScrollable = parent._isInScrollable;
	      this._parentScroller = parent._parentScroller;
	      return this._isInScrollable;
	    }
	    if (parent && parent.isScrollable()) {
	      this._isInScrollable = true;
	      this._parentScroller = parent;
	      return true;
	    }
	    if (!parent) {
	      console && console.warn('[h5-render] isInScrollable - parent not exist.');
	      return;
	    }
	  },
	
	
	  // dispatch a specified event on this.node
	  //  - type: event type
	  //  - data: event data
	  //  - config: event config object
	  //     - bubbles
	  //     - cancelable
	  dispatchEvent: function dispatchEvent(type, data, config) {
	    var event = document.createEvent('HTMLEvents');
	    config = config || {};
	    event.initEvent(type, config.bubbles || false, config.cancelable || false);
	    !data && (data = {});
	    event.data = (0, _utils.extend)({}, data);
	    (0, _utils.extend)(event, data);
	    this.node.dispatchEvent(event);
	  },
	
	
	  onAppend: function onAppend() {
	    var rect = this.node.getBoundingClientRect();
	    var parent = this.getParentScroller();
	    var parentNode = parent ? parent.node : this.getRootContainer();
	    var ctRect = parentNode.getBoundingClientRect();
	    if (hasIntersection(rect, ctRect)) {
	      this.dispatchEvent('appear', { direction: '' });
	    }
	  },
	
	  addAppendHandler: function addAppendHandler(cb) {
	    var pre = void 0;
	    if (this.onAppend) {
	      pre = this.onAppend.bind(this);
	    }
	    this.onAppend = function () {
	      pre && pre.call(this);
	      cb && cb.call(this);
	    }.bind(this);
	  },
	
	
	  // change src to img-src for lib.img to fire lazyload later.
	  enableLazyload: function enableLazyload(src) {
	    if (this.node) {
	      (0, _lazyload.makeImageLazy)(this.node, src);
	    } else {
	      console.error('[h5-render] this.node does not exist.');
	    }
	  },
	
	
	  // element can be both weex component and dom element.
	  fireLazyload: function fireLazyload(element) {
	    !element && (element = this);
	    (0, _lazyload.fireLazyload)(element);
	  },
	
	
	  attr: {}, // attr setters
	
	  style: {}, // style setters
	
	  // event funcs
	  //  - 1. 'updator' for updating attrs or styles with out triggering messages.
	  //  - 2. 'extra' for binding extra data.
	  //  - 3. 'setter' set a specified event handler.
	  // funcs should be functions like this: (take 'change' event as a example)
	  // {
	  //   change: {
	  //     updator () {
	  //       return {
	  //         attrs: {
	  //           checked: this.checked
	  //         }
	  //       }
	  //     },
	  //     extra () {
	  //       return {
	  //         value: this.checked
	  //       }
	  //     }
	  //   }
	  // }
	  event: {},
	
	  clearAttr: function clearAttr() {},
	  clearStyle: function clearStyle() {
	    this.node.cssText = '';
	  }
	};
	
	// extend operations.
	(0, _utils.extend)(Component.prototype, operate);
	
	// extend attr and style setters from 'position' and 'flexbox'.
	(0, _utils.extend)(Component.prototype, position);
	(0, _utils.extend)(Component.prototype.style, _flexbox2.default.style);

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ComponentManager = undefined;
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.ComponentManager = _componentManager2.default; /**
	                                                        * @fileOverview
	                                                        * A simple virtual dom implementation
	                                                        */

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.create = create;
	exports.createChildren = createChildren;
	exports.appendChild = appendChild;
	exports.insertBefore = insertBefore;
	exports.removeChild = removeChild;
	exports.updateAttrs = updateAttrs;
	exports.updateStyle = updateStyle;
	exports.bindEvents = bindEvents;
	exports.unbindEvents = unbindEvents;
	
	var _utils = __webpack_require__(83);
	
	var _valueFilter = __webpack_require__(125);
	
	function create(nodeType) {
	  var node = document.createElement(nodeType || 'div');
	  return node;
	}
	
	function createChildren() {
	  var children = this.data.children;
	  var parentRef = this.data.ref;
	  var componentManager = this.getComponentManager();
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment();
	    var isFlex = false;
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId;
	      children[i].scale = this.data.scale;
	      var child = componentManager.createElement(children[i]);
	      fragment.appendChild(child.node);
	      child.parentRef = parentRef;
	      if (!isFlex && child.data.style && child.data.style.hasOwnProperty('flex')) {
	        isFlex = true;
	      }
	    }
	    this.node.appendChild(fragment);
	  }
	}
	
	function appendChild(data) {
	  var children = this.data.children;
	  var componentManager = this.getComponentManager();
	  var child = componentManager.createElement(data);
	  this.node.appendChild(child.node);
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data];
	  } else {
	    children.push(data);
	  }
	  return child;
	}
	
	function insertBefore(child, before) {
	  var children = this.data.children;
	  var i = 0;
	  var l = void 0;
	  var isAppend = false;
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true;
	  } else {
	    for (l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break;
	      }
	    }
	    if (i === l) {
	      isAppend = true;
	    }
	  }
	
	  if (isAppend) {
	    this.node.appendChild(child.node);
	    children.push(child.data);
	  } else {
	    if (before.fixedPlaceholder) {
	      this.node.insertBefore(child.node, before.fixedPlaceholder);
	    } else if (before.stickyPlaceholder) {
	      this.node.insertBefore(child.node, before.stickyPlaceholder);
	    } else {
	      this.node.insertBefore(child.node, before.node);
	    }
	    children.splice(i, 0, child.data);
	  }
	}
	
	function removeChild(child) {
	  var children = this.data.children;
	  // remove from this.data.children
	  var i = 0;
	  var componentManager = this.getComponentManager();
	  if (children && children.length) {
	    var l = void 0;
	    for (l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break;
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1);
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeComponent(child.data.ref);
	  child.unsetPosition();
	  child.node.parentNode.removeChild(child.node);
	}
	
	function updateAttrs(attrs) {
	  // Noteattr must be injected into the dom element because
	  // it will be accessed from the outside developer by event.target.attr.
	  if (!this.node.attr) {
	    this.node.attr = {};
	  }
	  for (var key in attrs) {
	    var value = attrs[key];
	    var attrSetter = this.attr[key];
	    if (typeof attrSetter === 'function') {
	      attrSetter.call(this, value);
	    } else {
	      if (typeof value === 'boolean') {
	        this.node[key] = value;
	      } else {
	        this.node.setAttribute(key, value);
	      }
	      this.node.attr[key] = value;
	    }
	  }
	}
	
	function updateStyle(style) {
	  for (var key in style) {
	    var value = style[key];
	    var styleSetter = this.style[key];
	    if (typeof styleSetter === 'function') {
	      styleSetter.call(this, value);
	      continue;
	    }
	    var parser = (0, _valueFilter.getFilters)(key, { scale: this.data.scale })[typeof value === 'undefined' ? 'undefined' : _typeof(value)];
	    if (typeof parser === 'function') {
	      value = parser(value);
	    }
	    this.node.style[key] = value;
	  }
	}
	
	function bindEvents(evts) {
	  var self = this;
	  var weexInstance = this.getWeexInstance();
	  evts.map(function (evt) {
	    var func = self.event[evt] || {};
	    var setter = func.setter;
	    if (setter) {
	      self.node.addEventListener(evt, setter);
	      return;
	    }
	    var sender = weexInstance.sender;
	    var listener = function listener(e) {
	      // do stop bubbling.
	      // do not prevent default, otherwise the touchstart
	      // event will no longer trigger a click event
	      if (e._alreadyTriggered) {
	        return;
	      }
	      e._alreadyTriggered = true;
	      var event = (0, _utils.extend)({}, e);
	      event.target = self.data;
	      sender.fireEvent(self.data.ref, evt, {
	        extra: func.extra && func.extra.bind(self),
	        updator: func.updator && func.updator.bind(self)
	      }, event);
	    };
	    self.node.addEventListener(evt, listener, false, false);
	    var listeners = self._listeners;
	    if (!listeners) {
	      listeners = self._listeners = {};
	      self.node._listeners = {};
	    }
	    listeners[evt] = listener;
	    self.node._listeners[evt] = listener;
	  });
	}
	
	function unbindEvents(evts) {
	  var self = this;
	  evts.map(function (evt) {
	    var listener = this._listeners;
	    if (listener) {
	      self.node.removeEventListener(evt, listener);
	      self._listeners[evt] = null;
	      self.node._listeners[evt] = null;
	    }
	  });
	}

/***/ },
/* 125 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.filterStyles = filterStyles;
	exports.getFilters = getFilters;
	var NOT_PX_NUMBER_PROPERTIES = ['flex', 'opacity', 'zIndex', 'fontWeight'];
	
	function filterStyles(styles, config) {
	  for (var key in styles) {
	    var value = styles[key];
	    var parser = this.getFilters(key, config)[typeof value === 'undefined' ? 'undefined' : _typeof(value)];
	    if (typeof parser === 'function') {
	      styles[key] = parser(value);
	    }
	  }
	}
	
	function getFilters(key, config) {
	  if (NOT_PX_NUMBER_PROPERTIES.indexOf(key) !== -1) {
	    return {};
	  }
	  return {
	    number: function number(val) {
	      return val * config.scale + 'px';
	    },
	    string: function string(val) {
	      // string of a pure number or a number suffixed with a 'px' unit
	      if (val.match(/^\-?\d*\.?\d+(?:px)?$/)) {
	        return parseFloat(val) * config.scale + 'px';
	      }
	      if (key.match(/transform/) && val.match(/translate/)) {
	        return val.replace(/\d*\.?\d+px/g, function (match) {
	          return parseInt(parseFloat(match) * config.scale) + 'px';
	        });
	      }
	      return val;
	    }
	  };
	}

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.style = undefined;
	exports.setFixed = setFixed;
	exports.unsetFixed = unsetFixed;
	exports.setSticky = setSticky;
	exports.unsetSticky = unsetSticky;
	exports.unsetPosition = unsetPosition;
	
	var _sticky = __webpack_require__(127);
	
	var _sticky2 = _interopRequireDefault(_sticky);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Set positon to fixed, with a placeholder if it's in a
	// scrollable component.
	function setFixed() {
	  // delay processing in case the node is not appended yet.
	  setTimeout(function () {
	    this.node.style.position = 'fixed';
	    if (!this.isInScrollable()) {
	      return;
	    }
	    var parent = this.node.parentNode;
	    if (parent) {
	      // For the elements who are fixed: this fixedPlaceholder
	      // shoud be inserted, and the fixed element itself should
	      // be moved to the root container.
	      this.fixedPlaceholder = document.createElement('div');
	      this.fixedPlaceholder.classList.add('weex-fixed-placeholder');
	      this.fixedPlaceholder.style.cssText = ['display:none;', 'width:0px;', 'height:0px;'].join('');
	      parent.insertBefore(this.fixedPlaceholder, this.node);
	      this.getRootContainer().appendChild(this.node);
	    }
	  }.bind(this), 0);
	}
	
	// unset a fixed node to the pecified 'position' or 'relative' by default.
	function unsetFixed(position) {
	  // For the elements who are fixed elements before, now
	  // are not fixed: the fixedPlaceholder has to be replaced
	  // by this element.
	  position = position ? position + '' : 'relative';
	  if (this.fixedPlaceholder) {
	    var parent = this.fixedPlaceholder.parentNode;
	    parent.insertBefore(this.node, this.fixedPlaceholder);
	    parent.removeChild(this.fixedPlaceholder);
	    this.fixedPlaceholder = null;
	    this.node.style.position = position;
	  }
	}
	
	function setSticky() {
	  this.node.style.zIndex = 100;
	  setTimeout(function () {
	    this.sticky = new _sticky2.default(this);
	  }.bind(this), 0);
	}
	
	function unsetSticky() {
	  if (this.sticky) {
	    this.sticky.destroy();
	    this.sticky = null;
	  }
	}
	
	// usally used to unset sticky and fixed
	function unsetPosition(position) {
	  this.style.position.call(this, position);
	}
	
	var style = exports.style = {
	  position: function position(value) {
	    // This is a peace of hacking to fix the problem about
	    // mixing fixed and transform. See 'http://stackoverflo
	    // w.com/questions/15194313/webkit-css-transform3d-posi
	    // tion-fixed-issue' for more info.
	    value !== 'fixed' && this.unsetFixed();
	    value !== 'sticky' && this.unsetSticky();
	    if (value === 'fixed') {
	      return this.setFixed();
	    }
	    if (value === 'sticky') {
	      return this.setSticky();
	    }
	    this.node.style.position = value;
	  }
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sticky;
	
	var _utils = __webpack_require__(83);
	
	var ua = navigator.userAgent;
	var isFirefox = !!ua.match(/Firefox/i);
	var isIEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = isFirefox ? '-moz-' : isIEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = isFirefox ? 'Moz' : isIEMobile ? 'ms' : 'webkit';
	
	var supportSticky = (0, _utils.detectSticky)();
	
	function createStickyLayer(sticky) {
	  var parent = sticky.parentElement;
	  var sl = parent._stickyLayer;
	  if (sl) {
	    return;
	  }
	  sl = document.createElement('div');
	  sl.classList.add('weex-sticky-layer');
	  sl.style.cssText = ['position:fixed;', 'top:' + parent.getBoundingClientRect().top + 'px;', 'box-sizing:border-box;', 'width:100%;'].join('');
	  parent._stickyLayer = sl;
	  parent.appendChild(sl);
	}
	
	function destroyStickyLayer(sticky) {
	  var parent = sticky.parentElement;
	  var sl = parent._stickyLayer;
	  if (!sl || sl.children.length > 0) {
	    return;
	  }
	  sl && parent.removeChild(sl);
	  parent._stickyLayer = null;
	}
	
	function bindParent(sticky) {
	  if (!sticky instanceof Sticky) {
	    return;
	  }
	  var scroller = sticky.component.getParentScroller();
	  var pt = void 0;
	  if (scroller) {
	    pt = sticky.parent = scroller;
	    sticky.parentElement = pt.node;
	  } else {
	    pt = sticky.parent = sticky.component.getRootContainer();
	    sticky.parentElement = pt;
	  }
	}
	
	function setSticky(sticky) {
	  var comp = sticky.component;
	  comp.stickyPlaceholder = sticky.element.cloneNode(true);
	  comp.stickyPlaceholder.classList.add('weex-sticky-placeholder');
	  sticky.element.classList.add('weex-sticky');
	  sticky.preMarginTop = sticky.element.style.marginTop;
	  sticky.element.style.marginTop = sticky.top + 'px';
	  sticky.element.parentNode.insertBefore(comp.stickyPlaceholder, sticky.element);
	  var pt = sticky.parentElement;
	  !pt.stickys && (pt.stickys = []);
	  pt.stickys.push(sticky);
	  createStickyLayer(sticky);
	  pt._stickyLayer.appendChild(sticky.element);
	}
	
	/**
	 * unsetSticky
	 * @param  {Sticky} sticky : a sticky instance.
	 * @param  {string} position : position replacing with (default: 'relative').
	 */
	function unsetSticky(sticky, position) {
	  var comp = sticky.component;
	  var element = sticky.element;
	  position = position ? position + '' : sticky.prePosition;
	  element.style.position = position;
	  element.style.marginTop = sticky.preMarginTop || '';
	  element.classList.remove('weex-sticky');
	  if (comp.stickyPlaceholder) {
	    var parent = comp.stickyPlaceholder.parentNode;
	    parent.insertBefore(sticky.element, comp.stickyPlaceholder);
	    parent.removeChild(comp.stickyPlaceholder);
	    comp.stickyPlaceholder = null;
	  }
	  var stks = sticky.parentElement.stickys;
	  var idx = stks.indexOf(sticky);
	  stks.splice(idx, 1);
	  destroyStickyLayer(sticky);
	}
	
	/**
	 * @class  Sticky
	 * @param {Component} component: a weex component.
	 * @param {object} options config options.
	 *  - options.component (optional) incase the component param is missing, it can
	 *    be specified in this options.
	 *  - options.withinParent=falseoptionalonly for Androidthe sticky effect is
	 *    limited within the parent element only.
	 */
	function Sticky(component, options) {
	  options = options || {};
	  this.component = component;
	  this.element = component.node;
	  this.prePosition = this.element.style.position;
	  this.withinParent = options.withinParent || false;
	  this.parent = null;
	  this.init();
	}
	
	Sticky.prototype = {
	
	  constructor: Sticky,
	
	  init: function init() {
	    var elementStyle = this.element.style;
	    elementStyle[stylePrefix + 'Transform'] = 'translateZ(0)'; // fix flickering
	    elementStyle['transform'] = 'translateZ(0)';
	    bindParent(this);
	    if (supportSticky) {
	      elementStyle.position = cssPrefix + 'sticky';
	      elementStyle.position = 'sticky';
	    } else {
	      this._simulateSticky();
	      this._bindResize();
	    }
	  },
	  _bindResize: function _bindResize() {
	    var self = this;
	    var isAndroid = /android/gi.test(navigator.appVersion);
	    var resizeEvent = self._resizeEvent = 'onorientationchange' in window ? 'orientationchange' : 'resize';
	    var resizeHandler = self._resizeHandler = function () {
	      setTimeout(function () {
	        self.refresh();
	      }, isAndroid ? 200 : 0);
	    };
	    window.addEventListener(resizeEvent, resizeHandler, false);
	  },
	
	
	  /**
	   * Refresh a instance.
	   * If withParent is true and the parent' height altered, this
	   * method should be called.
	   */
	  refresh: function refresh() {
	    if (supportSticky) {
	      return;
	    }
	    this._detach();
	    this._simulateSticky();
	  },
	  _simulateSticky: function _simulateSticky() {
	    var self = this;
	    var isInScrollable = this.isInScrollable();
	    // the initial y offset.
	    this.offset = (isInScrollable ? this.getParentScroller().offset : window.pageYOffset) || 0;
	    var rectTop = this.element.getBoundingClientRect().top;
	    var wrapperTop = 0;
	    if (isInScrollable) {
	      wrapperTop = this.parentElement.getBoundingClientRect().top;
	    }
	    var withinParent = this.withinParent;
	    var thresholdBase = rectTop - wrapperTop + this.offset;
	    /**
	     * curState:
	     *   1 - normal
	     *   2 - sticky
	     *   3 - exceed parent
	     * @type {Number}
	     */
	    this.curState = 1;
	    var scrollHandler = this._scrollHandler = (0, _utils.throttle)(function (e) {
	      var sl = self.parentElement._stickyLayer;
	      var layerHeight = sl ? sl.getBoundingClientRect().height : 0;
	      var selfHeight = self.element.getBoundingClientRect().height;
	      var selfOffset = self.curState === 2 ? selfHeight : 0;
	      var thresholdTop = thresholdBase - layerHeight + selfOffset;
	      var ypos = self.isInScrollable() ? e.offset : window.pageYOffset;
	      self.offset = ypos;
	      if (ypos < thresholdTop) {
	        if (self.curState !== 1) {
	          unsetSticky(self);
	          self.curState = 1;
	        }
	      } else if (!withinParent && ypos >= thresholdTop || withinParent && ypos >= thresholdTop /* && ypos < thresholdBottom*/) {
	          if (self.curState !== 2) {
	            setSticky(self);
	            self.curState = 2;
	          }
	        }
	    }, 100);
	    window.addEventListener('scroll', scrollHandler, false);
	
	    // take effect once inited after a destroyment.
	    if (this.offset >= thresholdBase) {
	      var dummyEvent = document.createEvent('HTMLEvents');
	      dummyEvent.initEvent('scroll', true, true);
	      window.dispatchEvent(dummyEvent);
	    }
	  },
	  _detach: function _detach(position) {
	    position = position ? position + '' : 'relative';
	    if (!supportSticky) {
	      if (this.curState === 2) {
	        unsetSticky(this);
	      }
	      window.removeEventListener('scroll', this._scrollHandler, false);
	    }
	  },
	  isInScrollable: function isInScrollable() {
	    if (!this._isInScrollable) {
	      try {
	        this._isInScrollable = this.component.isInScrollable();
	      } catch (err) {
	        // The parentRef is not in componentManager's componentMap yet, so
	        // it's invalid to get the parent and test if it's scrollable.
	        // This is most likely to happen in the case that the parent
	        // component's 'append' attribute is set to 'tree'.
	        console.error('isInScrollable is not yet available to call', err);
	      }
	    }
	    return this._isInScrollable;
	  },
	  getParentScroller: function getParentScroller() {
	    return this.component.getParentScroller();
	  },
	  destroy: function destroy(position) {
	    this._detach(position);
	    var elementStyle = this.element.style;
	    elementStyle.removeProperty(cssPrefix + 'transform');
	    elementStyle.removeProperty('transform');
	    if (!supportSticky) {
	      window.removeEventListener(this._resizeEvent, this._resizeHandler, false);
	    }
	  }
	};

/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var boxAlignMap = {
	  stretch: 'stretch',
	  'flex-start': 'start',
	  'flex-end': 'end',
	  center: 'center'
	};
	
	var boxOrientMap = {
	  row: 'horizontal',
	  column: 'vertical'
	};
	
	var boxPackMap = {
	  'flex-start': 'start',
	  'flex-end': 'end',
	  center: 'center',
	  'space-between': 'justify',
	  'space-around': 'justify' // Just same as `space-between`
	};
	
	exports.default = {
	  style: {
	    flex: function flex(value) {
	      this.node.style.webkitBoxFlex = value;
	      this.node.style.webkitFlex = value;
	      this.node.style.flex = value;
	    },
	    alignItems: function alignItems(value) {
	      this.node.style.webkitBoxAlign = boxAlignMap[value];
	      this.node.style.webkitAlignItems = value;
	      this.node.style.alignItems = value;
	    },
	    alignSelf: function alignSelf(value) {
	      this.node.style.webkitAlignSelf = value;
	      this.node.style.alignSelf = value;
	    },
	    flexDirection: function flexDirection(value) {
	      this.node.style.webkitBoxOrient = boxOrientMap[value];
	      this.node.style.webkitFlexDirection = value;
	      this.node.style.flexDirection = value;
	    },
	    justifyContent: function justifyContent(value) {
	      this.node.style.webkitBoxPack = boxPackMap[value];
	      this.node.style.webkitJustifyContent = value;
	      this.node.style.justifyContent = value;
	    }
	  }
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib, HTMLElement */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.makeImageLazy = makeImageLazy;
	exports.fireLazyload = fireLazyload;
	__webpack_require__(130);
	
	var lazyloadTimer = void 0;
	
	// fire lazyimg on images.
	function fire() {
	  lib.img.fire();
	}
	
	// we don't know when all images are appended
	// just use setTimeout to do delay lazyload
	//
	// -- actually everytime we add a element or update styles,
	// the component manager will call startIfNeed to fire
	// lazyload once again in the handleAppend function. so there
	// is no way that any image element can miss it. See source
	// code in componentMangager.js.
	
	// component is not a dom element but a weex component.
	function startIfNeeded(component) {
	  if (component.data.type === 'image') {
	    if (!lazyloadTimer) {
	      lazyloadTimer = setTimeout(function () {
	        fire();
	        clearTimeout(lazyloadTimer);
	        lazyloadTimer = null;
	      }, 16);
	    }
	  }
	}
	
	// elementScope is a dom element.
	function loadIfNeeded(elementScope) {
	  var notPreProcessed = elementScope.querySelectorAll('[img-src]');
	  // image elements which have attribute 'i-lazy-src' were elements
	  // that had been preprocessed by lib-img-core, but not loaded yet, and
	  // must be loaded when 'appear' events were fired. It turns out the
	  // 'appear' event was not fired correctly in the css-translate-transition
	  // situation, so 'i-lazy-src' must be checked and lazyload must be
	  // fired manually.
	  var preProcessed = elementScope.querySelectorAll('[i-lazy-src]');
	  if (notPreProcessed.length > 0 || preProcessed.length > 0) {
	    fire();
	  }
	}
	
	function makeImageLazy(image, src) {
	  image.removeAttribute('img-src');
	  image.removeAttribute('i-lazy-src');
	  image.removeAttribute('src');
	  image.setAttribute('img-src', src);
	  fire();
	}
	
	function fireLazyload(component) {
	  if (component instanceof HTMLElement) {
	    loadIfNeeded(component);
	  } else {
	    startIfNeeded(component);
	  }
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/*
	    lib-img-adpter 
	    Author: kongshi.wl@alibaba-inc.com 
	    Date:   Dec,2015
	*/
	;
	
	(function (win, lib) {
	    __webpack_require__(131);
	
	    var adapter = {};
	    var appearInstance;
	    var runtimeFlags = {};
	
	    var config = {
	        'dataSrc': 'img-src', //attribute, lazy-class
	        'lazyHeight': 0, //
	        'lazyWidth': 0 //
	    };
	
	
	    function extendStrict(main, sub) {
	        var ret = {};
	        for (var k in main) {
	            if (main.hasOwnProperty(k)) {
	                ret[k] = sub.hasOwnProperty(k) ? sub[k] : main[k];
	            }
	        }
	        return ret;
	    }
	
	    function applySrc(item, processedSrc) {
	        if (!processedSrc) {
	            return;
	        }
	        if (item.nodeName.toUpperCase() == 'IMG') {
	            item.setAttribute('src', processedSrc);
	        } else {
	            item.style.backgroundImage = 'url("' + processedSrc + '")';
	        }
	    }
	
	    function init() {
	        appearInstance = lib.appear.init({
	            cls: 'imgtmp', //
	            once: true, //
	            x: config.lazyWidth, //x0
	            y: config.lazyHeight, //y0
	            onAppear: function (evt) {
	                var item = this;
	                applySrc(item, item.getAttribute('i-lazy-src'));
	                item.removeAttribute('i-lazy-src');
	            }
	        });
	    }
	
	
	    adapter.logConfig = function () {
	        console.log('lib-img Config\n', config);
	    }
	
	
	    adapter.fire = function () {
	
	        if (!appearInstance) {
	            init();
	        }
	
	        var label = 'i_' + Date.now() % 100000;
	        var domList = document.querySelectorAll('[' + config.dataSrc + ']');
	
	        [].forEach.call(domList, function (item) {
	            if (item.dataset.lazy == 'false' && item.dataset.lazy != 'true') {
	                applySrc(item, processSrc(item, item.getAttribute(config.dataSrc)));
	            } else {
	                item.classList.add(label);
	                item.setAttribute('i-lazy-src', item.getAttribute(config.dataSrc));
	            }
	            item.removeAttribute(config.dataSrc);
	        });
	
	        appearInstance.bind('.' + label);
	        appearInstance.fire();
	    }
	
	
	
	    adapter.defaultSrc = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
	
	
	
	    lib.img = adapter;
	    
	    module.exports = adapter;
	
	})(window, window['lib'] || (window['lib'] = {}));


/***/ },
/* 131 */
/***/ function(module, exports) {

	;
	(function (win, lib) {
	  var doc = document;
	  var appearEvt;
	  var disappearEvt;
	
	  function createEvent() {
	    appearEvt = doc.createEvent("HTMLEvents");//  
	    disappearEvt = doc.createEvent("HTMLEvents");//  
	    appearEvt.initEvent('_appear', false, true);      
	    disappearEvt.initEvent('_disappear', false, true);      
	  }
	
	  /**
	   * [throttle ]
	   * @param  {[function]} func []
	   * @param  {[int]} wait []
	   * @return {[type]}      [description]
	   */
	  function throttle(func, wait) {
	    var latest = Date.now(),
	      previous = 0,//
	      timeout = null,//setTimout
	      context,//
	      args,//
	      result;//
	    var later = function () {
	      previous = Date.now();
	      timeout = null;//
	      func.apply(context, args);
	    }
	    return function () {
	      var now = Date.now();
	      context = this;
	      args = arguments;
	
	      var remaining = wait - (now - previous);
	      if (remaining <= 0 || remaining >= wait) {
	        //
	        clearTimeout(timeout);
	        timeout = null;
	        result = func.apply(context, args);
	      } else if (timeout == null) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    }
	  }
	
	  /**
	   * [getOffset ]
	   * @param  {[type]} el   [description]
	   * @param  {[type]} param [description]
	   * @return {[type]}       [description]
	   */
	  function getOffset(el, param) {
	    var el, l,  r, b, t;
	    if (!el) {
	      return;
	    }
	    if (!param) {
	      param = {x: 0, y: 0};
	    }
	
	    if (el != window) {
	      el = el.getBoundingClientRect();
	      l = el.left;
	      t = el.top;
	      r = el.right;
	      b = el.bottom;
	    } else {
	      l = 0;
	      t = 0;
	      r = l + el.innerWidth;
	      b = t + el.innerHeight;
	    }
	    return {
	      'left': l,
	      'top': t,
	      'right': r + param.x,
	      'bottom': b + param.y
	    };
	  }
	  //
	  function compareOffset(d1, d2) {
	    var left = d2.right > d1.left && d2.left < d1.right;
	    var top = d2.bottom > d1.top && d2.top < d1.bottom;
	    return left && top;
	  }
	  //
	  function getDirection(beforeOffset, nowOffset) {
	    var direction = 'none';
	    var horizental = beforeOffset.left - nowOffset.left;
	    var vertical = beforeOffset.top - nowOffset.top;
	    if (vertical == 0) {
	      if (horizental != 0) {
	        direction = horizental > 0 ? 'left' : 'right';
	      } else {
	        direction = 'none'
	      }
	    }
	    if (horizental == 0) {
	      if (vertical != 0) {
	        direction = vertical > 0 ? 'up' : 'down';
	      } else {
	        direction = 'none';
	      }
	    }
	    return direction;
	  }
	
	  function extend(target, el) {
	    for (var k in el) {
	      if (el.hasOwnProperty(k)) {
	        target[k] = el[k];
	      }
	    }
	    return target;
	  }
	
	  /**
	   * [__bindEvent touchmovetransformresize]
	   * @return {[type]}      [description]
	   */
	  function __bindEvent() {
	    var self = this;
	    var handle = throttle(function () {
	      __fire.apply(self, arguments);
	    }, this.options.wait);
	    if (this.__handle) {
	      //
	      this.container.removeEventListener('scroll', this.__handle);
	      this.__handle = null;
	    }
	    this.__handle = handle;
	    this.container.addEventListener('scroll', handle, false);
	    this.container.addEventListener('resize', function(ev) {
	      __fire.apply(self, arguments);
	    }, false);
	    this.container.addEventListener('animationEnd', function() {
	      __fire.apply(self, arguments);
	    }, false);
	    // android4.0
	    this.container.addEventListener('webkitAnimationEnd', function() {
	      __fire.apply(self, arguments);
	    }, false);
	    this.container.addEventListener('transitionend', function() {
	      __fire.apply(self, arguments);
	    }, false);
	  }
	
	  //
	  function __getElements(selector) {
	    var self = this;
	    //
	    var container = this.options.container;
	    if (typeof container == 'string') {
	      //
	      this.container = doc.querySelector(container);
	    } else {
	      //
	      this.container = container;
	    }
	    //
	    if (this.container == window) {
	      var appearWatchElements = doc.querySelectorAll(selector);            
	    } else {
	      var appearWatchElements = this.container.querySelectorAll(selector);
	    }
	    var appearWatchElements = [].slice.call(appearWatchElements, null);
	
	    appearWatchElements = appearWatchElements.filter(function(ele) {
	      // appear
	      if (ele.dataset['bind'] == '1') {
	        delete ele._hasAppear;
	        delete ele._hasDisAppear;
	        delete ele._appear;      
	        ele.classList.remove(self.options.cls);
	        return false;
	      } else {
	        return true;
	      }
	    });
	
	    return appearWatchElements;
	  }
	
	  function __initBoundingRect(elements) {
	    var self = this;
	    if (elements && elements.length > 0) {
	      [].forEach.call(elements, function (ele) {
	        ele._eleOffset = getOffset(ele); 
	        //
	        ele.classList.remove(self.options.cls);
	        // 
	        ele.dataset['bind'] = 1;
	      });
	    }        
	  }
	
	  // 
	  function __fire() {
	    var container = this.container,
	      elements = this.appearWatchElements,
	      appearCallback = this.options.onAppear,//appear
	      disappearCallback = this.options.onDisappear,//disappear
	      containerOffset = getOffset(container, {
	        x: this.options.x,
	        y: this.options.y
	      }),
	      isOnce = this.options.once,//
	      ev = arguments[0] || {};
	    if (elements && elements.length > 0) {
	      [].forEach.call(elements, function (ele, i) {
	        //
	        var eleOffset = getOffset(ele);
	        var direction = getDirection(ele._eleOffset, eleOffset);
	        //
	        ele._eleOffset = eleOffset;
	        //
	        var isInView = compareOffset(containerOffset, eleOffset);
	        var appear = ele._appear;
	        var _hasAppear = ele._hasAppear;
	        var _hasDisAppear = ele._hasDisAppear;
	        appearEvt.data = {
	          direction: direction
	        }
	        disappearEvt.data = {
	          direction: direction
	        }
	        if (isInView && !appear) {
	          if ((isOnce && !_hasAppear) || !isOnce) {
	            //
	            //disppearappear
	            appearCallback && appearCallback.call(ele, ev);
	            //
	            ele.dispatchEvent(appearEvt);
	            ele._hasAppear = true;
	            ele._appear = true;
	          }
	        } else if (!isInView && appear) {
	          if ((isOnce && !_hasDisAppear) || !isOnce) {
	            //appeardisappeardisappear
	            disappearCallback && disappearCallback.call(ele, ev);
	            //
	            ele.dispatchEvent(disappearEvt);
	            ele._hasDisAppear = true;
	            ele._appear = false;
	          }
	        }
	      });
	    }
	  }
	
	  // proto = extend(proto, listener);
	
	  function __init(opts) {
	    //
	    extend(this.options, opts || (opts = {}));
	    //
	    this.appearWatchElements = this.appearWatchElements || __getElements.call(this, '.' + this.options.cls);
	    //
	    __initBoundingRect.call(this, this.appearWatchElements);
	    //
	    __bindEvent.call(this);
	  }
	  
	  var Appear = function () {
	    __init.apply(this, arguments);
	  }
	
	
	  var appear = {
	    instances: [],
	    init: function (opts) {
	      var proto = {
	        //
	        options: {
	          container: window,
	          wait: 100,
	          x: 0,
	          y: 0,
	          cls: 'lib-appear',
	          once: false,
	          onReset: function () {},
	          onAppear: function () {},
	          onDisappear: function () {}
	        },
	        container: null,
	        appearWatchElements: null,
	        bind: function (node) {
	          var cls = this.options.cls;
	          // appear
	          if (typeof node == 'string') {
	            var elements = __getElements.call(this, node);
	            [].forEach.call(elements, function (ele, i) {
	              if (!ele.classList.contains(cls)) {
	                ele.classList.add(cls);
	              }
	            });
	            
	          } else if (node.nodeType == 1 && this.container.contains(node)) {
	            //
	            if (!node.classList.contains(cls)) {
	              //
	              node.classList.add(cls);
	            }
	          } else {
	            return this;
	          }
	          //
	          var newElements = __getElements.call(this, '.' + this.options.cls);
	          //
	          this.appearWatchElements = this.appearWatchElements.concat(newElements);
	          //
	          __initBoundingRect.call(this, newElements);
	          return this;
	        },
	        // 
	        reset: function (opts) {
	          __init.call(this, opts);
	          this.appearWatchElements.forEach(function(ele) {
	            delete ele._hasAppear;
	            delete ele._hasDisAppear;
	            delete ele._appear;
	          });
	          return this;
	        },
	        fire: function () {
	          if (!this.appearWatchElements) {
	            this.appearWatchElements = [];
	          }
	          var newElements = __getElements.call(this, '.' + this.options.cls);
	          this.appearWatchElements = this.appearWatchElements.concat(newElements);
	          //
	          __initBoundingRect.call(this, newElements);
	          __fire.call(this);
	          return this;
	        }
	      }
	      Appear.prototype = proto;
	      var instance = new Appear(opts);
	      this.instances.push(instance);
	      return instance;
	    },
	    fireAll: function () {
	      var instances = this.instances;
	      instances.forEach(function (instance) {
	        instance.fire();
	      });
	    }
	  }
	  //
	  createEvent();
	
	  lib.appear = appear;
	
	})(window, window.lib || (window.lib = {}));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Atomic;
	
	var _component = __webpack_require__(122);
	
	var _component2 = _interopRequireDefault(_component);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Component which can have no subcomponents.
	// This component should not be instantiated directly, since
	// it is designed to be used as a base class to extend from.
	function Atomic(data) {
	  _component2.default.call(this, data);
	}
	
	Atomic.prototype = Object.create(_component2.default.prototype);
	
	Atomic.prototype.createChildren = function (data) {
	  // do nonthing
	  return;
	};
	
	Atomic.prototype.appendChild = function (data) {
	  // do nothing
	  return;
	};
	
	Atomic.prototype.insertBefore = function (child, before) {
	  // do nothing
	  return;
	};
	
	Atomic.prototype.removeChild = function (child) {
	  // do nothing
	  return;
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bind = bind;
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _loader = __webpack_require__(117);
	
	var _bridge = __webpack_require__(118);
	
	var _utils = __webpack_require__(83);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var methods = {
	  // Register a new component with the specified name.
	
	  registerComponent: function registerComponent(name, comp) {
	    _componentManager2.default.registerComponent(name, comp);
	  },
	
	
	  // Register a new api module.
	  // If the module already exists, just add methods from the
	  // new module to the old one.
	  registerApiModule: function registerApiModule(name, module, meta) {
	    if (!_bridge.protocol.apiModule[name]) {
	      _bridge.protocol.apiModule[name] = module;
	    } else {
	      for (var key in module) {
	        if (module.hasOwnProperty(key)) {
	          _bridge.protocol.apiModule[name][key] = module[key];
	        }
	      }
	    }
	    // register API module's meta info to jsframework
	    if (meta) {
	      _bridge.protocol.setApiModuleMeta(meta);
	      global.registerModules(_bridge.protocol.getApiModuleMeta(name), true);
	    }
	  },
	
	
	  // Register a new api method for the specified module.
	  // opts:
	  //  - args: type of arguments the API method takes such
	  //    as ['string', 'function']
	  registerApi: function registerApi(moduleName, name, method, args) {
	    if (typeof method !== 'function') {
	      return;
	    }
	    if (!_bridge.protocol.apiModule[moduleName]) {
	      _bridge.protocol.apiModule[moduleName] = {};
	      _bridge.protocol._meta[moduleName] = [];
	    }
	    _bridge.protocol.apiModule[moduleName][name] = method;
	    if (!args) {
	      return;
	    }
	    // register API meta info to jsframework
	    _bridge.protocol.setApiMeta(moduleName, {
	      name: name,
	      args: args
	    });
	    global.registerModules(_bridge.protocol.getApiModuleMeta(moduleName), true);
	  },
	
	
	  // Register a new weex-bundle-loader.
	  registerLoader: function registerLoader(name, loaderFunc) {
	    (0, _loader.registerLoader)(name, loaderFunc);
	  }
	};
	
	// To install components and plugins.
	function install(mod) {
	  mod.init(this);
	}
	
	function bind(Weex) {
	  Weex.install = install.bind(Weex);
	  (0, _utils.extend)(Weex, methods);
	}

/***/ },
/* 134 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){Object.defineProperty(this,"val",{value:a.toString(),enumerable:!0}),this.gt=function(a){return c.compare(this,a)>0},this.gte=function(a){return c.compare(this,a)>=0},this.lt=function(a){return c.compare(this,a)<0},this.lte=function(a){return c.compare(this,a)<=0},this.eq=function(a){return 0===c.compare(this,a)}}b.env=b.env||{},c.prototype.toString=function(){return this.val},c.prototype.valueOf=function(){for(var a=this.val.split("."),b=[],c=0;c<a.length;c++){var d=parseInt(a[c],10);isNaN(d)&&(d=0);var e=d.toString();e.length<5&&(e=Array(6-e.length).join("0")+e),b.push(e),1===b.length&&b.push(".")}return parseFloat(b.join(""))},c.compare=function(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0},b.version=function(a){return new c(a)}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.location.search.replace(/^\?/,"");if(b.env.params={},c)for(var d=c.split("&"),e=0;e<d.length;e++){d[e]=d[e].split("=");try{b.env.params[d[e][0]]=decodeURIComponent(d[e][1])}catch(f){b.env.params[d[e][0]]=d[e][1]}}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;if(c=d.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))b.env.os={name:"Windows Phone",isWindowsPhone:!0,version:c[1]};else if(d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/)))b.env.os={version:c[1]},d.match(/Mobile\s+Safari/)?(b.env.os.name="Android",b.env.os.isAndroid=!0):(b.env.os.name="AndroidPad",b.env.os.isAndroidPad=!0);else if(c=d.match(/(iPhone|iPad|iPod)/)){var e=c[1];c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.os={name:e,isIPhone:"iPhone"===e||"iPod"===e,isIPad:"iPad"===e,isIOS:!0,version:c[1].split("_").join(".")}}else b.env.os={name:"unknown",version:"0.0.0"};b.version&&(b.env.os.version=b.version(b.env.os.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;(c=d.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))?b.env.browser={name:"UC",isUC:!0,version:c[1]}:(c=d.match(/MQQBrowser\/([\d\.]+)/))?b.env.browser={name:"QQ",isQQ:!0,version:c[1]}:(c=d.match(/Firefox\/([\d\.]+)/))?b.env.browser={name:"Firefox",isFirefox:!0,version:c[1]}:(c=d.match(/MSIE\s([\d\.]+)/))||(c=d.match(/IEMobile\/([\d\.]+)/))?(b.env.browser={version:c[1]},d.match(/IEMobile/)?(b.env.browser.name="IEMobile",b.env.browser.isIEMobile=!0):(b.env.browser.name="IE",b.env.browser.isIE=!0),d.match(/Android|iPhone/)&&(b.env.browser.isIELikeWebkit=!0)):(c=d.match(/(?:Chrome|CriOS)\/([\d\.]+)/))?(b.env.browser={name:"Chrome",isChrome:!0,version:c[1]},d.match(/Version\/[\d+\.]+\s*Chrome/)&&(b.env.browser.name="Chrome Webview",b.env.browser.isWebview=!0)):d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/))?b.env.browser={name:"Android",isAndroid:!0,version:c[1]}:d.match(/iPhone|iPad|iPod/)?d.match(/Safari/)?(c=d.match(/Version\/([\d\.]+)/),b.env.browser={name:"Safari",isSafari:!0,version:c[1]}):(c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.browser={name:"iOS Webview",isWebview:!0,version:c[1].replace(/\_/g,".")}):b.env.browser={name:"unknown",version:"0.0.0"},b.version&&(b.env.browser.version=b.version(b.env.browser.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.navigator.userAgent;c.match(/Weibo/i)?b.env.thirdapp={appname:"Weibo",isWeibo:!0}:c.match(/MicroMessenger/i)?b.env.thirdapp={appname:"Weixin",isWeixin:!0}:b.env.thirdapp=!1}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d,e=a.navigator.userAgent;(d=e.match(/WindVane[\/\s]([\d\.\_]+)/))&&(c=d[1]);var f=!1,g="",h="",i="";(d=e.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))&&(f=!0,g=d[1],i=d[2],h=g.indexOf("-PD")>0?b.env.os.isIOS?"iPad":b.env.os.isAndroid?"AndroidPad":b.env.os.name:b.env.os.name),!g&&e.indexOf("TBIOS")>0&&(g="TB"),f?b.env.aliapp={windvane:b.version(c||"0.0.0"),appname:g||"unkown",version:b.version(i||"0.0.0"),platform:h||b.env.os.name}:b.env.aliapp=!1,b.env.taobaoApp=b.env.aliapp}(window,window.lib||(window.lib={}));;module.exports = window.lib['env'];

/***/ },
/* 135 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib['httpurl'];

/***/ },
/* 136 */
/***/ function(module, exports) {

	/* eslint-disable */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var isInitialized = false;
	
	// major events supported:
	//   panstart
	//   panmove
	//   panend
	//   swipe
	//   longpress
	// extra events supported:
	//   dualtouchstart
	//   dualtouch
	//   dualtouchend
	//   tap
	//   doubletap
	//   pressend
	
	var doc = window.document;
	var docEl = doc.documentElement;
	var slice = Array.prototype.slice;
	var gestures = {};
	var lastTap = null;
	
	/**
	 * find the closest common ancestor
	 * if there's no one, return null
	 *
	 * @param  {Element} el1 first element
	 * @param  {Element} el2 second element
	 * @return {Element}     common ancestor
	 */
	function getCommonAncestor(el1, el2) {
	  var el = el1;
	  while (el) {
	    if (el.contains(el2) || el == el2) {
	      return el;
	    }
	    el = el.parentNode;
	  }
	  return null;
	}
	
	/**
	 * fire a HTMLEvent
	 *
	 * @param  {Element} element which element to fire a event on
	 * @param  {string}  type    type of event
	 * @param  {object}  extra   extra data for the event object
	 */
	function fireEvent(element, type, extra) {
	  var event = doc.createEvent('HTMLEvents');
	  event.initEvent(type, true, true);
	
	  if ((typeof extra === 'undefined' ? 'undefined' : _typeof(extra)) === 'object') {
	    for (var p in extra) {
	      event[p] = extra[p];
	    }
	  }
	
	  element.dispatchEvent(event);
	}
	
	/**
	 * calc the transform
	 * assume 4 points ABCD on the coordinate system
	 * > rotateangle rotating from AB to CD
	 * > scalescale ratio from AB to CD
	 * > translatetranslate shift from A to C
	 *
	 * @param  {number} x1 abscissa of A
	 * @param  {number} y1 ordinate of A
	 * @param  {number} x2 abscissa of B
	 * @param  {number} y2 ordinate of B
	 * @param  {number} x3 abscissa of C
	 * @param  {number} y3 ordinate of C
	 * @param  {number} x4 abscissa of D
	 * @param  {number} y4 ordinate of D
	 * @return {object}    transform object like
	 *   {rotate, scale, translate[2], matrix[3][3]}
	 */
	function calc(x1, y1, x2, y2, x3, y3, x4, y4) {
	  var rotate = Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y2 - y1, x2 - x1);
	  var scale = Math.sqrt((Math.pow(y4 - y3, 2) + Math.pow(x4 - x3, 2)) / (Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)));
	  var translate = [x3 - scale * x1 * Math.cos(rotate) + scale * y1 * Math.sin(rotate), y3 - scale * y1 * Math.cos(rotate) - scale * x1 * Math.sin(rotate)];
	
	  return {
	    rotate: rotate,
	    scale: scale,
	    translate: translate,
	    matrix: [[scale * Math.cos(rotate), -scale * Math.sin(rotate), translate[0]], [scale * Math.sin(rotate), scale * Math.cos(rotate), translate[1]], [0, 0, 1]]
	  };
	}
	
	/**
	 * take over the touchstart events. Add new touches to the gestures.
	 * If there is no previous records, then bind touchmove, tochend
	 * and touchcancel events.
	 * new touches initialized with state 'tapping', and within 500 milliseconds
	 * if the state is still tapping, then trigger gesture 'press'.
	 * If there are two touche points, then the 'dualtouchstart' is triggerd. The
	 * node of the touch gesture is their cloest common ancestor.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchstartHandler(event) {
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.addEventListener('touchmove', touchmoveHandler, false);
	    docEl.addEventListener('touchend', touchendHandler, false);
	    docEl.addEventListener('touchcancel', touchcancelHandler, false);
	  }
	
	  // record every touch
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var touchRecord = {};
	
	    for (var p in touch) {
	      touchRecord[p] = touch[p];
	    }
	
	    var gesture = {
	      startTouch: touchRecord,
	      startTime: Date.now(),
	      status: 'tapping',
	      element: event.srcElement || event.target,
	      pressingHandler: setTimeout(function (element, touch) {
	        return function () {
	          if (gesture.status === 'tapping') {
	            gesture.status = 'pressing';
	
	            fireEvent(element, 'longpress', {
	              // add touch data for weex
	              touch: touch,
	              touches: event.touches,
	              changedTouches: event.changedTouches,
	              touchEvent: event
	            });
	          }
	
	          clearTimeout(gesture.pressingHandler);
	          gesture.pressingHandler = null;
	        };
	      }(event.srcElement || event.target, event.changedTouches[i]), 500)
	    };
	    gestures[touch.identifier] = gesture;
	  }
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchstart', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	}
	
	/**
	 * take over touchmove events, and handle pan and dual related gestures.
	 *
	 * 1. traverse every touch point
	 * > if 'tapping' and the shift is over 10 pixles, then it's a 'panning'.
	 * 2. if there are two touch points, then calc the tranform and trigger
	 *   'dualtouch'.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchmoveHandler(event) {
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var gesture = gestures[touch.identifier];
	
	    if (!gesture) {
	      return;
	    }
	
	    if (!gesture.lastTouch) {
	      gesture.lastTouch = gesture.startTouch;
	    }
	    if (!gesture.lastTime) {
	      gesture.lastTime = gesture.startTime;
	    }
	    if (!gesture.velocityX) {
	      gesture.velocityX = 0;
	    }
	    if (!gesture.velocityY) {
	      gesture.velocityY = 0;
	    }
	    if (!gesture.duration) {
	      gesture.duration = 0;
	    }
	
	    var time = Date.now() - gesture.lastTime;
	    var vx = (touch.clientX - gesture.lastTouch.clientX) / time;
	    var vy = (touch.clientY - gesture.lastTouch.clientY) / time;
	
	    var RECORD_DURATION = 70;
	    if (time > RECORD_DURATION) {
	      time = RECORD_DURATION;
	    }
	    if (gesture.duration + time > RECORD_DURATION) {
	      gesture.duration = RECORD_DURATION - time;
	    }
	
	    gesture.velocityX = (gesture.velocityX * gesture.duration + vx * time) / (gesture.duration + time);
	    gesture.velocityY = (gesture.velocityY * gesture.duration + vy * time) / (gesture.duration + time);
	    gesture.duration += time;
	
	    gesture.lastTouch = {};
	
	    for (var p in touch) {
	      gesture.lastTouch[p] = touch[p];
	    }
	    gesture.lastTime = Date.now();
	
	    var displacementX = touch.clientX - gesture.startTouch.clientX;
	    var displacementY = touch.clientY - gesture.startTouch.clientY;
	    var distance = Math.sqrt(Math.pow(displacementX, 2) + Math.pow(displacementY, 2));
	    var isVertical = !(Math.abs(displacementX) > Math.abs(displacementY));
	    var direction = isVertical ? displacementY >= 0 ? 'down' : 'up' : displacementX >= 0 ? 'right' : 'left';
	
	    // magic number 10: moving 10px means pan, not tap
	    if ((gesture.status === 'tapping' || gesture.status === 'pressing') && distance > 10) {
	      gesture.status = 'panning';
	      gesture.isVertical = isVertical;
	      gesture.direction = direction;
	
	      fireEvent(gesture.element, 'panstart', {
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: direction
	      });
	    }
	
	    if (gesture.status === 'panning') {
	      gesture.panTime = Date.now();
	
	      fireEvent(gesture.element, 'panmove', {
	        displacementX: displacementX,
	        displacementY: displacementY,
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: direction
	      });
	    }
	  }
	
	  if (Object.keys(gestures).length == 2) {
	    var position = [];
	    var current = [];
	    var elements = [];
	    var transform;
	
	    for (var i = 0; i < event.touches.length; i++) {
	      var touch = event.touches[i];
	      var gesture = gestures[touch.identifier];
	      position.push([gesture.startTouch.clientX, gesture.startTouch.clientY]);
	      current.push([touch.clientX, touch.clientY]);
	    }
	
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	
	    transform = calc(position[0][0], position[0][1], position[1][0], position[1][1], current[0][0], current[0][1], current[1][0], current[1][1]);
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouch', {
	      transform: transform,
	      touches: event.touches,
	      touchEvent: event
	    });
	  }
	}
	
	/**
	 * handle touchend event
	 *
	 * 1. if there are tow touch points, then trigger 'dualtouchend'
	 *
	 * 2. traverse every touch piont
	 * > if tapping, then trigger 'tap'.
	 * If there is a tap 300 milliseconds before, then it's a 'doubletap'.
	 * > if padding, then decide to trigger 'panend' or 'swipe'
	 * > if pressing, then trigger 'pressend'.
	 *
	 * 3. remove listeners.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchendHandler(event) {
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var id = touch.identifier;
	    var gesture = gestures[id];
	
	    if (!gesture) {
	      continue;
	    }
	
	    if (gesture.pressingHandler) {
	      clearTimeout(gesture.pressingHandler);
	      gesture.pressingHandler = null;
	    }
	
	    if (gesture.status === 'tapping') {
	      gesture.timestamp = Date.now();
	      fireEvent(gesture.element, 'tap', {
	        touch: touch,
	        touchEvent: event
	      });
	
	      if (lastTap && gesture.timestamp - lastTap.timestamp < 300) {
	        fireEvent(gesture.element, 'doubletap', {
	          touch: touch,
	          touchEvent: event
	        });
	      }
	
	      lastTap = gesture;
	    }
	
	    if (gesture.status === 'panning') {
	      var now = Date.now();
	      var duration = now - gesture.startTime;
	      var displacementX = touch.clientX - gesture.startTouch.clientX;
	      var displacementY = touch.clientY - gesture.startTouch.clientY;
	
	      var velocity = Math.sqrt(gesture.velocityY * gesture.velocityY + gesture.velocityX * gesture.velocityX);
	      var isSwipe = velocity > 0.5 && now - gesture.lastTime < 100;
	      var extra = {
	        duration: duration,
	        isSwipe: isSwipe,
	        velocityX: gesture.velocityX,
	        velocityY: gesture.velocityY,
	        displacementX: displacementX,
	        displacementY: displacementY,
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: gesture.direction
	      };
	
	      fireEvent(gesture.element, 'panend', extra);
	      if (isSwipe) {
	        fireEvent(gesture.element, 'swipe', extra);
	      }
	    }
	
	    if (gesture.status === 'pressing') {
	      fireEvent(gesture.element, 'pressend', {
	        touch: touch,
	        touchEvent: event
	      });
	    }
	
	    delete gestures[id];
	  }
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.removeEventListener('touchmove', touchmoveHandler, false);
	    docEl.removeEventListener('touchend', touchendHandler, false);
	    docEl.removeEventListener('touchcancel', touchcancelHandler, false);
	  }
	}
	
	/**
	 * handle touchcancel
	 *
	 * 1. if there are two touch points, then trigger 'dualtouchend'
	 *
	 * 2. traverse everty touch point:
	 * > if pannnig, then trigger 'panend'
	 * > if pressing, then trigger 'pressend'
	 *
	 * 3. remove listeners
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchcancelHandler(event) {
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var id = touch.identifier;
	    var gesture = gestures[id];
	
	    if (!gesture) {
	      continue;
	    }
	
	    if (gesture.pressingHandler) {
	      clearTimeout(gesture.pressingHandler);
	      gesture.pressingHandler = null;
	    }
	
	    if (gesture.status === 'panning') {
	      fireEvent(gesture.element, 'panend', {
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event
	      });
	    }
	    if (gesture.status === 'pressing') {
	      fireEvent(gesture.element, 'pressend', {
	        touch: touch,
	        touchEvent: event
	      });
	    }
	    delete gestures[id];
	  }
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.removeEventListener('touchmove', touchmoveHandler, false);
	    docEl.removeEventListener('touchend', touchendHandler, false);
	    docEl.removeEventListener('touchcancel', touchcancelHandler, false);
	  }
	}
	
	if (!isInitialized) {
	  docEl.addEventListener('touchstart', touchstartHandler, false);
	  isInitialized = true;
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function detectRootHeight(root) {
	  var rootQuery = '#' + root.getWeexInstance().rootId;
	  var rootContainer = document.querySelector(rootQuery) || document.body;
	  var height = rootContainer.getBoundingClientRect().height;
	  if (height > global.innerHeight) {
	    console.warn(['[h5-render] for scrollable root like \'list\' and \'scroller\', the height of ', 'the root container must be a user-specified value. Otherwise ', 'the scrollable element may not be able to work correctly. ', 'Current height of the root element \'' + rootQuery + '\' is ', height + 'px, and mostly its height should be less than the ', 'viewport\'s height ' + global.innerHeight + 'px. Please ', 'make sure the height is correct.'].join(''));
	  }
	}
	
	function init(Weex) {
	  var Component = Weex.Component;
	
	  function RootComponent(data, nodeType) {
	    var id = data.rootId + '-root';
	    var cm = _componentManager2.default.getInstance(data.instanceId);
	
	    this.data = data;
	
	    // In some situation the root component should be implemented as
	    // its own type, otherwise it has to be a div component as a root.
	    if (!nodeType) {
	      nodeType = 'div';
	    } else if (_config2.default.validRoots.indexOf(nodeType) === -1) {
	      console.warn('[h5-render] the root component type \'' + nodeType + '\' is not one of ' + 'the types in [' + _config2.default.validRoots + '] list. It is auto downgraded ' + 'to \'div\'.');
	      nodeType = 'div';
	    } else {
	      if (!global.weex.getInstance(data.instanceId).embed) {
	        window.addEventListener('renderend', function () {
	          detectRootHeight(this);
	        }.bind(this));
	      }
	      !this.data.style.height && (this.data.style.height = '100%');
	    }
	
	    data.type = nodeType;
	    var cmp = cm.createElement(data);
	    cmp.node.id = id;
	    return cmp;
	  }
	
	  RootComponent.prototype = Object.create(Component.prototype);
	
	  Weex.registerComponent('root', RootComponent);
	}
	
	exports.default = { init: init };

/***/ },
/* 138 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function init(Weex) {
	  var Component = Weex.Component;
	
	  function Div(data, nodeType) {
	    Component.call(this, data, nodeType);
	    this.node.classList.add('weex-container');
	  }
	  Div.prototype = Object.create(Component.prototype);
	
	  Weex.registerComponent('div', Div);
	  Weex.registerComponent('container', Div);
	}
	
	exports.default = { init: init };

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _image = __webpack_require__(140);
	
	var _image2 = _interopRequireDefault(_image);
	
	var _text = __webpack_require__(143);
	
	var _text2 = _interopRequireDefault(_text);
	
	var _scrollable = __webpack_require__(144);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	var _slider = __webpack_require__(161);
	
	var _slider2 = _interopRequireDefault(_slider);
	
	var _indicator = __webpack_require__(170);
	
	var _indicator2 = _interopRequireDefault(_indicator);
	
	var _tabheader = __webpack_require__(173);
	
	var _tabheader2 = _interopRequireDefault(_tabheader);
	
	var _input = __webpack_require__(176);
	
	var _input2 = _interopRequireDefault(_input);
	
	var _video = __webpack_require__(177);
	
	var _video2 = _interopRequireDefault(_video);
	
	var _switch = __webpack_require__(180);
	
	var _switch2 = _interopRequireDefault(_switch);
	
	var _a = __webpack_require__(183);
	
	var _a2 = _interopRequireDefault(_a);
	
	var _embed = __webpack_require__(184);
	
	var _embed2 = _interopRequireDefault(_embed);
	
	var _spinner = __webpack_require__(185);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _web = __webpack_require__(188);
	
	var _web2 = _interopRequireDefault(_web);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import Refresh from './refresh'
	// import Loading from './loading'
	
	// import Select from './select'
	// import Datepicker from './datepicker'
	// import Timepicker from './timepicker'
	// TODO
	// import Countdown from './countdown'
	// import Marquee from './marquee'
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_image2.default);
	    Weex.install(_text2.default);
	    Weex.install(_scrollable2.default); // TODO
	    // Weex.install(Countdown)
	    // Weex.install(Marquee)
	    Weex.install(_slider2.default);
	    Weex.install(_indicator2.default);
	    Weex.install(_tabheader2.default); // TODO
	    Weex.install(_input2.default);
	    // Weex.registerComponent('list', Vlist)
	    // Weex.registerComponent('vlist', Vlist)
	    // Weex.registerComponent('hlist', Hlist)
	    // Weex.registerComponent('scroller', Scroller)
	    // Weex.registerComponent('select', Select)
	    // Weex.registerComponent('datepicker', Datepicker)
	    // Weex.registerComponent('timepicker', Timepicker)
	    Weex.install(_video2.default);
	    Weex.install(_switch2.default);
	    Weex.install(_a2.default);
	    Weex.install(_embed2.default);
	    // Weex.install(Refresh)
	    // Weex.install(Loading)
	    Weex.install(_spinner2.default);
	    Weex.install(_web2.default);
	  }
	}; // TODO
	// import Scroller from './scroller'

	// import Vlist from './vlist'
	// import Hlist from './hlist'

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(141);
	
	var DEFAULT_SIZE = 200;
	var RESIZE_MODES = ['stretch', 'cover', 'contain'];
	var DEFAULT_RESIZE_MODE = 'stretch';
	
	/**
	 * resize: 'cover' | 'contain' | 'stretch', default is 'stretch'
	 * src: url
	 */
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-img', 'weex-element');
	    return node;
	  },
	  clearAttr: function clearAttr() {
	    this.src = '';
	    this.node.style.backgroundImage = '';
	  }
	};
	
	var attr = {
	  src: function src(val) {
	    if (!this.src) {
	      this.src = lib.img.defaultSrc;
	      this.node.style.backgroundImage = 'url(' + this.src + ')';
	    }
	    this.enableLazyload(val);
	  },
	
	  resize: function resize(val) {
	    if (RESIZE_MODES.indexOf(val) === -1) {
	      val = 'stretch';
	    }
	    this.node.style.backgroundSize = val === 'stretch' ? '100% 100%' : val;
	  }
	};
	
	var style = {
	  width: function width(val) {
	    val = parseFloat(val) * this.data.scale;
	    if (val < 0 || isNaN(val)) {
	      val = DEFAULT_SIZE;
	    }
	    this.node.style.width = val + 'px';
	  },
	
	  height: function height(val) {
	    val = parseFloat(val) * this.data.scale;
	    if (val < 0 || isNaN(val)) {
	      val = DEFAULT_SIZE;
	    }
	    this.node.style.height = val + 'px';
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  function Image(data) {
	    this.resize = DEFAULT_RESIZE_MODE;
	    Atomic.call(this, data);
	  }
	  Image.prototype = Object.create(Atomic.prototype);
	  extend(Image.prototype, proto);
	  extend(Image.prototype, { attr: attr });
	  extend(Image.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('image', Image);
	}
	
	exports.default = { init: init };

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./image.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./image.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-img {\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n  background-position: 50%;\n}", ""]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DEFAULT_FONT_SIZE = 32;
	var DEFAULT_TEXT_OVERFLOW = 'ellipsis';
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container');
	    node.style.fontSize = DEFAULT_FONT_SIZE * this.data.scale + 'px';
	    this.textNode = document.createElement('span');
	    // Give the developers the ability to control space
	    // and line-breakers.
	    this.textNode.style.whiteSpace = 'pre-wrap';
	    this.textNode.style.wordWrap = 'break-word';
	    this.textNode.style.display = '-webkit-box';
	    this.textNode.style.webkitBoxOrient = 'vertical';
	    this.style.lines.call(this, this.data.style.lines);
	    node.appendChild(this.textNode);
	    return node;
	  },
	  clearAttr: function clearAttr() {
	    this.node.firstChild.textContent = '';
	  }
	};
	
	var attr = {
	  value: function value(_value) {
	    var span = this.node.firstChild;
	    span.innerHTML = '';
	    if (_value == null || _value === '') {
	      return;
	    }
	    span.textContent = _value;
	    /**
	     * Developers are supposed to have the ability to break text
	     * lines manually. Using ``&nbsp;`` to replace text space is
	     * not compatible with the ``-webkit-line-clamp``. Therefor
	     * we use ``white-space: no-wrap`` instead (instead of the
	     * code bellow).
	       const frag = document.createDocumentFragment()
	        text.split(' ').forEach(function(str) {
	          const textNode = document.createTextNode(str)
	          const space = document.createElement('i')
	          space.innerHTML = '&nbsp;'
	          frag.appendChild(space)
	          frag.appendChild(textNode)
	        })
	        frag.removeChild(frag.firstChild)
	        span.appendChild(document.createElement('br'))
	        span.appendChild(frag)
	      })
	      span.removeChild(span.firstChild)
	     */
	  }
	};
	
	var style = {
	  lines: function lines(val) {
	    val = parseInt(val);
	    if (isNaN(val)) {
	      return;
	    }
	    if (val <= 0) {
	      this.textNode.style.textOverflow = '';
	      this.textNode.style.overflow = 'visible';
	      this.textNode.style.webkitLineClamp = '';
	    } else {
	      var _style = this.data ? this.data.style : null;
	      this.textNode.style.overflow = 'hidden';
	      this.textNode.style.textOverflow = _style ? _style.textOverflow : DEFAULT_TEXT_OVERFLOW;
	      this.textNode.style.webkitLineClamp = val;
	    }
	  },
	
	  textOverflow: function textOverflow(val) {
	    this.textNode.style.textOverflow = val;
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attr
	  //  - value: text content.
	  // style
	  //  - lines: maximum lines of the text.
	  function Text(data) {
	    Atomic.call(this, data);
	  }
	  Text.prototype = Object.create(Atomic.prototype);
	  extend(Text.prototype, proto);
	  extend(Text.prototype, { attr: attr });
	  extend(Text.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('text', Text);
	}
	
	exports.default = { init: init };

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(145);
	
	var _list2 = _interopRequireDefault(_list);
	
	var _scroller = __webpack_require__(154);
	
	var _scroller2 = _interopRequireDefault(_scroller);
	
	var _refresh = __webpack_require__(155);
	
	var _refresh2 = _interopRequireDefault(_refresh);
	
	var _loading = __webpack_require__(158);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_list2.default);
	    Weex.install(_scroller2.default);
	    Weex.install(_refresh2.default);
	    Weex.install(_loading2.default);
	  }
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _vlist = __webpack_require__(146);
	
	var _vlist2 = _interopRequireDefault(_vlist);
	
	var _hlist = __webpack_require__(153);
	
	var _hlist2 = _interopRequireDefault(_hlist);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  Weex.install(_vlist2.default);
	  Weex.install(_hlist2.default);
	}
	
	exports.default = { init: init };

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(147);
	
	var _list2 = _interopRequireDefault(_list);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var List = _list2.default.init(Weex);
	
	  function Vlist(data, nodeType) {
	    data.attr.direction = 'v';
	    List.call(this, data, nodeType);
	  }
	  Vlist.prototype = Object.create(List.prototype);
	
	  Weex.registerComponent('list', Vlist);
	  Weex.registerComponent('vlist', Vlist);
	}
	
	exports.default = { init: init };

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _scrollable = __webpack_require__(148);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var availableChildrenTypes = ['cell', 'loading', 'refresh'];
	
	function getProto(Scrollable) {
	  return {
	    create: function create() {
	      var node = Scrollable.prototype.create.call(this);
	      node.classList.add('list-wrap');
	      this.scrollElement.classList.add('list-element');
	      return node;
	    },
	    createChildren: function createChildren() {
	      var children = this.data.children || [];
	      children.forEach(function (data) {
	        var type = data.type;
	        if (availableChildrenTypes.indexOf(type) === -1) {
	          // throw new Error('[h5-render] invalid child type "'
	          //   + type + '" for list.')
	          console.warn('[h5-render] invalid child type "' + type + '" for list.');
	        }
	      });
	      return Scrollable.prototype.createChildren.call(this);
	    },
	    appendChild: function appendChild(data) {
	      var type = data.type;
	      if (availableChildrenTypes.indexOf(type) === -1) {
	        // throw new Error('[h5-render] invalid child type "'
	        //   + type + '" for list.')
	        console.warn('[h5-render] invalid child type "' + type + '" for list.');
	      }
	      return Scrollable.prototype.appendChild.call(this, data);
	    },
	    insertBefore: function insertBefore(child, before) {
	      var type = child.data.type;
	      if (availableChildrenTypes.indexOf(type) === -1) {
	        // throw new Error('[h5-render] invalid child type "'
	        //   + type + '" for list.')
	        console.warn('[h5-render] invalid child type "' + type + '" for list.');
	      }
	      return Scrollable.prototype.insertBefore.call(this, child, before);
	    }
	  };
	}
	
	function init(Weex) {
	  var Scrollable = _scrollable2.default.init(Weex);
	  function List(data, nodeType) {
	    Scrollable.call(this, data, nodeType);
	  }
	  var extend = Weex.utils.extend;
	
	  List.prototype = Object.create(Scrollable.prototype);
	  extend(List.prototype, getProto(Scrollable));
	
	  return List;
	}
	
	exports.default = { init: init };

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(149);
	__webpack_require__(151);
	
	// lib.scroll events:
	//  - scrollstart
	//  - scrolling
	//  - pulldownend
	//  - pullupend
	//  - pullleftend
	//  - pullrightend
	//  - pulldown
	//  - pullup
	//  - pullleft
	//  - pullright
	//  - contentrefresh
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	};
	
	var DEFAULT_DIRECTION = 'column';
	var DEFAULT_LOAD_MORE_OFFSET = 0;
	
	function refreshWhenDomRenderend(comp) {
	  if (!comp.renderendHandler) {
	    comp.renderendHandler = function () {
	      comp.scroller.refresh();
	    };
	  }
	  window.addEventListener('renderend', comp.renderendHandler);
	}
	
	function removeEvents(comp) {
	  if (comp.renderendHandler) {
	    window.removeEventListener('renderend', comp.renderendHandler);
	  }
	}
	
	function getProto(Weex) {
	  var Component = Weex.Component;
	
	  function create(nodeType) {
	    var Scroll = lib.scroll;
	    var node = Component.prototype.create.call(this, nodeType);
	    node.classList.add('weex-container', 'scrollable-wrap');
	    this.scrollElement = document.createElement('div');
	    this.scrollElement.classList.add('weex-container', 'scrollable-element', 'dir-' + this.direction);
	
	    this.scrollElement.style.webkitBoxOrient = directionMap[this.direction][1];
	    this.scrollElement.style.webkitFlexDirection = directionMap[this.direction][0];
	    this.scrollElement.style.flexDirection = directionMap[this.direction][0];
	
	    node.appendChild(this.scrollElement);
	    this.scroller = new Scroll({
	      // if the direction is x, then the bounding rect of the scroll element
	      // should be got by the 'Range' API other than the 'getBoundingClientRect'
	      // API, because the width outside the viewport won't be count in by
	      // 'getBoundingClientRect'.
	      // Otherwise should use the element rect in case there is a child scroller
	      // or list in this scroller. If using 'Range', the whole scroll element
	      // including the hiding part will be count in the rect.
	      useElementRect: this.direction === 'v',
	      scrollElement: this.scrollElement,
	      direction: this.direction === 'h' ? 'x' : 'y'
	    });
	    this.scroller.init();
	    this.offset = 0;
	    return node;
	  }
	
	  function createChildren() {
	    var children = this.data.children;
	    var parentRef = this.data.ref;
	    var componentManager = this.getComponentManager();
	    if (children && children.length) {
	      var fragment = document.createDocumentFragment();
	      var isFlex = false;
	      for (var i = 0; i < children.length; i++) {
	        children[i].instanceId = this.data.instanceId;
	        children[i].scale = this.data.scale;
	        var child = componentManager.createElement(children[i]);
	        fragment.appendChild(child.node);
	        child.parentRef = parentRef;
	        if (!isFlex && child.data.style && child.data.style.hasOwnProperty('flex')) {
	          isFlex = true;
	        }
	      }
	      this.scrollElement.appendChild(fragment);
	    }
	    // wait for fragment to appended on scrollElement on UI thread.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function appendChild(data) {
	    var children = this.data.children;
	    var componentManager = this.getComponentManager();
	    var child = componentManager.createElement(data);
	    this.scrollElement.appendChild(child.node);
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	
	    // update this.data.children
	    if (!children || !children.length) {
	      this.data.children = [data];
	    } else {
	      children.push(data);
	    }
	
	    return child;
	  }
	
	  function insertBefore(child, before) {
	    var children = this.data.children;
	    var i = 0;
	    var isAppend = false;
	
	    // update this.data.children
	    if (!children || !children.length || !before) {
	      isAppend = true;
	    } else {
	      var l = void 0;
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === before.data.ref) {
	          break;
	        }
	      }
	      if (i === l) {
	        isAppend = true;
	      }
	    }
	
	    if (isAppend) {
	      this.scrollElement.appendChild(child.node);
	      children.push(child.data);
	    } else {
	      var refreshLoadingPlaceholder = before.refreshPlaceholder || before.loadingPlaceholder;
	      if (refreshLoadingPlaceholder) {
	        this.scrollElement.insertBefore(child.node, refreshLoadingPlaceholder);
	      } else if (before.fixedPlaceholder) {
	        this.scrollElement.insertBefore(child.node, before.fixedPlaceholder);
	      } else if (before.stickyPlaceholder) {
	        this.scrollElement.insertBefore(child.node, before.stickyPlaceholder);
	      } else {
	        this.scrollElement.insertBefore(child.node, before.node);
	      }
	      children.splice(i, 0, child.data);
	    }
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function removeChild(child) {
	    var children = this.data.children;
	    // remove from this.data.children
	    var i = 0;
	    var componentManager = this.getComponentManager();
	    if (children && children.length) {
	      var l = void 0;
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === child.data.ref) {
	          break;
	        }
	      }
	      if (i < l) {
	        children.splice(i, 1);
	      }
	    }
	    // remove from componentMap recursively
	    componentManager.removeComponent(child.data.ref);
	    var refreshLoadingPlaceholder = child.refreshPlaceholder || child.loadingPlaceholder;
	    child.unsetPosition();
	    if (refreshLoadingPlaceholder) {
	      this.scrollElement.removeChild(refreshLoadingPlaceholder);
	    }
	    child.node.parentNode.removeChild(child.node);
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function bindEvents(evts) {
	    Component.prototype.bindEvents.call(this, evts);
	    // to enable lazyload for Images
	    this.scroller.addEventListener('scrolling', function (e) {
	      var so = e.scrollObj;
	      var scrollTop = so.getScrollTop();
	      var scrollLeft = so.getScrollLeft();
	      var offset = this.direction === 'v' ? scrollTop : scrollLeft;
	      var diff = offset - this.offset;
	      var dir = void 0;
	      if (diff >= 0) {
	        dir = this.direction === 'v' ? 'up' : 'left';
	      } else {
	        dir = this.direction === 'v' ? 'down' : 'right';
	      }
	      this.dispatchEvent('scroll', {
	        originalType: 'scrolling',
	        scrollTop: so.getScrollTop(),
	        scrollLeft: so.getScrollLeft(),
	        offset: offset,
	        direction: dir
	      }, {
	        bubbles: true
	      });
	      this.offset = offset;
	
	      // fire loadmore event.
	      var leftDist = Math.abs(so.maxScrollOffset) - this.offset;
	      if (leftDist <= this.loadmoreoffset && this.isAvailableToFireloadmore) {
	        this.isAvailableToFireloadmore = false;
	        this.dispatchEvent('loadmore');
	      } else if (leftDist > this.loadmoreoffset && !this.isAvailableToFireloadmore) {
	        this.isAvailableToFireloadmore = true;
	      }
	    }.bind(this));
	  }
	
	  function onAppend() {
	    refreshWhenDomRenderend(this);
	  }
	
	  function onRemove() {
	    removeEvents(this);
	  }
	
	  return {
	    create: create,
	    createChildren: createChildren,
	    appendChild: appendChild,
	    insertBefore: insertBefore,
	    removeChild: removeChild,
	    bindEvents: bindEvents,
	    onAppend: onAppend,
	    onRemove: onRemove
	  };
	}
	
	var attr = {
	  loadmoreoffset: function loadmoreoffset(val) {
	    val = parseFloat(val);
	    if (val < 0 || isNaN(val)) {
	      console.warn('[h5-render] invalida');
	      return;
	    }
	    this.loadmoreoffset = val;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //  - loadmoreoffset: updatable
	  //  - scroll-direciton: none|vertical|horizontal (default is vertical)
	  //  - show-scrollbar: true|false (default is true)
	  function Scrollable(data, nodeType) {
	    this.loadmoreoffset = DEFAULT_LOAD_MORE_OFFSET;
	    this.isAvailableToFireloadmore = true;
	    var attrs = data.attr || {};
	    var direction = attrs.scrollDirection || attrs.direction || DEFAULT_DIRECTION;
	    this.direction = directionMap.h.indexOf(direction) === -1 ? 'v' : 'h';
	    this.showScrollbar = attrs.showScrollbar || true;
	    Component.call(this, data, nodeType);
	  }
	  Scrollable.prototype = Object.create(Component.prototype);
	  extend(Scrollable.prototype, getProto(Weex));
	  extend(Scrollable.prototype, { attr: attr });
	  return Scrollable;
	}
	
	exports.default = { init: init };

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(150);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./scrollable.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./scrollable.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".scrollable-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.scrollable-element.horizontal {\n  -webkit-box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.scrollable-element.vertical {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/* eslint-disable */
	
	__webpack_require__(152);
	
	var doc = window.document;
	var ua = window.navigator.userAgent;
	var scrollObjs = {};
	var plugins = {};
	var dpr = window.dpr || (!!window.navigator.userAgent.match(/iPhone|iPad|iPod/) ? document.documentElement.clientWidth / window.screen.availWidth : 1);
	var inertiaCoefficient = {
	  normal: [2 * dpr, 0.0015 * dpr],
	  slow: [1.5 * dpr, 0.003 * dpr],
	  veryslow: [1.5 * dpr, 0.005 * dpr]
	};
	var timeFunction = {
	  ease: [.25, .1, .25, 1],
	  liner: [0, 0, 1, 1],
	  'ease-in': [.42, 0, 1, 1],
	  'ease-out': [0, 0, .58, 1],
	  'ease-in-out': [.42, 0, .58, 1]
	};
	var Firefox = !!ua.match(/Firefox/i);
	var IEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit';
	
	function debugLog() {
	  if (lib.scroll.outputDebugLog) {
	    console.log.apply(console, arguments);
	  }
	}
	
	function getBoundingClientRect(el) {
	  var rect = el.getBoundingClientRect();
	  if (!rect) {
	    rect = {};
	    rect.width = el.offsetWidth;
	    rect.height = el.offsetHeight;
	
	    rect.left = el.offsetLeft;
	    rect.top = el.offsetTop;
	    var parent = el.offsetParent;
	    while (parent) {
	      rect.left += parent.offsetLeft;
	      rect.top += parent.offsetTop;
	      parent = parent.offsetParent;
	    }
	
	    rect.right = rect.left + rect.width;
	    rect.bottom = rect.top + rect.height;
	  }
	  return rect;
	}
	
	function getMinScrollOffset(scrollObj) {
	  return 0 - scrollObj.options[scrollObj.axis + 'PaddingTop'];
	}
	
	function getMaxScrollOffset(scrollObj) {
	  var rect = getBoundingClientRect(scrollObj.element);
	  var pRect = getBoundingClientRect(scrollObj.viewport);
	  var min = getMinScrollOffset(scrollObj);
	  if (scrollObj.axis === 'y') {
	    var max = 0 - rect.height + pRect.height;
	  } else {
	    var max = 0 - rect.width + pRect.width;
	  }
	  return Math.min(max + scrollObj.options[scrollObj.axis + 'PaddingBottom'], min);
	}
	
	function _getBoundaryOffset(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    return offset - scrollObj.minScrollOffset;
	  }
	  if (offset < scrollObj.maxScrollOffset) {
	    return offset - scrollObj.maxScrollOffset;
	  }
	}
	
	function touchBoundary(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    offset = scrollObj.minScrollOffset;
	  } else if (offset < scrollObj.maxScrollOffset) {
	    offset = scrollObj.maxScrollOffset;
	  }
	  return offset;
	}
	
	function fireEvent(scrollObj, eventName, extra) {
	  debugLog(scrollObj.element.scrollId, eventName, extra);
	  var event = doc.createEvent('HTMLEvents');
	  event.initEvent(eventName, false, true);
	  event.scrollObj = scrollObj;
	  if (extra) {
	    for (var key in extra) {
	      event[key] = extra[key];
	    }
	  }
	  scrollObj.element.dispatchEvent(event);
	  scrollObj.viewport.dispatchEvent(event);
	}
	
	function getTransformOffset(scrollObj) {
	  var offset = { x: 0, y: 0 };
	  var transform = getComputedStyle(scrollObj.element)[stylePrefix + 'Transform'];
	  var matched;
	  var reg1 = new RegExp('^matrix3d' + '\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),' + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)');
	  var reg2 = new RegExp('^matrix' + '\\((?:[-\\d.]+,\\s*){4}([-\\d.]+),\\s*([-\\d.]+)\\)$');
	  if (transform !== 'none') {
	    if (matched = transform.match(reg1) || transform.match(reg2)) {
	      offset.x = parseFloat(matched[1]) || 0;
	      offset.y = parseFloat(matched[2]) || 0;
	    }
	  }
	
	  return offset;
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix';
	var has3d = !!Firefox || CSSMatrix in window && 'm11' in new window[CSSMatrix]();
	function getTranslate(x, y) {
	  x = parseFloat(x);
	  y = parseFloat(y);
	
	  if (x != 0) {
	    x += 'px';
	  }
	
	  if (y != 0) {
	    y += 'px';
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)';
	  }
	  return 'translate(' + x + ', ' + y + ')';
	}
	
	function setTransitionStyle(scrollObj, duration, timingFunction) {
	  if (duration === '' && timingFunction === '') {
	    scrollObj.element.style[stylePrefix + 'Transition'] = '';
	  } else {
	    scrollObj.element.style[stylePrefix + 'Transition'] = cssPrefix + 'transform ' + duration + ' ' + timingFunction + ' 0s';
	  }
	}
	
	function setTransformStyle(scrollObj, offset) {
	  var x = 0;
	  var y = 0;
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    x = offset.x;
	    y = offset.y;
	  } else {
	    if (scrollObj.axis === 'y') {
	      y = offset;
	    } else {
	      x = offset;
	    }
	  }
	  scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(x, y);
	}
	
	var panning = false;
	doc.addEventListener('touchmove', function (e) {
	  if (panning) {
	    e.preventDefault();
	    return false;
	  }
	  return true;
	}, false);
	
	function Scroll(element, options) {
	  var that = this;
	
	  options = options || {};
	  options.noBounce = !!options.noBounce;
	  options.padding = options.padding || {};
	
	  if (options.isPrevent == null) {
	    options.isPrevent = true;
	  } else {
	    options.isPrevent = !!options.isPrevent;
	  }
	
	  if (options.isFixScrollendClick == null) {
	    options.isFixScrollendClick = true;
	  } else {
	    options.isFixScrollendClick = !!options.isFixScrollendClick;
	  }
	
	  if (options.padding) {
	    options.yPaddingTop = -options.padding.top || 0;
	    options.yPaddingBottom = -options.padding.bottom || 0;
	    options.xPaddingTop = -options.padding.left || 0;
	    options.xPaddingBottom = -options.padding.right || 0;
	  } else {
	    options.yPaddingTop = 0;
	    options.yPaddingBottom = 0;
	    options.xPaddingTop = 0;
	    options.xPaddingBottom = 0;
	  }
	
	  options.direction = options.direction || 'y';
	  options.inertia = options.inertia || 'normal';
	
	  this.options = options;
	  that.axis = options.direction;
	  this.element = element;
	  this.viewport = element.parentNode;
	  this.plugins = {};
	
	  this.element.scrollId = setTimeout(function () {
	    scrollObjs[that.element.scrollId + ''] = that;
	  }, 1);
	
	  this.viewport.addEventListener('touchstart', touchstartHandler, false);
	  this.viewport.addEventListener('touchend', touchendHandler, false);
	  this.viewport.addEventListener('touchcancel', touchendHandler, false);
	  this.viewport.addEventListener('panstart', panstartHandler, false);
	  this.viewport.addEventListener('panmove', panHandler, false);
	  this.viewport.addEventListener('panend', panendHandler, false);
	
	  if (options.isPrevent) {
	    this.viewport.addEventListener('touchstart', function (e) {
	      panning = true;
	    }, false);
	    that.viewport.addEventListener('touchend', function (e) {
	      panning = false;
	    }, false);
	  }
	
	  // if (options.isPrevent) {
	  //   var d = this.axis === 'y'?'vertical':'horizontal'
	  //   this.viewport.addEventListener(d + 'panstart', function (e) {
	  //     panning = true
	  //   }, false)
	  //   that.viewport.addEventListener('panend', function (e) {
	  //     panning = false
	  //   }, false)
	  // }
	
	  if (options.isFixScrollendClick) {
	    var preventScrollendClickHandler = function preventScrollendClickHandler(e) {
	      if (preventScrollendClick || isScrolling) {
	        e.preventDefault();
	        e.stopPropagation();
	        return false;
	      }
	      return true;
	    };
	
	    var fireNiceTapEventHandler = function fireNiceTapEventHandler(e) {
	      if (!preventScrollendClick && !isScrolling) {
	        setTimeout(function () {
	          var niceTapEvent = document.createEvent('HTMLEvents');
	          niceTapEvent.initEvent('niceclick', true, true);
	          e.target.dispatchEvent(niceTapEvent);
	        }, 300);
	      }
	    };
	
	    var preventScrollendClick;
	    var fixScrollendClickTimeoutId;
	
	    this.viewport.addEventListener('scrolling', function () {
	      preventScrollendClick = true;
	      fixScrollendClickTimeoutId && clearTimeout(fixScrollendClickTimeoutId);
	      fixScrollendClickTimeoutId = setTimeout(function (e) {
	        preventScrollendClick = false;
	      }, 400);
	    }, false);
	
	    this.viewport.addEventListener('click', preventScrollendClickHandler);
	    this.viewport.addEventListener('tap', fireNiceTapEventHandler);
	  }
	
	  function setTransitionEndHandler(h, t) {
	    if (options.useFrameAnimation) {
	      return;
	    }
	    transitionEndHandler = null;
	    clearTimeout(transitionEndTimeoutId);
	
	    transitionEndTimeoutId = setTimeout(function () {
	      if (transitionEndHandler) {
	        transitionEndHandler = null;
	        lib.animation.requestFrame(h);
	      }
	    }, t || 400);
	
	    transitionEndHandler = h;
	  }
	
	  if (options.useFrameAnimation) {
	    var scrollAnimation;
	
	    Object.defineProperty(this, 'animation', {
	      get: function get() {
	        return scrollAnimation;
	      }
	    });
	  } else {
	    var transitionEndHandler;
	    var transitionEndTimeoutId = 0;
	
	    element.addEventListener(Firefox ? 'transitionend' : stylePrefix + 'TransitionEnd', function (e) {
	      if (transitionEndHandler) {
	        var handler = transitionEndHandler;
	
	        transitionEndHandler = null;
	        clearTimeout(transitionEndTimeoutId);
	
	        lib.animation.requestFrame(function () {
	          handler(e);
	        });
	      }
	    }, false);
	  }
	
	  var panFixRatio;
	  var isScrolling;
	  var isFlickScrolling;
	  var cancelScrollEnd;
	
	  Object.defineProperty(this, 'isScrolling', {
	    get: function get() {
	      return !!isScrolling;
	    }
	  });
	
	  function isEnabled(e) {
	    if (!that.enabled) {
	      return false;
	    }
	
	    if (typeof e.isVertical != 'undefined') {
	      if (that.axis === 'y' && e.isVertical || that.axis === 'x' && !e.isVertical) {
	        // gesture in same direction, stop bubbling up
	        e.stopPropagation();
	      } else {
	        // gesture in different direction, bubbling up
	        // to the top, without any other process
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  function touchstartHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    if (isScrolling) {
	      scrollEnd();
	    }
	
	    if (options.useFrameAnimation) {
	      scrollAnimation && scrollAnimation.stop();
	      scrollAnimation = null;
	    } else {
	      var transform = getTransformOffset(that);
	      setTransformStyle(that, transform);
	      setTransitionStyle(that, '', '');
	      transitionEndHandler = null;
	      clearTimeout(transitionEndTimeoutId);
	    }
	  }
	
	  function touchendHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    var s0 = getTransformOffset(that)[that.axis];
	    var boundaryOffset = _getBoundaryOffset(that, s0);
	
	    if (boundaryOffset) {
	      // dragging out of boundray, bounce is needed
	      var s1 = touchBoundary(that, s0);
	
	      if (options.useFrameAnimation) {
	        // frame
	        var _s = s1 - s0;
	        scrollAnimation = new lib.animation(400, lib.cubicbezier.ease, 0, function (i1, i2) {
	          var offset = (s0 + _s * i2).toFixed(2);
	          setTransformStyle(that, offset);
	          fireEvent(that, 'scrolling');
	        });
	        scrollAnimation.onend(scrollEnd);
	        scrollAnimation.play();
	      } else {
	        // css
	        var offset = s1.toFixed(0);
	        setTransitionEndHandler(scrollEnd, 400);
	        setTransitionStyle(that, '0.4s', 'ease');
	        setTransformStyle(that, offset);
	
	        lib.animation.requestFrame(function doScroll() {
	          if (isScrolling && that.enabled) {
	            fireEvent(that, 'scrolling');
	            lib.animation.requestFrame(doScroll);
	          }
	        });
	      }
	
	      if (boundaryOffset > 0) {
	        fireEvent(that, that.axis === 'y' ? 'pulldownend' : 'pullrightend');
	      } else if (boundaryOffset < 0) {
	        fireEvent(that, that.axis === 'y' ? 'pullupend' : 'pullleftend');
	      }
	    } else if (isScrolling) {
	      // without exceeding the boundary, just end it
	      scrollEnd();
	    }
	  }
	
	  var lastDisplacement;
	  function panstartHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    that.transformOffset = getTransformOffset(that);
	    that.minScrollOffset = getMinScrollOffset(that);
	    that.maxScrollOffset = getMaxScrollOffset(that);
	    panFixRatio = 2.5;
	    cancelScrollEnd = true;
	    isScrolling = true;
	    isFlickScrolling = false;
	    fireEvent(that, 'scrollstart');
	
	    lastDisplacement = e['displacement' + that.axis.toUpperCase()];
	  }
	
	  function panHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    // finger move less than 5 px. just ignore that.
	    var displacement = e['displacement' + that.axis.toUpperCase()];
	    if (Math.abs(displacement - lastDisplacement) < 5) {
	      e.stopPropagation();
	      return;
	    }
	    lastDisplacement = displacement;
	
	    var offset = that.transformOffset[that.axis] + displacement;
	    if (offset > that.minScrollOffset) {
	      offset = that.minScrollOffset + (offset - that.minScrollOffset) / panFixRatio;
	      panFixRatio *= 1.003;
	    } else if (offset < that.maxScrollOffset) {
	      offset = that.maxScrollOffset - (that.maxScrollOffset - offset) / panFixRatio;
	      panFixRatio *= 1.003;
	    }
	    if (panFixRatio > 4) {
	      panFixRatio = 4;
	    }
	
	    // tell whether or not reach the fringe
	    var boundaryOffset = _getBoundaryOffset(that, offset);
	    if (boundaryOffset) {
	      fireEvent(that, boundaryOffset > 0 ? that.axis === 'y' ? 'pulldown' : 'pullright' : that.axis === 'y' ? 'pullup' : 'pullleft', {
	        boundaryOffset: Math.abs(boundaryOffset)
	      });
	      if (that.options.noBounce) {
	        offset = touchBoundary(that, offset);
	      }
	    }
	
	    setTransformStyle(that, offset.toFixed(2));
	    fireEvent(that, 'scrolling');
	  }
	
	  function panendHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    if (e.isSwipe) {
	      flickHandler(e);
	    }
	  }
	
	  function flickHandler(e) {
	    cancelScrollEnd = true;
	
	    var v0, a0, t0, s0, s, motion0;
	    var v1, a1, t1, s1, motion1, sign;
	    var v2, a2, t2, s2, motion2, ft;
	
	    s0 = getTransformOffset(that)[that.axis];
	    var boundaryOffset0 = _getBoundaryOffset(that, s0);
	    if (!boundaryOffset0) {
	      // when fingers left the range of screen, let touch end handler
	      // to deal with it.
	      // when fingers left the screen, but still in the range of
	      // screen, calculate the intertia.
	      v0 = e['velocity' + that.axis.toUpperCase()];
	
	      var maxV = 2;
	      var friction = 0.0015;
	      if (options.inertia && inertiaCoefficient[options.inertia]) {
	        maxV = inertiaCoefficient[options.inertia][0];
	        friction = inertiaCoefficient[options.inertia][1];
	      }
	
	      if (v0 > maxV) {
	        v0 = maxV;
	      }
	      if (v0 < -maxV) {
	        v0 = -maxV;
	      }
	      a0 = friction * (v0 / Math.abs(v0));
	      motion0 = new lib.motion({
	        v: v0,
	        a: -a0
	      });
	      t0 = motion0.t;
	      s = s0 + motion0.s;
	
	      var boundaryOffset1 = _getBoundaryOffset(that, s);
	      if (boundaryOffset1) {
	        debugLog('inertial calculation has exceeded the boundary', boundaryOffset1);
	
	        v1 = v0;
	        a1 = a0;
	        if (boundaryOffset1 > 0) {
	          s1 = that.minScrollOffset;
	          sign = 1;
	        } else {
	          s1 = that.maxScrollOffset;
	          sign = -1;
	        }
	        motion1 = new lib.motion({
	          v: sign * v1,
	          a: -sign * a1,
	          s: Math.abs(s1 - s0)
	        });
	        t1 = motion1.t;
	        var timeFunction1 = motion1.generateCubicBezier();
	
	        v2 = v1 - a1 * t1;
	        a2 = 0.03 * (v2 / Math.abs(v2));
	        motion2 = new lib.motion({
	          v: v2,
	          a: -a2
	        });
	        t2 = motion2.t;
	        s2 = s1 + motion2.s;
	        var timeFunction2 = motion2.generateCubicBezier();
	
	        if (options.noBounce) {
	          debugLog('no bounce effect');
	
	          if (s0 !== s1) {
	            if (options.useFrameAnimation) {
	              // frame
	              var _s = s1 - s0;
	              var bezier = lib.cubicbezier(timeFunction1[0][0], timeFunction1[0][1], timeFunction1[1][0], timeFunction1[1][1]);
	              scrollAnimation = new lib.animation(t1.toFixed(0), bezier, 0, function (i1, i2) {
	                var offset = s0 + _s * i2;
	                getTransformOffset(that, offset.toFixed(2));
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                });
	              });
	
	              scrollAnimation.onend(scrollEnd);
	
	              scrollAnimation.play();
	            } else {
	              // css
	              var offset = s1.toFixed(0);
	              setTransitionEndHandler(scrollEnd, (t1 / 1000).toFixed(2) * 1000);
	              setTransitionStyle(that, (t1 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction1 + ')');
	              setTransformStyle(that, offset);
	            }
	          } else {
	            scrollEnd();
	          }
	        } else if (s0 !== s2) {
	          debugLog('scroll for inertia', 's=' + s2.toFixed(0), 't=' + ((t1 + t2) / 1000).toFixed(2));
	
	          if (options.useFrameAnimation) {
	            var _s = s2 - s0;
	            var bezier = lib.cubicbezier.easeOut;
	            scrollAnimation = new lib.animation((t1 + t2).toFixed(0), bezier, 0, function (i1, i2) {
	              var offset = s0 + _s * i2;
	              setTransformStyle(that, offset.toFixed(2));
	              fireEvent(that, 'scrolling', {
	                afterFlick: true
	              });
	            });
	
	            scrollAnimation.onend(function () {
	              if (!that.enabled) {
	                return;
	              }
	
	              var _s = s1 - s2;
	              var bezier = lib.cubicbezier.ease;
	              scrollAnimation = new lib.animation(400, bezier, 0, function (i1, i2) {
	                var offset = s2 + _s * i2;
	                setTransformStyle(that, offset.toFixed(2));
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                });
	              });
	
	              scrollAnimation.onend(scrollEnd);
	
	              scrollAnimation.play();
	            });
	
	            scrollAnimation.play();
	          } else {
	            var offset = s2.toFixed(0);
	            setTransitionEndHandler(function (e) {
	              if (!that.enabled) {
	                return;
	              }
	
	              debugLog('inertial bounce', 's=' + s1.toFixed(0), 't=400');
	
	              if (s2 !== s1) {
	                var offset = s1.toFixed(0);
	                setTransitionStyle(that, '0.4s', 'ease');
	                setTransformStyle(that, offset);
	                setTransitionEndHandler(scrollEnd, 400);
	              } else {
	                scrollEnd();
	              }
	            }, ((t1 + t2) / 1000).toFixed(2) * 1000);
	
	            setTransitionStyle(that, ((t1 + t2) / 1000).toFixed(2) + 's', 'ease-out');
	            setTransformStyle(that, offset);
	          }
	        } else {
	          scrollEnd();
	        }
	      } else {
	        debugLog('inertial calculation hasn\'t exceeded the boundary');
	        var timeFunction = motion0.generateCubicBezier();
	
	        if (options.useFrameAnimation) {
	          // frame
	          var _s = s - s0;
	          var bezier = lib.cubicbezier(timeFunction[0][0], timeFunction[0][1], timeFunction[1][0], timeFunction[1][1]);
	          scrollAnimation = new lib.animation(t0.toFixed(0), bezier, 0, function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2);
	            setTransformStyle(that, offset);
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            });
	          });
	
	          scrollAnimation.onend(scrollEnd);
	
	          scrollAnimation.play();
	        } else {
	          // css
	          var offset = s.toFixed(0);
	          setTransitionEndHandler(scrollEnd, (t0 / 1000).toFixed(2) * 1000);
	          setTransitionStyle(that, (t0 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction + ')');
	          setTransformStyle(that, offset);
	        }
	      }
	
	      isFlickScrolling = true;
	      if (!options.useFrameAnimation) {
	        lib.animation.requestFrame(function doScroll() {
	          if (isScrolling && isFlickScrolling && that.enabled) {
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            });
	            lib.animation.requestFrame(doScroll);
	          }
	        });
	      }
	    }
	  }
	
	  function scrollEnd() {
	    if (!that.enabled) {
	      return;
	    }
	
	    cancelScrollEnd = false;
	
	    setTimeout(function () {
	      if (!cancelScrollEnd && isScrolling) {
	        isScrolling = false;
	        isFlickScrolling = false;
	
	        if (options.useFrameAnimation) {
	          scrollAnimation && scrollAnimation.stop();
	          scrollAnimation = null;
	        } else {
	          setTransitionStyle(that, '', '');
	        }
	        fireEvent(that, 'scrollend');
	      }
	    }, 50);
	  }
	
	  var proto = {
	    init: function init() {
	      this.enable();
	      this.refresh();
	      this.scrollTo(0);
	      return this;
	    },
	
	    enable: function enable() {
	      this.enabled = true;
	      return this;
	    },
	
	    disable: function disable() {
	      var el = this.element;
	      this.enabled = false;
	
	      if (this.options.useFrameAnimation) {
	        scrollAnimation && scrollAnimation.stop();
	      } else {
	        lib.animation.requestFrame(function () {
	          el.style[stylePrefix + 'Transform'] = getComputedStyle(el)[stylePrefix + 'Transform'];
	        });
	      }
	
	      return this;
	    },
	
	    getScrollWidth: function getScrollWidth() {
	      return getBoundingClientRect(this.element).width;
	    },
	
	    getScrollHeight: function getScrollHeight() {
	      return getBoundingClientRect(this.element).height;
	    },
	
	    getScrollLeft: function getScrollLeft() {
	      return -getTransformOffset(this).x - this.options.xPaddingTop;
	    },
	
	    getScrollTop: function getScrollTop() {
	      return -getTransformOffset(this).y - this.options.yPaddingTop;
	    },
	
	    getMaxScrollLeft: function getMaxScrollLeft() {
	      return -that.maxScrollOffset - this.options.xPaddingTop;
	    },
	
	    getMaxScrollTop: function getMaxScrollTop() {
	      return -that.maxScrollOffset - this.options.yPaddingTop;
	    },
	
	    getBoundaryOffset: function getBoundaryOffset() {
	      return Math.abs(_getBoundaryOffset(this, getTransformOffset(this)[this.axis]) || 0);
	    },
	
	    refresh: function refresh() {
	      var el = this.element;
	      var isVertical = this.axis === 'y';
	      var type = isVertical ? 'height' : 'width';
	      var size, rect, extraSize;
	
	      function getExtraSize(el, isVertical) {
	        var extraType = isVertical ? ['top', 'bottom'] : ['left', 'right'];
	        return parseFloat(getComputedStyle(el.firstElementChild)['margin-' + extraType[0]]) + parseFloat(getComputedStyle(el.lastElementChild)['margin-' + extraType[1]]);
	      }
	
	      if (this.options[type] != null) {
	        // use options
	        size = this.options[type];
	      } else if (el.childElementCount <= 0) {
	        el.style[type] = 'auto';
	        size = null;
	      } else if (!!this.options.useElementRect) {
	        el.style[type] = 'auto';
	        rect = getBoundingClientRect(el);
	        size = rect[type];
	        size += getExtraSize(el, isVertical);
	      } else {
	        var range, rect;
	        var firstEl = el.firstElementChild;
	        var lastEl = el.lastElementChild;
	
	        if (document.createRange && !this.options.ignoreOverflow) {
	          // use range
	          range = document.createRange();
	          range.selectNodeContents(el);
	          rect = getBoundingClientRect(range);
	        }
	
	        if (rect) {
	          size = rect[type];
	        } else {
	          // use child offsets
	          while (firstEl) {
	            if (getBoundingClientRect(firstEl)[type] === 0 && firstEl.nextElementSibling) {
	              firstEl = firstEl.nextElementSibling;
	            } else {
	              break;
	            }
	          }
	
	          while (lastEl && lastEl !== firstEl) {
	            if (getBoundingClientRect(lastEl)[type] === 0 && lastEl.previousElementSibling) {
	              lastEl = lastEl.previousElementSibling;
	            } else {
	              break;
	            }
	          }
	
	          size = getBoundingClientRect(lastEl)[isVertical ? 'bottom' : 'right'] - getBoundingClientRect(firstEl)[isVertical ? 'top' : 'left'];
	        }
	
	        size += getExtraSize(el, isVertical);
	      }
	
	      el.style[type] = size ? size + 'px' : 'auto';
	
	      this.transformOffset = getTransformOffset(this);
	      this.minScrollOffset = getMinScrollOffset(this);
	      this.maxScrollOffset = getMaxScrollOffset(this);
	
	      this.scrollTo(-this.transformOffset[this.axis] - this.options[this.axis + 'PaddingTop']);
	      fireEvent(this, 'contentrefresh');
	
	      return this;
	    },
	
	    offset: function offset(childEl) {
	      var elRect = getBoundingClientRect(this.element);
	      var childRect = getBoundingClientRect(childEl);
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - elRect.top - this.options.yPaddingTop,
	          left: childRect.left - elRect.left,
	          right: elRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height;
	      } else {
	        var offsetRect = {
	          top: childRect.top - elRect.top,
	          bottom: elRect.bottom - childRect.bottom,
	          left: childRect.left - elRect.left - this.options.xPaddingTop,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.right = offsetRect.left + offsetRect.width;
	      }
	      return offsetRect;
	    },
	
	    getRect: function getRect(childEl) {
	      var viewRect = getBoundingClientRect(this.viewport);
	      var childRect = getBoundingClientRect(childEl);
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          left: childRect.left - viewRect.left,
	          right: viewRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height;
	      } else {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          bottom: viewRect.bottom - childRect.bottom,
	          left: childRect.left - viewRect.left,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.right = offsetRect.left + offsetRect.width;
	      }
	      return offsetRect;
	    },
	
	    isInView: function isInView(childEl) {
	      var viewRect = this.getRect(this.viewport);
	      var childRect = this.getRect(childEl);
	      if (this.axis === 'y') {
	        return viewRect.top < childRect.bottom && viewRect.bottom > childRect.top;
	      }
	      return viewRect.left < childRect.right && viewRect.right > childRect.left;
	    },
	
	    scrollTo: function scrollTo(offset, isSmooth) {
	      var that = this;
	      var element = this.element;
	
	      offset = -offset - this.options[this.axis + 'PaddingTop'];
	      offset = touchBoundary(this, offset);
	
	      isScrolling = true;
	      if (isSmooth === true) {
	        if (this.options.useFrameAnimation) {
	          var s0 = getTransformOffset(that)[this.axis];
	          var _s = offset - s0;
	          scrollAnimation = new lib.animation(400, lib.cubicbezier.easeInOut, 0, function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2);
	            setTransformStyle(that, offset);
	            fireEvent(that, 'scrolling');
	          });
	
	          scrollAnimation.onend(scrollEnd);
	
	          scrollAnimation.play();
	        } else {
	          (function () {
	            var _cancelScroll = function _cancelScroll() {
	              if (isScrolling && that.enabled) {
	                fireEvent(that, 'scrolling');
	                lib.animation.requestFrame(_cancelScroll);
	              }
	            };
	
	            setTransitionEndHandler(scrollEnd, 400);
	            setTransitionStyle(that, '0.4s', 'ease-in-out');
	            setTransformStyle(that, offset);
	
	            lib.animation.requestFrame(_cancelScroll);
	          })();
	        }
	      } else {
	        if (!this.options.useFrameAnimation) {
	          setTransitionStyle(that, '', '');
	        }
	        setTransformStyle(that, offset);
	        scrollEnd();
	      }
	
	      return this;
	    },
	
	    scrollToElement: function scrollToElement(childEl, isSmooth, topOffset) {
	      var offset = this.offset(childEl);
	      offset = offset[this.axis === 'y' ? 'top' : 'left'];
	      topOffset && (offset += topOffset);
	      return this.scrollTo(offset, isSmooth);
	    },
	
	    getViewWidth: function getViewWidth() {
	      return getBoundingClientRect(this.viewport).width;
	    },
	
	    getViewHeight: function getViewHeight() {
	      return getBoundingClientRect(this.viewport).height;
	    },
	
	    addPulldownHandler: function addPulldownHandler(handler) {
	      var that = this;
	      this.element.addEventListener('pulldownend', function (e) {
	        that.disable();
	        handler.call(that, e, function () {
	          that.scrollTo(0, true);
	          that.refresh();
	          that.enable();
	        });
	      }, false);
	
	      return this;
	    },
	
	    addPullupHandler: function addPullupHandler(handler) {
	      var that = this;
	
	      this.element.addEventListener('pullupend', function (e) {
	        that.disable();
	        handler.call(that, e, function () {
	          that.scrollTo(that.getScrollHeight(), true);
	          that.refresh();
	          that.enable();
	        });
	      }, false);
	
	      return this;
	    },
	
	    addScrollstartHandler: function addScrollstartHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrollstart', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addScrollingHandler: function addScrollingHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrolling', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addScrollendHandler: function addScrollendHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrollend', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addContentrenfreshHandler: function addContentrenfreshHandler(handler) {
	      var that = this;
	      this.element.addEventListener('contentrefresh', function (e) {
	        handler.call(that, e);
	      }, false);
	    },
	
	    addEventListener: function addEventListener(name, handler, useCapture) {
	      var that = this;
	      this.element.addEventListener(name, function (e) {
	        handler.call(that, e);
	      }, !!useCapture);
	    },
	
	    removeEventListener: function removeEventListener(name, handler) {
	      var that = this;
	      this.element.removeEventListener(name, function (e) {
	        handler.call(that, e);
	      });
	    },
	
	    enablePlugin: function enablePlugin(name, options) {
	      var plugin = plugins[name];
	      if (plugin && !this.plugins[name]) {
	        this.plugins[name] = true;
	        options = options || {};
	        plugin.call(this, name, options);
	      }
	      return this;
	    }
	  };
	
	  for (var k in proto) {
	    this[k] = proto[k];
	  }
	  // delete proto
	}
	
	lib.scroll = function (el, options) {
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0];
	    if (options.scrollElement) {
	      el = options.scrollElement;
	    } else if (options.scrollWrap) {
	      el = options.scrollWrap.firstElementChild;
	    } else {
	      throw new Error('no scroll element');
	    }
	  }
	
	  if (!el.parentNode) {
	    throw new Error('wrong dom tree');
	  }
	  if (options && options.direction && ['x', 'y'].indexOf(options.direction) < 0) {
	    throw new Error('wrong direction');
	  }
	
	  var scroll;
	  if (options.downgrade === true && lib.scroll.downgrade) {
	    scroll = lib.scroll.downgrade(el, options);
	  } else {
	    if (el.scrollId) {
	      scroll = scrollObjs[el.scrollId];
	    } else {
	      scroll = new Scroll(el, options);
	    }
	  }
	  return scroll;
	};
	
	lib.scroll.plugin = function (name, constructor) {
	  if (constructor) {
	    name = name.split(',');
	    name.forEach(function (n) {
	      plugins[n] = constructor;
	    });
	  } else {
	    return plugins[name];
	  }
	};

/***/ },
/* 152 */
/***/ function(module, exports) {

	/* global lib: true */
	
	'use strict';
	
	/**
	 * transfer Quadratic Bezier Curve to Cubic Bezier Curve
	 *
	 * @param  {number} a abscissa of p1
	 * @param  {number} b ordinate of p1
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	
	function quadratic2cubicBezier(a, b) {
	  return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)], [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]];
	}
	
	/**
	 * derive position data from knowing motion parameters
	 * base on Newton's second law: s = vt + at^2/2
	 *
	 * @param {object} config object of { v, a, s, t }
	 *   - v: initial velocity
	 *   - a: accelerate speed
	 *   - t: time
	 *   - s: shifting
	 */
	function Motion(config) {
	  this.v = config.v || 0;
	  this.a = config.a || 0;
	
	  if (typeof config.t !== 'undefined') {
	    this.t = config.t;
	  }
	
	  if (typeof config.s !== 'undefined') {
	    this.s = config.s;
	  }
	
	  // derive time from shifting
	  if (typeof this.t === 'undefined') {
	    if (typeof this.s === 'undefined') {
	      this.t = -this.v / this.a;
	    } else {
	      var t1 = (Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
	      var t2 = (-Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
	      this.t = Math.min(t1, t2);
	    }
	  }
	
	  // derive shifting from time
	  if (typeof this.s === 'undefined') {
	    this.s = this.a * this.t * this.t / 2 + this.v * this.t;
	  }
	}
	
	/**
	 * derive cubic bezier parameters from motion parameters
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	Motion.prototype.generateCubicBezier = function () {
	  return quadratic2cubicBezier(this.v / this.a, this.t + this.v / this.a);
	};
	
	!lib && (lib = {});
	lib.motion = Motion;
	
	module.exports = Motion;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(147);
	
	var _list2 = _interopRequireDefault(_list);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var List = _list2.default.init(Weex);
	
	  function Hlist(data, nodeType) {
	    data.attr.direction = 'h';
	    List.call(this, data, nodeType);
	  }
	
	  Hlist.prototype = Object.create(List.prototype);
	
	  Weex.registerComponent('hlist', Hlist);
	}
	
	exports.default = { init: init };

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _scrollable = __webpack_require__(148);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var Scrollable = _scrollable2.default.init(Weex);
	  function Scroller(data, nodeType) {
	    Scrollable.call(this, data, nodeType);
	  }
	  var extend = Weex.utils.extend;
	
	  Scroller.prototype = Object.create(Scrollable.prototype);
	  extend(Scroller.prototype, {
	    create: function create() {
	      var node = Scrollable.prototype.create.call(this);
	      node.classList.add('scroller-wrap');
	      this.scrollElement.classList.add('scroller-element');
	      return node;
	    }
	  });
	
	  Weex.registerComponent('scroller', Scroller);
	}
	
	exports.default = { init: init };

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(156);
	
	var parents = ['scroller', 'list', 'vlist'];
	
	// Only if pulldown offset is larger than this value can this
	// component trigger the 'refresh' event, otherwise just recover
	// to the start point.
	var DEFAULT_CLAMP = 130;
	var DEFAULT_ALIGN_ITEMS = 'center';
	var DEFAULT_JUSTIFY_CONTENT = 'center';
	
	function adjustHeight(refresh, val) {
	  refresh.node.style.height = val + 'px';
	}
	
	// function adJustPosition (refresh, val) {
	//   refresh.node.style.top = -val + 'px'
	// }
	
	function handleRefresh(refresh, e) {
	  refresh.node.style.height = refresh.clamp + 'px';
	  refresh.dispatchEvent('refresh');
	  refresh.isRefreshing = true;
	}
	
	function show(refresh) {
	  refresh.display = true;
	  refresh.node.style.display = '-webkit-box';
	  refresh.node.style.display = '-webkit-flex';
	  refresh.node.style.display = 'flex';
	}
	
	function hide(refresh) {
	  refresh.display = false;
	  refresh.node.style.display = 'none';
	  refresh.isRefreshing = false;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-refresh');
	    return node;
	  },
	  onAppend: function onAppend() {
	    var parent = this.getParent();
	    var self = this;
	    if (parents.indexOf(parent.data.type) === -1) {
	      // not in a scroller or a list
	      return;
	    }
	    this.refreshPlaceholder = document.createElement('div');
	    this.refreshPlaceholder.classList.add('weex-refresh-placeholder');
	    this.refreshPlaceholder.style.display = 'none';
	    this.refreshPlaceholder.style.width = '0px';
	    this.refreshPlaceholder.style.height = '0px';
	    var scrollElement = parent.scrollElement || parent.listElement;
	    scrollElement.insertBefore(this.refreshPlaceholder, this.node);
	    parent.node.appendChild(this.node);
	    parent.scroller.addEventListener('pulldown', function (e) {
	      if (self.isRefreshing) {
	        return;
	      }
	      adjustHeight(self, Math.abs(e.scrollObj.getScrollTop()));
	      if (!self.display) {
	        show(self);
	      }
	    });
	    parent.scroller.addEventListener('pulldownend', function (e) {
	      if (self.isRefreshing) {
	        return;
	      }
	      var top = Math.abs(e.scrollObj.getScrollTop());
	      if (top > self.clamp) {
	        handleRefresh(self, e);
	      } else {
	        hide(self);
	      }
	    });
	  }
	};
	
	var attr = {
	  display: function display(val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        show(this);
	      }.bind(this), 0);
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        hide(this);
	      }.bind(this), 0);
	    } else {
	      console.error('[h5-render] attr \'display\' of <refresh>\': value ' + val + ' is invalid. Should be \'show\' or \'hide\'');
	    }
	  }
	};
	
	var style = {
	  height: function height(val) {
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      return console.warn('[h5-render] <refresh>\'s height (' + val + ') is invalid.');
	    }
	    this.clamp = val * this.data.scale;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  function Refresh(data) {
	    this.isRefreshing = false;
	    this.clamp = (data.style.height || DEFAULT_CLAMP) * data.scale;
	    !data.style.alignItems && (data.style.alignItems = DEFAULT_ALIGN_ITEMS);
	    !data.style.justifyContent && (data.style.justifyContent = DEFAULT_JUSTIFY_CONTENT);
	    Component.call(this, data);
	  }
	  Refresh.prototype = Object.create(Component.prototype);
	  extend(Refresh.prototype, proto);
	  extend(Refresh.prototype, { attr: attr });
	  extend(Refresh.prototype, {
	    style: extend(Object.create(Component.prototype.style), style)
	  });
	
	  Weex.registerComponent('refresh', Refresh);
	}
	
	exports.default = { init: init };

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(157);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../../node_modules/css-loader/index.js!./refresh.css", function() {
				var newContent = require("!!./../../../../../../node_modules/css-loader/index.js!./refresh.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-refresh {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n  z-index: 999999;\n  background-color: #666;\n}", ""]);
	
	// exports


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(159);
	
	var parents = ['scroller', 'list', 'vlist'];
	
	var DEFAULT_CLAMP = 130;
	var DEFAULT_ALIGN_ITEMS = 'center';
	var DEFAULT_JUSTIFY_CONTENT = 'center';
	
	function adjustHeight(loading, val) {
	  loading.node.style.height = val + 'px';
	}
	
	function handleLoading(loading, e) {
	  loading.node.style.height = loading.clamp + 'px';
	  loading.dispatchEvent('loading');
	  loading.isLoading = true;
	}
	
	function show(loading) {
	  loading.display = true;
	  loading.node.style.display = '-webkit-box';
	  loading.node.style.display = '-webkit-flex';
	  loading.node.style.display = 'flex';
	}
	
	function hide(loading) {
	  loading.display = false;
	  loading.node.style.display = 'none';
	  loading.isLoading = false;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-loading');
	    return node;
	  },
	  onAppend: function onAppend() {
	    var parent = this.getParent();
	    var self = this;
	    var scrollWrapHeight = parent.node.getBoundingClientRect().height;
	    if (parents.indexOf(parent.data.type) === -1) {
	      // not in a scroller or a list
	      return;
	    }
	    this.loadingPlaceholder = document.createElement('div');
	    this.loadingPlaceholder.classList.add('weex-loading-placeholder');
	    this.loadingPlaceholder.style.display = 'none';
	    this.loadingPlaceholder.style.width = '0px';
	    this.loadingPlaceholder.style.height = '0px';
	    var scrollElement = parent.scrollElement || parent.listElement;
	    scrollElement.insertBefore(this.loadingPlaceholder, this.node);
	    parent.node.appendChild(this.node);
	    parent.scroller.addEventListener('pullup', function (e) {
	      if (self.isLoading) {
	        return;
	      }
	      var obj = e.scrollObj;
	      adjustHeight(self, Math.abs(obj.getScrollHeight() - obj.getScrollTop() - scrollWrapHeight));
	      if (!self.display) {
	        show(self);
	      }
	    });
	    parent.scroller.addEventListener('pullupend', function (e) {
	      if (self.isLoading) {
	        return;
	      }
	      handleLoading(self, e);
	    });
	  }
	};
	
	var attr = {
	  display: function display(val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        show(this);
	      }.bind(this), 0);
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        hide(this);
	      }.bind(this), 0);
	    } else {
	      console.error('[h5-render] attr \'display\' of <refresh>\': value ' + val + ' is invalid. Should be \'show\' or \'hide\'');
	    }
	  }
	};
	
	var style = {
	  height: function height(val) {
	    val = parseFloat(val);
	    if (Number.isNaN(val) || val < 0) {
	      return console.warn('[h5-render] <loading>\'s height (' + val + ') is invalid.');
	    }
	    this.clamp = val * this.data.scale;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  function Loading(data) {
	    this.clamp = (data.style.height || DEFAULT_CLAMP) * data.scale;
	    !data.style.alignItems && (data.style.alignItems = DEFAULT_ALIGN_ITEMS);
	    !data.style.justifyContent && (data.style.justifyContent = DEFAULT_JUSTIFY_CONTENT);
	    Component.call(this, data);
	  }
	  Loading.prototype = Object.create(Component.prototype);
	  extend(Loading.prototype, proto);
	  extend(Loading.prototype, { attr: attr });
	  extend(Loading.prototype, {
	    style: extend(Object.create(Component.prototype.style), style)
	  });
	
	  Weex.registerComponent('loading', Loading);
	}
	
	exports.default = { init: init };

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(160);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../../node_modules/css-loader/index.js!./loading.css", function() {
				var newContent = require("!!./../../../../../../node_modules/css-loader/index.js!./loading.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-loading {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n  background-color: #666;\n}", ""]);
	
	// exports


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(162);
	
	__webpack_require__(168);
	
	var DEFAULT_INTERVAL = 3000;
	
	var extend = void 0,
	    Component = void 0;
	
	function idleWhenPageDisappear(slider) {
	  function handlePageShow() {
	    slider.isPageShow = true;
	    slider.autoPlay && !slider.isDomRendering && slider.play();
	  }
	  function handlePageHide() {
	    slider.isPageShow = false;
	    slider.stop();
	  }
	  global.addEventListener('pageshow', handlePageShow);
	  global.addEventListener('pagehide', handlePageHide);
	  document.addEventListener('visibilitychange', function () {
	    if (document.visibilityState === 'visible') {
	      handlePageShow();
	    } else if (document.visibilityState === 'hidden') {
	      handlePageHide();
	    }
	  });
	}
	
	function idleWhenDomRendering(slider) {
	  global.addEventListener('renderend', function () {
	    slider.isDomRendering = false;
	    slider.autoPlay && slider.isPageShow && slider.play();
	  });
	  global.addEventListener('renderbegin', function () {
	    slider.isDomRendering = true;
	    slider.stop();
	  });
	}
	
	function updateIndicators(slider) {
	  slider.indicator && slider.indicator.setIndex(slider.currentIndex);
	}
	
	function getSliderChangeHandler(slider) {
	  if (!slider._sliderChangeHandler) {
	    slider._sliderChangeHandler = function (e) {
	      var index = this.carrousel.items.index;
	      this.currentIndex = index;
	      updateIndicators(this);
	      this.dispatchEvent('change', { index: index });
	    }.bind(slider);
	  }
	  return slider._sliderChangeHandler;
	}
	
	function doRender(slider) {
	  slider.createChildren();
	  slider.onAppend();
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('slider');
	    node.style.position = 'relative';
	    node.style.overflow = 'hidden';
	    return node;
	  },
	  createChildren: function createChildren() {
	    var componentManager = this.getComponentManager();
	
	    // recreate slider container.
	    if (this.sliderContainer) {
	      this.node.removeChild(this.sliderContainer);
	    }
	    if (this.indicator) {
	      this.indicator.node.parentNode.removeChild(this.indicator.node);
	    }
	    this.children = [];
	
	    var sliderContainer = document.createElement('ul');
	    sliderContainer.style.listStyle = 'none';
	    this.node.appendChild(sliderContainer);
	    this.sliderContainer = sliderContainer;
	
	    var children = this.data.children;
	    var scale = this.data.scale;
	    var fragment = document.createDocumentFragment();
	    var indicatorData = void 0,
	        width = void 0,
	        height = void 0;
	    var childWidth = 0;
	    var childHeight = 0;
	
	    if (children && children.length) {
	      for (var i = 0; i < children.length; i++) {
	        var child = void 0;
	        children[i].scale = this.data.scale;
	        children[i].instanceId = this.data.instanceId;
	        if (children[i].type === 'indicator') {
	          indicatorData = extend(children[i], {
	            extra: {
	              amount: children.length - 1,
	              index: 0
	            }
	          });
	        } else {
	          child = componentManager.createElement(children[i], 'li');
	          this.children.push(child);
	          fragment.appendChild(child.node);
	          width = child.data.style.width || 0;
	          height = child.data.style.height || 0;
	          width > childWidth && (childWidth = width);
	          height > childHeight && (childHeight = height);
	          child.parentRef = this.data.ref;
	        }
	      }
	      // append indicator
	      if (indicatorData) {
	        indicatorData.extra.width = this.data.style.width || childWidth;
	        indicatorData.extra.height = this.data.style.height || childHeight;
	        this.indicator = componentManager.createElement(indicatorData);
	        this.indicator.parentRef = this.data.ref;
	        this.indicator.slider = this;
	        this.node.appendChild(this.indicator.node);
	      }
	
	      sliderContainer.style.height = scale * this.data.style.height + 'px';
	      sliderContainer.appendChild(fragment);
	    }
	  },
	  appendChild: function appendChild(data) {
	    var children = this.data.children || (this.data.children = []);
	    children.push(data);
	    doRender(this);
	    if (this.children.length > 0) {
	      return this.children[this.children.length - 1];
	    }
	  },
	  insertBefore: function insertBefore(child, before) {
	    var children = this.data.children;
	    var childIndex = -1;
	    for (var i = 0, l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        childIndex = i;
	        break;
	      }
	    }
	    children.splice(childIndex, 0, child.data);
	    doRender(this);
	    if (this.children.length > 0) {
	      return this.children[this.children.length - 1];
	    }
	  },
	  removeChild: function removeChild(child) {
	    var children = this.data.children;
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        if (child.data.ref === children[i].ref) {
	          children.splice(i, 1);
	          break;
	        }
	      }
	    }
	    doRender(this);
	  },
	  onAppend: function onAppend() {
	    if (this.carrousel) {
	      this.carrousel.removeEventListener('change', getSliderChangeHandler(this));
	      this.carrousel.stop();
	      this.carrousel = null;
	    }
	    var Carrousel = lib.carrousel;
	    this.carrousel = new Carrousel(this.sliderContainer, {
	      autoplay: this.autoPlay,
	      useGesture: true
	    });
	
	    this.carrousel.playInterval = this.interval;
	    this.carrousel.addEventListener('change', getSliderChangeHandler(this));
	    this.currentIndex = 0;
	
	    // preload all images for slider
	    // because:
	    // 1. lib-img doesn't listen to event transitionend
	    // 2. even if we fire lazy load in slider's change event handler,
	    //    the next image still won't be preloaded utill the moment it
	    //    slides into the view, which is too late.
	    if (this.preloadImgsTimer) {
	      clearTimeout(this.preloadImgsTimer);
	    }
	    // The time just before the second slide appear and enough
	    // for all child elements to append is ok.
	    var preloadTime = 0.8;
	    this.preloadImgsTimer = setTimeout(function () {
	      var imgs = this.carrousel.element.querySelectorAll('.weex-img');
	      for (var i = 0, l = imgs.length; i < l; i++) {
	        var img = imgs[i];
	        var iLazySrc = img.getAttribute('i-lazy-src');
	        var imgSrc = img.getAttribute('img-src');
	        if (iLazySrc) {
	          img.style.backgroundImage = 'url(' + iLazySrc + ')';
	        } else if (imgSrc) {
	          img.style.backgroundImage = 'url(' + imgSrc + ')';
	        }
	        img.removeAttribute('i-lazy-src');
	        img.removeAttribute('img-src');
	      }
	    }.bind(this), preloadTime * 1000);
	
	    // avoid page scroll when panning
	    var panning = false;
	    this.carrousel.element.addEventListener('panstart', function (e) {
	      if (!e.isVertical) {
	        panning = true;
	      }
	    });
	    this.carrousel.element.addEventListener('panend', function (e) {
	      if (!e.isVertical) {
	        panning = false;
	      }
	    });
	
	    document.addEventListener('touchmove', function (e) {
	      if (panning) {
	        e.preventDefault();
	        return false;
	      }
	      return true;
	    });
	
	    Component.prototype.onAppend.call(this);
	  },
	  play: function play() {
	    this.carrousel.play();
	  },
	  stop: function stop() {
	    this.carrousel.stop();
	  },
	  slideTo: function slideTo(index) {
	    var offset = index - this.currentIndex;
	    this.carrousel.items.slide(offset);
	  }
	};
	
	var attr = {
	  interval: function interval(val) {
	    this.interval = parseInt(val) || DEFAULT_INTERVAL;
	    if (this.carrousel) {
	      this.carrousel.playInterval = this.interval;
	    }
	  },
	
	  index: function index(val) {
	    var _this = this;
	    function doSlide(index) {
	      index = parseInt(index);
	      if (index < 0 || isNaN(index)) {
	        return console.error('[h5-render] invalid index ', index);
	      }
	      _this.slideTo(index);
	      if (_this._updateIndex) {
	        window.removeEventListener('renderend', _this._updateIndex);
	      }
	    }
	    if (this.isDomRendering) {
	      var pre = !!this._updateIndex;
	      this._updateIndex = function () {
	        _this.autoPlay && _this.isPageShow && _this.play();
	        doSlide(val);
	      };
	      !pre && window.addEventListener('renderend', this._updateIndex);
	    } else {
	      doSlide(val);
	    }
	  },
	
	  playstatus: function playstatus(val) {
	    this.playstatus = val && val !== 'false';
	    this.autoPlay = this.playstatus;
	    if (this.carrousel) {
	      if (this.playstatus) {
	        this.play();
	      } else {
	        this.stop();
	      }
	    }
	  },
	
	  // support playstatus' alias auto-play for compatibility
	  autoPlay: function autoPlay(val) {
	    this.attr.playstatus.call(this, val);
	  }
	};
	
	var event = {
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          index: this.currentIndex
	        }
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  Component = Weex.Component;
	  extend = Weex.utils.extend;
	
	  function Slider(data) {
	    this.autoPlay = false; // default value is false.
	    this.interval = DEFAULT_INTERVAL;
	    this.direction = 'row'; // 'column' is not temporarily supported.
	    this.children = [];
	    this.isPageShow = true;
	    this.isDomRendering = true;
	
	    // bind event 'pageshow', 'pagehide' and 'visibilitychange' on window.
	    idleWhenPageDisappear(this);
	    // bind event 'renderBegin' and 'renderEnd' on window.
	    idleWhenDomRendering(this);
	
	    Component.call(this, data);
	  }
	  Slider.prototype = Object.create(Component.prototype);
	  extend(Slider.prototype, proto);
	  extend(Slider.prototype, { attr: attr });
	  extend(Slider.prototype, { event: event });
	
	  Weex.registerComponent('slider', Slider);
	}
	
	exports.default = { init: init };

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable */
	
	'use strict';
	
	// require('./gesture')
	
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	
	var doc = window.document;
	var ua = window.navigator.userAgent;
	var Firefox = !!ua.match(/Firefox/i);
	var IEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit';
	
	var timer = __webpack_require__(167);
	var setTimeout = timer.setTimeout;
	var clearTimeout = timer.clearTimeout;
	
	function getTransformOffset(element) {
	  var offset = { x: 0, y: 0 };
	  var transform = getComputedStyle(element)[stylePrefix + 'Transform'];
	  var regMatrix3d = new RegExp('^matrix3d\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),' + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)');
	  var regMatrix = /^matrix\((?:[-\d.]+,\s*){4}([-\d.]+),\s*([-\d.]+)\)$/;
	  var matched;
	
	  if (transform !== 'none') {
	    if (matched = transform.match(regMatrix3d) || transform.match(regMatrix)) {
	      offset.x = parseFloat(matched[1]) || 0;
	      offset.y = parseFloat(matched[2]) || 0;
	    }
	  }
	
	  return offset;
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix';
	var has3d = !!Firefox || CSSMatrix in window && 'm11' in new window[CSSMatrix]();
	function getTranslate(x, y) {
	  x = parseFloat(x);
	  y = parseFloat(y);
	
	  if (x != 0) {
	    x += 'px';
	  }
	
	  if (y != 0) {
	    y += 'px';
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)';
	  }
	
	  return 'translate(' + x + ', ' + y + ')';
	}
	
	var slice = Array.prototype.slice;
	function ArrayFrom(a) {
	  return slice.call(a);
	}
	
	var incId = 0;
	function Carrousel(element, options) {
	  var that = this;
	  var views = [];
	  var pages = {};
	  var id = Date.now() + '-' + ++incId;
	  var root = document.createDocumentFragment();
	
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0];
	    element = null;
	  }
	
	  if (!element) {
	    element = document.createElement('ul');
	    root.appendChild(element);
	  }
	  options = options || {};
	
	  element.setAttribute('data-ctrl-name', 'carrousel');
	  element.setAttribute('data-ctrl-id', id);
	
	  function fireEvent(name, extra) {
	    var ev = doc.createEvent('HTMLEvents');
	    ev.initEvent(name, false, false);
	    if (extra) {
	      for (var key in extra) {
	        ev[key] = extra[key];
	      }
	    }
	    root.dispatchEvent(ev);
	  }
	
	  element.style.position = 'relative';
	  element.style[stylePrefix + 'Transform'] = getTranslate(0, 0);
	
	  var transformOffset = 0;
	  var items = {};
	  var itemLength = 0;
	  var itemStep = options.step || element.getBoundingClientRect().width;
	  var itemIndex = 0;
	
	  items.add = function (html) {
	    var li = document.createElement('li');
	    li.style.display = 'none';
	    li.style.float = 'left';
	    li.index = itemLength;
	    if (typeof html === 'string') {
	      li.innerHTML = html;
	    } else if (html instanceof HTMLElement) {
	      li.appendChild(html);
	    }
	    element.appendChild(li);
	
	    Object.defineProperty(items, itemLength + '', {
	      get: function get() {
	        return li;
	      }
	    });
	
	    itemLength++;
	    return li;
	  };
	
	  function normalizeIndex(index) {
	    while (index < 0) {
	      index += itemLength;
	    }
	
	    while (index >= itemLength) {
	      index -= itemLength;
	    }
	
	    return index;
	  }
	
	  items.get = function (index) {
	    return items[normalizeIndex(index)];
	  };
	
	  items.getCloned = function (index) {
	    var index = normalizeIndex(index);
	    var item = element.querySelector('[cloned="cloned-' + index + '"]');
	    var originalItem = items[index];
	
	    // If there a _listeners attribute on the dom element
	    // then clone the _listeners as well for the events' binding
	    function cloneEvents(origin, clone, deep) {
	      var listeners = origin._listeners;
	      if (listeners) {
	        clone._listeners = listeners;
	        for (var type in listeners) {
	          clone.addEventListener(type, listeners[type]);
	        }
	      }
	      if (deep && origin.children && origin.children.length) {
	        for (var i = 0, l = origin.children.length; i < l; i++) {
	          cloneEvents(origin.children[i], clone.children[i], deep);
	        }
	      }
	    }
	
	    if (!item) {
	      item = originalItem.cloneNode(true);
	      cloneEvents(originalItem, item, true);
	
	      element.appendChild(item);
	      item.setAttribute('cloned', 'cloned-' + index);
	      item.index = index;
	    }
	
	    return item;
	  };
	
	  function activate(index) {
	    if (itemLength === 0) {
	      return;
	    }
	
	    var curItem = items.get(index);
	    var prevItem;
	    var nextItem;
	
	    if (itemLength > 1) {
	      prevItem = items.get(index - 1);
	
	      if (itemLength === 2) {
	        nextItem = items.getCloned(index + 1);
	      } else {
	        nextItem = items.get(index + 1);
	      }
	
	      curItem.style.left = -transformOffset + 'px';
	      prevItem.style.left = -transformOffset - itemStep + 'px';
	      nextItem.style.left = -transformOffset + itemStep + 'px';
	    }
	
	    itemIndex = curItem.index;
	
	    fireEvent('change', {
	      prevItem: prevItem,
	      curItem: curItem,
	      nextItem: nextItem
	    });
	  }
	
	  items.slide = function (index) {
	    if (itemLength === 0) {
	      return;
	    }
	
	    if (itemLength === 1) {
	      index = 0;
	    }
	
	    var startOffset = getTransformOffset(element).x;
	    var endOffset = transformOffset + itemStep * -index;
	    var interOffset = endOffset - startOffset;
	
	    if (interOffset === 0) {
	      return;
	    }
	
	    var anim = new lib.animation(400, lib.cubicbezier.ease, function (i1, i2) {
	      element.style[stylePrefix + 'Transform'] = getTranslate(startOffset + interOffset * i2, 0);
	    }).play().then(function () {
	      transformOffset = endOffset;
	      element.style[stylePrefix + 'Transform'] = getTranslate(endOffset, 0);
	      index && activate(itemIndex + index);
	    });
	  };
	
	  items.next = function () {
	    items.slide(1);
	  };
	
	  items.prev = function () {
	    items.slide(-1);
	  };
	
	  ArrayFrom(element.children).forEach(function (el) {
	    el.style.position = 'absolute';
	    el.style.top = '0';
	    el.style.left = itemLength * itemStep + 'px';
	    el.style.float = 'left';
	    el.index = itemLength;
	    Object.defineProperty(items, itemLength + '', {
	      get: function get() {
	        return el;
	      }
	    });
	
	    itemLength++;
	  });
	
	  Object.defineProperty(this, 'items', {
	    get: function get() {
	      return items;
	    }
	  });
	
	  Object.defineProperty(items, 'length', {
	    get: function get() {
	      return itemLength;
	    }
	  });
	
	  Object.defineProperty(items, 'index', {
	    get: function get() {
	      return itemIndex;
	    }
	  });
	
	  Object.defineProperty(items, 'step', {
	    get: function get() {
	      return itemStep;
	    },
	
	    set: function set(v) {
	      itemStep = v;
	    }
	  });
	
	  var starting = false;
	  var playing = false;
	  var isSliding = false;
	  this.play = function () {
	    if (!starting) {
	      starting = true;
	      return activate(0);
	    }
	
	    if (!!playing) {
	      return;
	    }
	
	    playing = setTimeout(function play() {
	      isSliding = true;
	      items.next();
	      setTimeout(function () {
	        isSliding = false;
	      }, 500);
	      playing = setTimeout(play, 400 + playInterval);
	    }, 400 + playInterval);
	  };
	
	  this.stop = function () {
	    if (!playing) {
	      return;
	    }
	    clearTimeout(playing);
	    setTimeout(function () {
	      playing = false;
	    }, 500);
	  };
	
	  var autoplay = false;
	  var readyToPlay = false;
	  Object.defineProperty(this, 'autoplay', {
	    get: function get() {
	      return autoplay;
	    },
	    set: function set(v) {
	      autoplay = !!v;
	      if (readyToPlay) {
	        clearTimeout(readyToPlay);
	        readyToPlay = false;
	      }
	      if (autoplay) {
	        readyToPlay = setTimeout(function () {
	          that.play();
	        }, 2000);
	      } else {
	        that.stop();
	      }
	    }
	  });
	  this.autoplay = !!options.autoplay;
	
	  var playInterval = 1500;
	  Object.defineProperty(this, 'playInterval', {
	    get: function get() {
	      return playInterval;
	    },
	    set: function set(n) {
	      playInterval = n;
	    }
	  });
	  this.playInterval = !!options.playInterval || 1500;
	
	  if (options.useGesture) {
	    var panning = false;
	    var displacement;
	    element.addEventListener('panstart', function (e) {
	      if (!e.isVertical && !(panning && isSliding)) {
	        e.preventDefault();
	        e.stopPropagation();
	
	        if (autoplay) {
	          that.stop();
	        }
	
	        displacement = 0;
	        panning = true;
	      }
	    });
	
	    element.addEventListener('panmove', function (e) {
	      if (!e.isVertical && panning) {
	        e.preventDefault();
	        e.stopPropagation();
	        displacement = e.displacementX;
	        element.style[stylePrefix + 'Transform'] = getTranslate(transformOffset + displacement, 0);
	      }
	    });
	
	    element.addEventListener('panend', function (e) {
	      if (!e.isVertical && panning) {
	        e.preventDefault();
	        e.stopPropagation();
	        panning = false;
	        if (e.isSwipe) {
	          if (displacement < 0) {
	            items.next();
	          } else {
	            items.prev();
	          }
	        } else {
	          if (Math.abs(displacement) < itemStep / 2) {
	            items.slide(0);
	          } else {
	            items.slide(displacement < 0 ? 1 : -1);
	          }
	        }
	
	        if (autoplay) {
	          setTimeout(function () {
	            that.play();
	          }, 2000);
	        }
	      }
	    }, false);
	
	    element.addEventListener('swipe', function (e) {
	      if (!e.isVertical) {
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    });
	  }
	
	  this.addEventListener = function (name, handler) {
	    this.root.addEventListener(name, handler, false);
	  };
	
	  this.removeEventListener = function (name, handler) {
	    this.root.removeEventListener(name, handler, false);
	  };
	
	  this.root = root;
	  this.element = element;
	}
	
	!lib && (lib = {});
	lib.carrousel = Carrousel;

/***/ },
/* 163 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a,b,c,d){function e(a){return(3*k*a+2*l)*a+m}function f(a){return((k*a+l)*a+m)*a}function g(a){return((n*a+o)*a+p)*a}function h(a){for(var b,c,d=a,g=0;8>g;g++){if(c=f(d)-a,Math.abs(c)<j)return d;if(b=e(d),Math.abs(b)<j)break;d-=c/b}var h=1,i=0;for(d=a;h>i;){if(c=f(d)-a,Math.abs(c)<j)return d;c>0?h=d:i=d,d=(h+i)/2}return d}function i(a){return g(h(a))}var j=1e-6,k=3*a-3*c+1,l=3*c-6*a,m=3*a,n=3*b-3*d+1,o=3*d-6*b,p=3*b;return i}b.cubicbezier=c,b.cubicbezier.linear=c(0,0,1,1),b.cubicbezier.ease=c(.25,.1,.25,1),b.cubicbezier.easeIn=c(.42,0,1,1),b.cubicbezier.easeOut=c(0,0,.58,1),b.cubicbezier.easeInOut=c(.42,0,.58,1)}(window,window.lib||(window.lib={}));;module.exports = window.lib['cubicbezier'];

/***/ },
/* 164 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){return setTimeout(a,l)}function d(a){clearTimeout(a)}function e(){var a={},b=new m(function(b,c){a.resolve=b,a.reject=c});return a.promise=b,a}function f(a,b){return["then","catch"].forEach(function(c){b[c]=function(){return a[c].apply(a,arguments)}}),b}function g(b){var c,d,h=!1;this.request=function(){h=!1;var g=arguments;return c=e(),f(c.promise,this),d=n(function(){h||c&&c.resolve(b.apply(a,g))}),this},this.cancel=function(){return d&&(h=!0,o(d),c&&c.reject("CANCEL")),this},this.clone=function(){return new g(b)}}function h(a,b){"function"==typeof b&&(b={0:b});for(var c=a/l,d=1/c,e=[],f=Object.keys(b).map(function(a){return parseInt(a)}),h=0;c>h;h++){var i=f[0],j=d*h;if(null!=i&&100*j>=i){var k=b[""+i];k instanceof g||(k=new g(k)),e.push(k),f.shift()}else e.length&&e.push(e[e.length-1].clone())}return e}function i(a){var c;return"string"==typeof a||a instanceof Array?b.cubicbezier?"string"==typeof a?b.cubicbezier[a]&&(c=b.cubicbezier[a]):a instanceof Array&&4===a.length&&(c=b.cubicbezier.apply(b.cubicbezier,a)):console.error("require lib.cubicbezier"):"function"==typeof a&&(c=a),c}function j(a,b,c){var d,g=h(a,c),j=1/(a/l),k=0,m=i(b);if(!m)throw new Error("unexcept timing function");var n=!1;this.play=function(){function a(){var c=j*(k+1).toFixed(10),e=g[k];e.request(c.toFixed(10),b(c).toFixed(10)).then(function(){n&&(k===g.length-1?(n=!1,d&&d.resolve("FINISH"),d=null):(k++,a()))},function(){})}if(!n)return n=!0,d||(d=e(),f(d.promise,this)),a(),this},this.stop=function(){return n?(n=!1,g[k]&&g[k].cancel(),this):void 0}}var k=60,l=1e3/k,m=a.Promise||b.promise&&b.promise.ES6Promise,n=window.requestAnimationFrame||window.msRequestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||c,o=window.cancelAnimationFrame||window.msCancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||d;(n===c||o===d)&&(n=c,o=d),b.animation=function(a,b,c){return new j(a,b,c)},b.animation.frame=function(a){return new g(a)},b.animation.requestFrame=function(a){var b=new g(a);return b.request()}}(window,window.lib||(window.lib={}));;module.exports = window.lib['animation'];

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./carrousel.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./carrousel.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "[data-ctrl-name=\"carrousel\"] {\n  position: relative;\n  -webkit-transform: translateZ(1px);\n  -ms-transform: translateZ(1px);\n  transform: translateZ(1px);\n}", ""]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	/* eslint-disable */
	
	'use strict';
	
	var _fallback = false;
	
	var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
	if (!raf) {
	  _fallback = true;
	  raf = function raf(callback) {
	    return setTimeout(callback, 16);
	  };
	}
	var caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
	if (!caf && _fallback) {
	  caf = function caf(id) {
	    return clearTimeout(id);
	  };
	} else if (!caf) {
	  caf = function caf() {};
	}
	
	var MAX = (Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1) - 1;
	
	var _idMap = {};
	var _globalId = 0;
	
	function _getGlobalId() {
	  _globalId = (_globalId + 1) % MAX;
	  if (_idMap[_globalId]) {
	    return _getGlobalId();
	  }
	  return _globalId;
	}
	
	var timer = {
	
	  setTimeout: function setTimeout(cb, ms) {
	    var id = _getGlobalId();
	    var start = Date.now();
	    _idMap[id] = raf(function loop() {
	      if (!_idMap[id] && _idMap[id] !== 0) {
	        return;
	      }
	      var ind = Date.now() - start;
	      if (ind < ms) {
	        _idMap[id] = raf(loop);
	      } else {
	        delete _idMap[id];
	        cb();
	      }
	    });
	    return id;
	  },
	
	  clearTimeout: function clearTimeout(id) {
	    var tid = _idMap[id];
	    tid && caf(tid);
	    delete _idMap[id];
	  }
	
	};
	
	module.exports = timer;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(169);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./slider.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./slider.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".slider {\n  position: relative;\n}\n\n.slider .indicator-container {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  font-size: 0;\n}\n.slider .indicator-container .indicator {\n  border-radius: 50%;\n}\n.slider .indicator-container.row {\n  -webkit-box-orient: horizontal;\n  box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.slider .indicator-container.column {\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(171);
	
	var DEFAULT_ITEM_COLOR = '#999';
	var DEFAULT_ITEM_SELECTED_COLOR = '#0000ff';
	var DEFAULT_ITEM_SIZE = 20;
	var DEFAULT_MARGIN_SIZE = 10;
	
	function resetColor(indicator) {
	  var len = indicator.items.length;
	  if (typeof indicator.index !== 'undefined' && len > indicator.index) {
	    for (var i = 0; i < len; i++) {
	      var item = indicator.items[i];
	      if (indicator.index === i) {
	        item.classList.add('active');
	        item.style.backgroundColor = indicator.itemSelectedColor;
	      } else {
	        item.style.backgroundColor = indicator.itemColor;
	      }
	    }
	  }
	}
	
	function handleClick(indicator, idx, e) {
	  indicator.slider.slideTo(idx);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-indicators');
	    node.classList.add('weex-element');
	    node.style.position = 'absolute';
	    this.node = node;
	    this.style.itemSize.call(this, 0);
	    this.updateStyle({
	      left: 0,
	      top: 0,
	      itemSize: 0
	    });
	    return node;
	  },
	  createChildren: function createChildren() {
	    var root = document.createDocumentFragment();
	    for (var i = 0; i < this.amount; i++) {
	      var indicator = document.createElement('div');
	      indicator.classList.add('weex-indicator');
	      indicator.style.boxSizing = 'border-box';
	      indicator.style.margin = '0 ' + DEFAULT_MARGIN_SIZE * this.data.scale + 'px';
	      indicator.style.width = this.itemSize + 'px';
	      indicator.style.height = this.itemSize + 'px';
	      indicator.setAttribute('index', i);
	      if (this.index === i) {
	        indicator.classList.add('active');
	        indicator.style.backgroundColor = this.itemSelectedColor;
	      } else {
	        indicator.style.backgroundColor = this.itemColor;
	      }
	      indicator.addEventListener('click', handleClick.bind(null, this, i));
	      this.items[i] = indicator;
	      root.appendChild(indicator);
	    }
	    this.node.appendChild(root);
	  },
	  setIndex: function setIndex(idx) {
	    if (idx >= this.amount) {
	      return;
	    }
	    var prev = this.items[this.index];
	    var cur = this.items[idx];
	    prev.classList.remove('active');
	    prev.style.backgroundColor = this.itemColor;
	    cur.classList.add('active');
	    cur.style.backgroundColor = this.itemSelectedColor;
	    this.index = idx;
	  }
	};
	
	var style = {
	  itemColor: function itemColor(val) {
	    this.itemColor = val || DEFAULT_ITEM_COLOR;
	    resetColor(this);
	  },
	  itemSelectedColor: function itemSelectedColor(val) {
	    this.itemSelectedColor = val || DEFAULT_ITEM_SELECTED_COLOR;
	    resetColor(this);
	  },
	  itemSize: function itemSize(val) {
	    val = parseInt(val) * this.data.scale || DEFAULT_ITEM_SIZE * this.data.scale;
	    this.itemSize = val;
	    this.node.style.height = val + 'px';
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.width = val + 'px';
	      this.items[i].style.height = val + 'px';
	    }
	  },
	  width: function width(val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderWidth);
	    this.virtualWrapperWidth = val;
	  },
	  height: function height(val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderHeight);
	    this.virtualWrapperHeight = val;
	  },
	  top: function top(val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2 + val * this.data.scale;
	    this.node.style.bottom = '';
	    this.node.style.top = val + 'px';
	  },
	  bottom: function bottom(val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2 + val * this.data.scale;
	    this.node.style.top = '';
	    this.node.style.bottom = val + 'px';
	  },
	  left: function left(val) {
	    val = this.virtualWrapperWidth / 2 - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale) * this.amount / 2 + val * this.data.scale;
	    this.node.style.right = '';
	    this.node.style.left = val + 'px';
	  },
	  right: function right(val) {
	    val = this.virtualWrapperWidth / 2 - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale) * this.amount / 2 + val * this.data.scale;
	    this.node.style.left = '';
	    this.node.style.right = val + 'px';
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // Style supported:
	  //   position: (default - absolute)
	  //   itemColor: color of indicator dots
	  //   itemSelectedColor: color of the selected indicator dot
	  //   itemSize: size of indicators
	  //   other layout styles
	  function Indicator(data) {
	    this.direction = 'row'; // 'column' is not temporarily supported.
	    this.amount = data.extra.amount;
	    this.index = data.extra.index;
	    this.sliderWidth = data.extra.width;
	    this.sliderHeight = data.extra.height;
	    var styles = data.style || {};
	    this.data = data;
	    this.style.width.call(this, styles.width);
	    this.style.height.call(this, styles.height);
	    this.itemColor = styles.itemColor || DEFAULT_ITEM_COLOR;
	    this.itemSelectedColor = styles.itemSelectedColor || DEFAULT_ITEM_SELECTED_COLOR;
	    this.items = [];
	    Atomic.call(this, data);
	  }
	  Indicator.prototype = Object.create(Atomic.prototype);
	  extend(Indicator.prototype, proto);
	  extend(Indicator.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('indicator', Indicator);
	}
	
	exports.default = { init: init };

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(172);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./indicator.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./indicator.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-indicators {\n  position: absolute;\n  white-space: nowrap;\n}\n.weex-indicators .weex-indicator {\n  float: left;\n  border-radius: 50%;\n}\n", ""]);
	
	// exports


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// TODO: refactor this scss code since this is strongly
	// dependent on lib.flexible other than the value of
	// scale.
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(174);
	
	function initFoldBtn(tabheader) {
	  var node = tabheader.node;
	  var btn = document.createElement('span');
	  btn.className = 'fold-toggle iconfont';
	  btn.innerHTML = '&#xe661;';
	  node.appendChild(btn);
	
	  btn.addEventListener('click', function () {
	    if (tabheader.unfolding) {
	      folding(tabheader);
	    } else {
	      unfolding(tabheader);
	    }
	  });
	}
	
	function initMask(tabheader) {
	  var mask = document.createElement('div');
	  mask.className = 'tabheader-mask';
	  tabheader.mask = mask;
	  // stop default behavior: page moving.
	  mask.addEventListener('touchmove', function (evt) {
	    evt.preventDefault();
	  });
	  // click to unfold.
	  mask.addEventListener('click', function () {
	    folding(tabheader);
	  });
	
	  document.body.appendChild(mask);
	}
	
	function unfolding(tabheader) {
	  // mark the initial posiiton of tabheader
	  if (!tabheader.flag) {
	    var flag = document.createComment('tabheader');
	    tabheader.flag = flag;
	    tabheader.node.parentNode.insertBefore(flag, tabheader.node);
	  }
	  if (!tabheader.mask) {
	    initMask(tabheader);
	  }
	
	  // record the scroll position.
	  tabheader._scrollVal = tabheader._body.scrollLeft;
	  // record the position in document.
	  tabheader._topVal = tabheader.node.getBoundingClientRect().top;
	  tabheader._styleTop = tabheader.node.style.top;
	
	  document.body.appendChild(tabheader.node);
	  tabheader.node.classList.add('unfold-header');
	  tabheader.node.style.height = 'auto';
	  // recalc the position when it is unfolded.
	  var thHeight = tabheader.node.getBoundingClientRect().height;
	  if (thHeight + tabheader._topVal > window.innerHeight) {
	    tabheader._topVal = tabheader._topVal + (window.innerHeight - thHeight - tabheader._topVal);
	  }
	
	  tabheader.node.style.top = tabheader._topVal + 'px';
	  // process mask style
	  tabheader.mask.classList.add('unfold-header');
	  tabheader.mask.style.height = window.innerHeight + 'px';
	  tabheader.unfolding = true;
	}
	
	function folding(tabheader) {
	  if (tabheader.unfolding !== true) {
	    return;
	  }
	
	  tabheader.mask.classList.remove('unfold-header');
	  tabheader.node.classList.remove('unfold-header');
	
	  tabheader.node.style.height = '';
	  tabheader.node.style.top = tabheader._styleTop;
	
	  // recover the position of tabheader.
	  tabheader.flag.parentNode.insertBefore(tabheader.node, tabheader.flag);
	  // recover the position of scoller.
	  tabheader._body.scrollLeft = tabheader._scrollVal;
	
	  scrollToView(tabheader);
	  tabheader.unfolding = false;
	}
	
	function initEvent(tabheader) {
	  initClickEvent(tabheader);
	  initSelectEvent(tabheader);
	}
	
	// init events.
	function initClickEvent(tabheader) {
	  var box = tabheader.box;
	
	  box.addEventListener('click', function (evt) {
	    var target = evt.target;
	    if (target.nodeName === 'UL') {
	      return;
	    }
	
	    if (target.parentNode.nodeName === 'LI') {
	      target = target.parentNode;
	    }
	
	    var floor = target.getAttribute('data-floor');
	    /* eslint-disable eqeqeq */
	    if (tabheader.data.attr.selectedIndex == floor) {
	      // Duplicated clicking, not to trigger select event.
	      return;
	    }
	    /* eslint-enable eqeqeq */
	
	    fireEvent(target, 'select', { index: floor });
	  });
	}
	
	function initSelectEvent(tabheader) {
	  var node = tabheader.node;
	  node.addEventListener('select', function (evt) {
	    var index = void 0;
	    if (evt.index !== undefined) {
	      index = evt.index;
	    } else if (evt.data && evt.data.index !== undefined) {
	      index = evt.data.index;
	    }
	
	    if (index === undefined) {
	      return;
	    }
	
	    tabheader.attr.selectedIndex.call(tabheader, index);
	  });
	}
	
	function scrollToView(tabheader, node) {
	  if (!node) {
	    var _attr = tabheader.data.attr;
	    node = tabheader.node.querySelector('[data-floor="' + _attr.selectedIndex + '"]');
	  }
	  if (!node) {
	    return;
	  }
	
	  // const defaultVal = tabheader._body.scrollLeft
	  // const leftVal = defaultVal - node.offsetLeft + 300
	
	  var scrollVal = getScrollVal(tabheader._body.getBoundingClientRect(), node);
	  doScroll(tabheader._body, scrollVal);
	}
	
	// scroll the tabheader.
	// positive val means to scroll right.
	// negative val means to scroll left.
	function doScroll(node, val, finish) {
	  if (!val) {
	    return;
	  }
	  if (finish === undefined) {
	    finish = Math.abs(val);
	  }
	
	  if (finish <= 0) {
	    return;
	  }
	
	  setTimeout(function () {
	    if (val > 0) {
	      node.scrollLeft += 2;
	    } else {
	      node.scrollLeft -= 2;
	    }
	    finish -= 2;
	
	    doScroll(node, val, finish);
	  });
	}
	
	// get scroll distance.
	function getScrollVal(rect, node) {
	  var left = node.previousSibling;
	  var right = node.nextSibling;
	  var scrollVal = void 0;
	
	  // process left-side element first.
	  if (left) {
	    var leftRect = left.getBoundingClientRect();
	    // only need to compare the value of left.
	    if (leftRect.left < rect.left) {
	      scrollVal = leftRect.left;
	      return scrollVal;
	    }
	  }
	
	  if (right) {
	    var rightRect = right.getBoundingClientRect();
	    // compare the value of right.
	    if (rightRect.right > rect.right) {
	      scrollVal = rightRect.right - rect.right;
	      return scrollVal;
	    }
	  }
	
	  // process current node, from left to right.
	  var nodeRect = node.getBoundingClientRect();
	  if (nodeRect.left < rect.left) {
	    scrollVal = nodeRect.left;
	  } else if (nodeRect.right > rect.right) {
	    scrollVal = nodeRect.right - rect.right;
	  }
	
	  return scrollVal;
	}
	
	// trigger and broadcast events.
	function fireEvent(element, type, data) {
	  var evt = document.createEvent('Event');
	  evt.data = data;
	  for (var k in data) {
	    if (data.hasOwnProperty(k)) {
	      evt[k] = data[k];
	    }
	  }
	  // need bubble.
	  evt.initEvent(type, true, true);
	
	  element.dispatchEvent(evt);
	}
	
	function createHighlightIcon(code) {
	  var html = '<i class="hl-icon iconfont">' + '&#xe650' + '</i>';
	  return html;
	}
	
	function isValidColor(color) {
	  if (!color) {
	    return false;
	  }
	
	  if (color.charAt(0) !== '#') {
	    return false;
	  }
	
	  if (color.length !== 7) {
	    return false;
	  }
	
	  return true;
	}
	
	var proto = {
	  create: function create() {
	    // outside container.
	    var node = document.createElement('div');
	    node.className = 'tab-header';
	    // tip on the top.
	    var bar = document.createElement('div');
	    bar.className = 'header-bar';
	    bar.textContent = 'CHANGE FLOOR';
	    // middle layer.
	    var body = document.createElement('div');
	    body.className = 'header-body';
	    var box = document.createElement('ul');
	    box.className = 'tabheader';
	
	    body.appendChild(box);
	    node.appendChild(bar);
	    node.appendChild(body);
	    this._bar = bar;
	    this._body = body;
	    this.box = box;
	    this.node = node;
	    // init events.
	    initFoldBtn(this);
	    initEvent(this);
	    return node;
	  }
	};
	
	var attr = {
	  highlightIcon: function highlightIcon() {
	    return createHighlightIcon();
	  },
	  data: function data() {
	    var attr = this.data.attr;
	    // Ensure there is a default selected value.
	    if (attr.selectedIndex === undefined) {
	      attr.selectedIndex = 0;
	    }
	
	    var list = attr.data || [];
	    var curItem = attr.selectedIndex;
	
	    var ret = [];
	    var itemTmpl = '<li class="th-item" data-floor="{{floor}}">' + '{{hlIcon}}{{floorName}}</li>';
	
	    list.forEach(function (item, idx) {
	      var html = itemTmpl.replace('{{floor}}', idx);
	      /* eslint-disable eqeqeq */
	      if (curItem == idx) {
	        html = html.replace('{{hlIcon}}', createHighlightIcon());
	      } else {
	        html = html.replace('{{hlIcon}}', '');
	      }
	      /* eslint-enable eqeqeq */
	
	      html = html.replace('{{floorName}}', item);
	
	      ret.push(html);
	    }, this);
	
	    this.box.innerHTML = ret.join('');
	  },
	  selectedIndex: function selectedIndex(val) {
	    var attr = this.data.attr;
	
	    if (val === undefined) {
	      val = 0;
	    }
	
	    // if (val == attr.selectedIndex) {
	    //   return
	    // }
	
	    attr.selectedIndex = val;
	
	    this.attr.data.call(this);
	
	    folding(this);
	    this.style.textHighlightColor.call(this, this.textHighlightColor);
	  }
	};
	
	var style = {
	  opacity: function opacity(val) {
	    if (val === undefined || val < 0 || val > 1) {
	      val = 1;
	    }
	
	    this.node.style.opacity = val;
	  },
	  textColor: function textColor(val) {
	    if (!isValidColor(val)) {
	      return;
	    }
	
	    this.node.style.color = val;
	  },
	  textHighlightColor: function textHighlightColor(val) {
	    if (!isValidColor(val)) {
	      return;
	    }
	    this.textHighlightColor = val;
	    var attr = this.data.attr;
	
	    var node = this.node.querySelector('[data-floor="' + attr.selectedIndex + '"]');
	    if (node) {
	      node.style.color = val;
	      scrollToView(this, node);
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  function TabHeader(data) {
	    Atomic.call(this, data);
	  }
	  TabHeader.prototype = Object.create(Atomic.prototype);
	  extend(TabHeader.prototype, proto);
	  extend(TabHeader.prototype, { attr: attr });
	  extend(TabHeader.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('tabHeader', TabHeader);
	}
	
	exports.default = { init: init };

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(175);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./tabheader.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./tabheader.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".tab-header {\n  position: relative;\n  width: 10rem;\n  font-size: 14px;\n  color: #333;\n}\n.tab-header .header-bar {\n  height: 1.17rem;\n  line-height: 1.17rem;\n  display: none;\n  color: #999;\n  padding-left: 0.4rem;\n}\n.tab-header .header-body {\n  margin-right: 1.07rem;\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.tab-header .header-body::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  overflow: hidden;\n}\n.tab-header .fold-toggle {\n  position: absolute;\n  top: 0.59rem;\n  -webkit-transform: translateY(-50%);\n  right: 0.29rem;\n  width: 0.48rem;\n  height: 0.48rem;\n  line-height: 0.48rem;\n  text-align: center;\n  z-index: 99;\n  font-size: 14px;\n}\n.tab-header.unfold-header {\n  position: fixed !important;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.tabheader {\n  list-style: none;\n  white-space: nowrap;\n  height: 1.17rem;\n  line-height: 1.17rem;\n}\n.tabheader .th-item {\n  padding-left: 0.72rem;\n  position: relative;\n  display: inline-block;\n}\n.tabheader .hl-icon {\n  width: 0.4rem;\n  height: 0.4rem;\n  line-height: 0.4rem;\n  text-align: center;\n  position: absolute;\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  left: 0.24rem;\n  font-size: 14px;\n}\n\n.unfold-header .header-bar {\n  display: block;\n}\n.unfold-header .fold-toggle {\n  -webkit-transform: translateY(-50%) rotate(180deg);\n}\n.unfold-header .header-body {\n  margin-right: 0;\n  padding: 0.24rem;\n}\n.unfold-header .tabheader {\n  display: block;\n  height: auto;\n}\n.unfold-header .th-item {\n  box-sizing: border-box;\n  float: left;\n  width: 33.3333%;\n  height: 1.01rem;\n  line-height: 1.01rem;\n}\n.unfold-header .hl-icon {\n  margin-right: 0;\n  position: absolute;\n}\n.unfold-header.tabheader-mask {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n\n.tabheader-mask {\n  display: none;\n  position: fixed;\n  left: 0;\n  top: 0;\n}\n\n@font-face {\n  font-family: \"iconfont\";\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,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R7AEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmGwAiVGYTgjIDwjOBshICBGI0ewACsjYTghWbEkARQrLbA7LLAuKy6xJAEUKy2wPCywLyshIyAgPLAEI0IjOLEkARQrsARDLrAkKy2wPSywABUgR7AAI0KyAAEBFRQTLrAqKi2wPiywABUgR7AAI0KyAAEBFRQTLrAqKi2wPyyxAAEUE7ArKi2wQCywLSotsEEssAAWRSMgLiBGiiNhOLEkARQrLbBCLLAJI0KwQSstsEMssgAAOistsEQssgABOistsEUssgEAOistsEYssgEBOistsEcssgAAOystsEgssgABOystsEkssgEAOystsEossgEBOystsEsssgAANystsEwssgABNystsE0ssgEANystsE4ssgEBNystsE8ssgAAOSstsFAssgABOSstsFEssgEAOSstsFIssgEBOSstsFMssgAAPCstsFQssgABPCstsFUssgEAPCstsFYssgEBPCstsFcssgAAOCstsFgssgABOCstsFkssgEAOCstsFossgEBOCstsFsssDArLrEkARQrLbBcLLAwK7A0Ky2wXSywMCuwNSstsF4ssAAWsDArsDYrLbBfLLAxKy6xJAEUKy2wYCywMSuwNCstsGEssDErsDUrLbBiLLAxK7A2Ky2wYyywMisusSQBFCstsGQssDIrsDQrLbBlLLAyK7A1Ky2wZiywMiuwNistsGcssDMrLrEkARQrLbBoLLAzK7A0Ky2waSywMyuwNSstsGossDMrsDYrLbBrLCuwCGWwAyRQeLABFTAtAABLuADIUlixAQGOWbkIAAgAYyCwASNEILADI3CwDkUgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbABRWMjYrACI0SzCgkFBCuzCgsFBCuzDg8FBCtZsgQoCUVSRLMKDQYEK7EGAUSxJAGIUViwQIhYsQYDRLEmAYhRWLgEAIhYsQYBRFlZWVm4Af+FsASNsQUARAAAAA==\") format(\"truetype\");\n}\n.iconfont {\n  font-family: iconfont !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n[data-dpr=\"2\"] .tab-header {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tabheader .hl-icon {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tabheader .hl-icon {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tab-header .fold-toggle {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header .fold-toggle {\n  font-size: 42px;\n}\n", ""]);
	
	// exports


/***/ },
/* 176 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var appendStyle = void 0;
	
	var availableTypes = ['text', 'password', 'tel', 'email', 'url'];
	var DEFAULT_TYPE = 'text';
	
	function setPlaceholderColor(input, placeholderColor) {
	  if (!placeholderColor) {
	    return;
	  }
	  var vendors = ['::-webkit-input-placeholder', ':-moz-placeholder', '::-moz-placeholder', ':-ms-input-placeholder', ':placeholder-shown'];
	  var css = '';
	  var cssRule = 'color: ' + placeholderColor + ';';
	  for (var i = 0, l = vendors.length; i < l; i++) {
	    css += '.' + input.className + vendors[i] + '{' + cssRule + '}';
	  }
	  appendStyle(css, input.styleId, true);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('input');
	    var uuid = Math.floor(10000000000000 * Math.random()) + Date.now();
	    this.className = 'weex-ipt-' + uuid;
	    this.styleId = 'weex-style-' + uuid;
	    node.classList.add(this.className);
	    node.classList.add('weex-element');
	    this.placeholder && (node.placeholder = this.placeholder);
	    return node;
	  }
	};
	
	// updatable attributes
	var attr = {
	  disabled: function disabled(val) {
	    this.node.disabled = !!val;
	  },
	  placeholder: function placeholder(val) {
	    this.node.placeholder = val || '';
	  },
	  value: function value(val) {
	    this.node.value = val || '';
	  },
	  autofocus: function autofocus(val) {
	    this.node.autofocus = !!val;
	  },
	  type: function type(val) {
	    this.node.type = availableTypes.indexOf(val) !== -1 ? val : DEFAULT_TYPE;
	  }
	};
	
	// updatable styles
	var style = {
	  placeholderColor: function placeholderColor(val) {
	    setPlaceholderColor(this, val);
	  }
	};
	
	// events configurations
	var event = {
	  input: {
	    updator: function updator() {
	      return {
	        attrs: {
	          value: this.node.value
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.node.value,
	        timestamp: Date.now()
	      };
	    }
	  },
	
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          value: this.node.value
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.node.value,
	        timestamp: Date.now()
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  appendStyle = Weex.utils.appendStyle;
	
	  // attrs:
	  //   - type: text|password|tel|email|url
	  //   - value
	  //   - placeholder
	  //   - disabled
	  //   - autofocus
	  function Input(data) {
	    Atomic.call(this, data);
	  }
	  Input.prototype = Object.create(Atomic.prototype);
	  extend(Input.prototype, proto);
	  extend(Input.prototype, { attr: attr });
	  extend(Input.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	  extend(Input.prototype, { event: event });
	
	  Weex.registerComponent('input', Input);
	}
	
	exports.default = { init: init };

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(178);
	
	function getProto(Weex) {
	  var Atomic = Weex.Atomic;
	  return {
	    create: function create() {
	      var node = document.createElement('video');
	      node.classList.add('weex-video', 'weex-element');
	      node.controls = true;
	      node.autoplay = this.autoPlay;
	      node.setAttribute('play-status', this.playStatus);
	      this.node = node;
	      if (this.autoPlay && this.playStatus === 'play') {
	        this.play();
	      }
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      Atomic.prototype.bindEvents.call(this, evts);
	
	      // convert w3c-video events to weex-video events.
	      var evtsMap = {
	        start: 'play',
	        finish: 'ended',
	        fail: 'error'
	      };
	      for (var evtName in evtsMap) {
	        this.node.addEventListener(evtsMap[evtName], function (type, e) {
	          this.dispatchEvent(type, e.data);
	        }.bind(this, evtName));
	      }
	    },
	    play: function play() {
	      var src = this.node.getAttribute('src');
	      if (!src) {
	        src = this.node.getAttribute('data-src');
	        src && this.node.setAttribute('src', src);
	      }
	      this.node.play();
	    },
	    pause: function pause() {
	      this.node.pause();
	    },
	    stop: function stop() {
	      this.node.pause();
	      this.node.autoplay = false;
	      this.node.setAttribute('data-src', this.node.src);
	      this.node.src = '';
	    }
	  };
	}
	
	var attr = {
	  playStatus: function playStatus(val) {
	    if (val !== 'play' && val !== 'stop' && val !== 'pause') {
	      val = 'pause';
	    }
	    if (this.playStatus === val) {
	      return;
	    }
	    this.playStatus = val;
	    this.node.setAttribute('play-status', val);
	    this[this.playStatus]();
	  },
	  autoPlay: function autoPlay(val) {
	    // DO NOTHING
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - autoPlay: true | false (default: false)
	  //   - playStatus: play | pause | stop
	  //   - src: {string}
	  //   - poster: {string}
	  //   - loop: true | false (default: false)
	  //   - muted: true | false (default: false)
	  // events:
	  //   - start
	  //   - pause
	  //   - finish
	  //   - fail
	  function Video(data) {
	    var autoPlay = data.attr.autoPlay;
	    var playStatus = data.attr.playStatus;
	    this.autoPlay = autoPlay === true || autoPlay === 'true';
	    if (playStatus !== 'play' && playStatus !== 'stop' && playStatus !== 'pause') {
	      this.playStatus = 'pause';
	    } else {
	      this.playStatus = playStatus;
	    }
	    Atomic.call(this, data);
	  }
	  Video.prototype = Object.create(Atomic.prototype);
	  extend(Video.prototype, getProto(Weex));
	  extend(Video.prototype, { attr: attr });
	
	  Weex.registerComponent('video', Video);
	}
	
	exports.default = { init: init };

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(179);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./video.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./video.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-video {\n\tbackground-color: #000;\n}", ""]);
	
	// exports


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(181);
	
	var defaults = {
	  color: '#64bd63',
	  secondaryColor: '#dfdfdf',
	  jackColor: '#fff',
	  jackSecondaryColor: null,
	  className: 'weex-switch',
	  disabledOpacity: 0.5,
	  speed: '0.4s',
	  width: 100,
	  height: 60,
	  // is width and height scalable ?
	  scalable: false
	};
	
	function transitionize(element, props) {
	  var transitions = [];
	  for (var key in props) {
	    transitions.push(key + ' ' + props[key]);
	  }
	  element.style.transition = transitions.join(', ');
	  element.style.webkitTransition = transitions.join(', ');
	}
	
	function setSize(comp) {
	  var min = Math.min(comp.width, comp.height);
	  var max = Math.max(comp.width, comp.height);
	  comp.node.style.width = max + 'px';
	  comp.node.style.height = min + 'px';
	  comp.node.style.borderRadius = min / 2 + 'px';
	  comp.jack.style.width = comp.jack.style.height = min + 'px';
	}
	
	function setPosition(comp, clicked) {
	  var checked = comp.checked;
	  var node = comp.node;
	  var jack = comp.jack;
	
	  if (clicked && checked) {
	    checked = false;
	  } else if (clicked && !checked) {
	    checked = true;
	  }
	
	  if (checked === true) {
	    comp.checked = true;
	
	    if (window.getComputedStyle) {
	      jack.style.left = parseInt(window.getComputedStyle(node).width) - parseInt(window.getComputedStyle(jack).width) + 'px';
	    } else {
	      jack.style.left = parseInt(node.currentStyle['width']) - parseInt(jack.currentStyle['width']) + 'px';
	    }
	
	    comp.options.color && colorize(comp);
	    setSpeed(comp);
	  } else {
	    comp.checked = false;
	    jack.style.left = 0;
	    node.style.boxShadow = 'inset 0 0 0 0 ' + comp.options.secondaryColor;
	    node.style.borderColor = comp.options.secondaryColor;
	    node.style.backgroundColor = comp.options.secondaryColor !== defaults.secondaryColor ? comp.options.secondaryColor : '#fff';
	    jack.style.backgroundColor = comp.options.jackSecondaryColor !== comp.options.jackColor ? comp.options.jackSecondaryColor : comp.options.jackColor;
	    setSpeed(comp);
	  }
	}
	
	function setSpeed(comp) {
	  var switcherProp = {};
	  var jackProp = {
	    'background-color': comp.options.speed,
	    left: comp.options.speed.replace(/[a-z]/, '') / 2 + 's'
	  };
	
	  if (comp.checked) {
	    switcherProp = {
	      border: comp.options.speed,
	      'box-shadow': comp.options.speed,
	      'background-color': comp.options.speed.replace(/[a-z]/, '') * 3 + 's'
	    };
	  } else {
	    switcherProp = {
	      border: comp.options.speed,
	      'box-shadow': comp.options.speed
	    };
	  }
	
	  transitionize(comp.node, switcherProp);
	  transitionize(comp.jack, jackProp);
	}
	
	function colorize(comp) {
	  var nodeHeight = comp.node.offsetHeight / 2;
	
	  comp.node.style.backgroundColor = comp.options.color;
	  comp.node.style.borderColor = comp.options.color;
	  comp.node.style.boxShadow = 'inset 0 0 0 ' + nodeHeight + 'px ' + comp.options.color;
	  comp.jack.style.backgroundColor = comp.options.jackColor;
	}
	
	function getClickHandler(comp) {
	  if (!comp._clickHandler) {
	    comp._clickHandler = function () {
	      setPosition(comp, true);
	      comp.dispatchEvent('change', {
	        value: comp.checked
	      });
	    };
	  }
	  return comp._clickHandler;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('span');
	    this.jack = document.createElement('small');
	    node.appendChild(this.jack);
	    node.className = this.options.className;
	    this.node = node;
	    this.attr.disabled.call(this, this.data.attr.disabled);
	    return node;
	  },
	  onAppend: function onAppend() {
	    setSize(this);
	    setPosition(this);
	  },
	  enable: function enable() {
	    this.disabled && (this.disabled = false);
	    this.node.style.opacity = 1;
	    this.node.addEventListener('click', getClickHandler(this));
	  },
	  disable: function disable() {
	    !this.disabled && (this.disabled = true);
	    this.node.style.opacity = defaults.disabledOpacity;
	    this.node.removeEventListener('click', getClickHandler(this));
	  }
	};
	
	var attr = {
	  disabled: function disabled(val) {
	    this.disabled = val && val !== 'false';
	    this.disabled ? this.disable() : this.enable();
	  }
	};
	
	var style = {
	  width: function width(val) {
	    if (!this.options.scalable) {
	      return;
	    }
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      val = this.options.width;
	    }
	    this.width = val * this.data.scale;
	    this.setSize();
	  },
	
	  height: function height(val) {
	    if (!this.options.scalable) {
	      return;
	    }
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      val = this.options.height;
	    }
	    this.height = val * this.data.scale;
	    this.setSize();
	  }
	};
	
	var event = {
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          checked: this.checked
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.checked
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - checked: if is checked.
	  //   - disabled: if true, this component is not available for interaction.
	  function Switch(data) {
	    this.options = extend({}, defaults);
	    this.checked = data.attr.checked && data.attr.checked !== 'false';
	    this.data = data;
	    this.width = this.options.width * data.scale;
	    this.height = this.options.height * data.scale;
	    Atomic.call(this, data);
	  }
	  Switch.prototype = Object.create(Atomic.prototype);
	  extend(Switch.prototype, proto);
	  extend(Switch.prototype, { attr: attr });
	  extend(Switch.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	  extend(Switch.prototype, { event: event });
	
	  Weex.registerComponent('switch', Switch);
	}
	
	exports.default = { init: init };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(182);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./switch.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./switch.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "/* switch defaults. */\n.weex-switch {\n  background-color: #fff;\n  border: 1px solid #dfdfdf;\n  cursor: pointer;\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  box-sizing: content-box;\n  background-clip: content-box;\n}\n\n.weex-switch > small {\n  background: #fff;\n  border-radius: 100%;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n  position: absolute;\n  top: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 183 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function getProto(Weex) {
	  var Component = Weex.Component;
	  return {
	    create: function create() {
	      var node = document.createElement('a');
	      node.classList.add('weex-container');
	      node.style.textDecoration = 'none';
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      // event handler for click event will be processed
	      // before the url redirection.
	      Component.prototype.bindEvents.call(this, evts);
	      this.node.addEventListener('click', function (evt) {
	        if (evt._alreadyFired && evt.target !== this.node) {
	          // if the event target is this.node, then this is
	          // just another click event handler for the same
	          // target, not a handler for a bubbling up event,
	          // otherwise it is a bubbling up event, and it
	          // should be disregarded.
	          return;
	        }
	        evt._alreadyFired = true;
	        location.href = this.href;
	      }.bind(this));
	    }
	  };
	}
	
	var attr = {
	  href: function href(val) {
	    if (!val) {
	      return console.warn('[web-render] href of <a> should not be a null value.');
	    }
	    this.href = val;
	    this.node.setAttribute('data-href', val);
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - href
	  function A(data) {
	    Component.call(this, data);
	  }
	
	  A.prototype = Object.create(Component.prototype);
	  extend(A.prototype, getProto(Weex));
	  extend(A.prototype, { attr: attr });
	
	  Weex.registerComponent('a', A);
	}
	
	exports.default = { init: init };

/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ID_PREFIX = 'weex_embed_';
	
	var getRandom = void 0;
	
	function _generateId() {
	  return ID_PREFIX + getRandom(10);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.id = this.id;
	    node.style.overflow = 'scroll';
	    return node;
	  },
	  initWeex: function initWeex() {
	    this.id = _generateId();
	    this.node.id = this.id;
	    var config = {
	      appId: this.id,
	      source: this.source,
	      bundleUrl: this.source,
	      loader: this.loader,
	      jsonpCallback: this.jsonpCallback,
	      width: this.node.getBoundingClientRect().width,
	      rootId: this.id,
	      embed: true
	    };
	    window.weex.init(config);
	  },
	  destroyWeex: function destroyWeex() {
	    this.id && window.destroyInstance(this.id);
	    // TODO: unbind events and clear doms.
	    this.node.innerHTML = '';
	  },
	  reloadWeex: function reloadWeex() {
	    if (this.id) {
	      this.destroyWeex();
	      this.id = null;
	      this.node.id = null;
	      this.node.innerHTML = '';
	    }
	    this.initWeex();
	  }
	};
	
	// not recommended, because of the leak of memory.
	var attr = {
	  src: function src(value) {
	    this.source = value;
	    this.reloadWeex();
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	  getRandom = Weex.utils.getRandom;
	
	  function Embed(data, nodeType) {
	    var attr = data.attr;
	    if (attr) {
	      this.source = attr.src;
	      this.loader = attr.loader || 'xhr';
	      this.jsonpCallback = attr.jsonpCallback;
	    }
	    Component.call(this, data, nodeType);
	  }
	
	  Embed.prototype = Object.create(Component.prototype);
	  extend(Embed.prototype, proto);
	  extend(Embed.prototype, { attr: attr });
	
	  Weex.registerComponent('embed', Embed);
	}
	
	exports.default = { init: init };

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* global CSSRule */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(186);
	
	var loopArray = void 0,
	    getRgb = void 0;
	
	function getStyleSheet(spinner) {
	  if (spinner.styleSheet) {
	    return;
	  }
	  var styles = document.styleSheets;
	  var i = void 0,
	      l = void 0,
	      j = void 0,
	      m = void 0;
	  /* eslint-disable no-labels */
	  outer: for (i = 0, l = styles.length; i < l; i++) {
	    var rules = styles[i].rules;
	    for (j = 0, m = rules.length; j < m; j++) {
	      var item = rules.item(j);
	      if ((item.type === CSSRule.KEYFRAMES_RULE || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE) && item.name === 'spinner') {
	        break outer;
	      }
	    }
	  }
	  /* eslint-enable no-labels */
	  spinner.styleSheet = styles[i];
	}
	
	function setKeyframeColor(spinner, val) {
	  getStyleSheet(spinner);
	  var keyframeRules = computeKeyFrameRules(val);
	  var rules = spinner.styleSheet.rules;
	  for (var i = 0, l = rules.length; i < l; i++) {
	    var item = rules.item(i);
	    if ((item.type === CSSRule.KEYFRAMES_RULE || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE) && item.name === 'spinner') {
	      var cssRules = item.cssRules;
	      for (var j = 0, m = cssRules.length; j < m; j++) {
	        var keyframe = cssRules[j];
	        if (keyframe.type === CSSRule.KEYFRAME_RULE || keyframe.type === CSSRule.WEBKIT_KEYFRAME_RULE) {
	          keyframe.style.boxShadow = keyframeRules[j];
	        }
	      }
	    }
	  }
	}
	
	function computeKeyFrameRules(rgb) {
	  if (!rgb) {
	    return;
	  }
	  var scaleArr = ['0em -2.6em 0em 0em', '1.8em -1.8em 0 0em', '2.5em 0em 0 0em', '1.75em 1.75em 0 0em', '0em 2.5em 0 0em', '-1.8em 1.8em 0 0em', '-2.6em 0em 0 0em', '-1.8em -1.8em 0 0em'];
	  var colorArr = ['1', '0.2', '0.2', '0.2', '0.2', '0.2', '0.5', '0.7'].map(function (e) {
	    return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + e + ')';
	  });
	  var rules = [];
	
	  var _loop = function _loop(i) {
	    var tmpColorArr = loopArray(colorArr, i, 'r');
	    rules.push(scaleArr.map(function (scaleStr, i) {
	      return scaleStr + ' ' + tmpColorArr[i];
	    }).join(', '));
	  };
	
	  for (var i = 0; i < scaleArr.length; i++) {
	    _loop(i);
	  }
	  return rules;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-spinner-wrap');
	    this.spinner = document.createElement('div');
	    this.spinner.classList.add('weex-element', 'weex-spinner');
	    node.appendChild(this.spinner);
	    return node;
	  }
	};
	
	var style = {
	  color: function color(val) {
	    var rgb = getRgb(val);
	    if (!rgb) {
	      return console.error('[web-render] invalid color value:', val);
	    }
	    setKeyframeColor(this, rgb);
	  }
	};
	
	// Spinner.prototype.updateStyle = function (style) {
	//   Atomic.prototype.updateStyle.call(this, style)
	//   if (style && style.color) {
	//     this.setKeyframeColor(global.weex.utils.getRgb(this.node.style.color))
	//   }
	// }
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  getRgb = Weex.utils.getRgb;
	  loopArray = Weex.utils.loopArray;
	
	  function Spinner(data) {
	    Atomic.call(this, data);
	  }
	  Spinner.prototype = Object.create(Atomic.prototype);
	  extend(Spinner.prototype, proto);
	  extend(Spinner.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('spinner', Spinner);
	  Weex.registerComponent('loading-indicator', Spinner);
	}
	
	exports.default = { init: init };

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(187);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./spinner.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./spinner.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-spinner-wrap {\n  width: 1.013333rem; /* 76px */\n  height: 1.013333rem;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  overflow: visible;\n}\n\n.weex-spinner {\n  font-size: 0.16rem; /* 12px */\n  width: 1em;\n  height: 1em;\n  border-radius: 50%;\n  position: relative;\n  text-indent: -9999em;\n  -webkit-animation: spinner 1.1s infinite ease;\n  animation: spinner 1.1s infinite ease;\n  -webkit-transform: translateZ(0);\n  -ms-transform: translateZ(0);\n  transform: translateZ(0);\n}\n@-webkit-keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n@keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n", ""]);
	
	// exports


/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isArray = void 0;
	
	function handleMsg(web, evt) {
	  var msg = evt.data;
	  if (typeof msg === 'string') {
	    try {
	      msg = JSON.parse(msg);
	    } catch (e) {}
	  }
	  if (!msg) {
	    return;
	  }
	  if (msg.type === 'weex') {
	    if (!isArray(msg.content)) {
	      return console.error('[h5-render] weex msg received by web component.' + ' msg.content should be a array:', msg.content);
	    }
	    callNative(web.getComponentManager().instanceId, msg.content);
	  }
	}
	
	function getProto(Weex) {
	  var Atomic = Weex.Atomic;
	  return {
	    create: function create() {
	      // Iframe's defect: can't use position:absolute and top, left, right,
	      // bottom all setting to zero and use margin to leave specified
	      // height for a blank area, and have to use 100% to fill the parent
	      // container, otherwise it will use a unwanted default size instead.
	      // Therefore a div as a iframe wrapper is needed here.
	      var node = document.createElement('div');
	      node.classList.add('weex-container');
	      this.web = document.createElement('iframe');
	      node.appendChild(this.web);
	      this.web.classList.add('weex-element');
	      this.web.style.width = '100%';
	      this.web.style.height = '100%';
	      this.web.style.border = 'none';
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      Atomic.prototype.bindEvents.call(this, evts);
	      var that = this;
	      this.web.addEventListener('load', function (e) {
	        that.dispatchEvent('pagefinish', {
	          url: that.web.src
	        });
	      });
	      window.addEventListener('message', handleMsg.bind(null, this));
	    },
	    goBack: function goBack() {
	      this.web.contentWindow.history.back();
	    },
	    goForward: function goForward() {
	      this.web.contentWindow.history.forward();
	    },
	    reload: function reload() {
	      this.web.contentWindow.location.reload();
	    }
	  };
	}
	
	var attr = {
	  src: function src(val) {
	    this.web.src = val;
	    setTimeout(function () {
	      this.dispatchEvent('pagestart', { url: val });
	    }.bind(this), 0);
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  isArray = Weex.utils.isArray;
	
	  // A component to import web pages, which works like
	  // a iframe element or a webview.
	  // attrs:
	  //   - src
	  // events:
	  //   - pagestart
	  //   - pagefinish
	  //   - error
	  function Web(data) {
	    Atomic.call(this, data);
	  }
	  Web.prototype = Object.create(Atomic.prototype);
	  extend(Web.prototype, getProto(Weex));
	  extend(Web.prototype, { attr: attr });
	
	  Weex.registerComponent('web', Web);
	}
	
	exports.default = { init: init };

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _dom = __webpack_require__(190);
	
	var _dom2 = _interopRequireDefault(_dom);
	
	var _event = __webpack_require__(198);
	
	var _event2 = _interopRequireDefault(_event);
	
	var _pageInfo = __webpack_require__(199);
	
	var _pageInfo2 = _interopRequireDefault(_pageInfo);
	
	var _stream = __webpack_require__(200);
	
	var _stream2 = _interopRequireDefault(_stream);
	
	var _modal = __webpack_require__(201);
	
	var _modal2 = _interopRequireDefault(_modal);
	
	var _animation = __webpack_require__(218);
	
	var _animation2 = _interopRequireDefault(_animation);
	
	var _webview = __webpack_require__(220);
	
	var _webview2 = _interopRequireDefault(_webview);
	
	var _navigator = __webpack_require__(221);
	
	var _navigator2 = _interopRequireDefault(_navigator);
	
	var _storage = __webpack_require__(222);
	
	var _storage2 = _interopRequireDefault(_storage);
	
	var _clipboard = __webpack_require__(223);
	
	var _clipboard2 = _interopRequireDefault(_clipboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_dom2.default);
	    Weex.install(_event2.default);
	    Weex.install(_pageInfo2.default);
	    Weex.install(_stream2.default);
	    Weex.install(_modal2.default);
	    Weex.install(_animation2.default);
	    Weex.install(_webview2.default);
	    // Weex.install(timer)
	    Weex.install(_navigator2.default);
	    Weex.install(_storage2.default);
	    Weex.install(_clipboard2.default);
	  }
	};
	// import timer from './timer'

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _scrollTo = __webpack_require__(191);
	
	var _scrollTo2 = _interopRequireDefault(_scrollTo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var dom = {
	  /**
	   * scrollToElement
	   * @param  {string} ref
	   * @param  {obj} options {offset:Number}
	   *   ps: scroll-to has 'ease' and 'duration'(ms) as options.
	   */
	  scrollToElement: function scrollToElement(ref, options) {
	    !options && (options = {});
	    var offset = (Number(options.offset) || 0) * this.scale;
	    var elem = this.getComponentManager().getComponent(ref);
	    if (!elem) {
	      return console.error('[h5-render] component of ref ' + ref + ' doesn\'t exist.');
	    }
	    var parentScroller = elem.getParentScroller();
	    if (parentScroller) {
	      parentScroller.scroller.scrollToElement(elem.node, true, offset);
	    } else {
	      var offsetTop = elem.node.getBoundingClientRect().top + document.body.scrollTop;
	      var tween = (0, _scrollTo2.default)(0, offsetTop + offset, options);
	      tween.on('end', function () {
	        console.log('scroll end.');
	      });
	    }
	  }
	};
	
	var meta = {
	  dom: [{
	    name: 'scrollToElement',
	    args: ['string', 'object']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('dom', dom, meta);
	  }
	};

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Tween = __webpack_require__(192);
	var raf = __webpack_require__(197);
	
	/**
	 * Expose `scrollTo`.
	 */
	
	module.exports = scrollTo;
	
	/**
	 * Scroll to `(x, y)`.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @api public
	 */
	
	function scrollTo(x, y, options) {
	  options = options || {};
	
	  // start position
	  var start = scroll();
	
	  // setup tween
	  var tween = Tween(start)
	    .ease(options.ease || 'out-circ')
	    .to({ top: y, left: x })
	    .duration(options.duration || 1000);
	
	  // scroll
	  tween.update(function(o){
	    window.scrollTo(o.left | 0, o.top | 0);
	  });
	
	  // handle end
	  tween.on('end', function(){
	    animate = function(){};
	  });
	
	  // animate
	  function animate() {
	    raf(animate);
	    tween.update();
	  }
	
	  animate();
	  
	  return tween;
	}
	
	/**
	 * Return scroll position.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	function scroll() {
	  var y = window.pageYOffset || document.documentElement.scrollTop;
	  var x = window.pageXOffset || document.documentElement.scrollLeft;
	  return { top: y, left: x };
	}


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Emitter = __webpack_require__(193);
	var clone = __webpack_require__(194);
	var type = __webpack_require__(195);
	var ease = __webpack_require__(196);
	
	/**
	 * Expose `Tween`.
	 */
	
	module.exports = Tween;
	
	/**
	 * Initialize a new `Tween` with `obj`.
	 *
	 * @param {Object|Array} obj
	 * @api public
	 */
	
	function Tween(obj) {
	  if (!(this instanceof Tween)) return new Tween(obj);
	  this._from = obj;
	  this.ease('linear');
	  this.duration(500);
	}
	
	/**
	 * Mixin emitter.
	 */
	
	Emitter(Tween.prototype);
	
	/**
	 * Reset the tween.
	 *
	 * @api public
	 */
	
	Tween.prototype.reset = function(){
	  this.isArray = 'array' === type(this._from);
	  this._curr = clone(this._from);
	  this._done = false;
	  this._start = Date.now();
	  return this;
	};
	
	/**
	 * Tween to `obj` and reset internal state.
	 *
	 *    tween.to({ x: 50, y: 100 })
	 *
	 * @param {Object|Array} obj
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.to = function(obj){
	  this.reset();
	  this._to = obj;
	  return this;
	};
	
	/**
	 * Set duration to `ms` [500].
	 *
	 * @param {Number} ms
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.duration = function(ms){
	  this._duration = ms;
	  return this;
	};
	
	/**
	 * Set easing function to `fn`.
	 *
	 *    tween.ease('in-out-sine')
	 *
	 * @param {String|Function} fn
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.ease = function(fn){
	  fn = 'function' == typeof fn ? fn : ease[fn];
	  if (!fn) throw new TypeError('invalid easing function');
	  this._ease = fn;
	  return this;
	};
	
	/**
	 * Stop the tween and immediately emit "stop" and "end".
	 *
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.stop = function(){
	  this.stopped = true;
	  this._done = true;
	  this.emit('stop');
	  this.emit('end');
	  return this;
	};
	
	/**
	 * Perform a step.
	 *
	 * @return {Tween} self
	 * @api private
	 */
	
	Tween.prototype.step = function(){
	  if (this._done) return;
	
	  // duration
	  var duration = this._duration;
	  var now = Date.now();
	  var delta = now - this._start;
	  var done = delta >= duration;
	
	  // complete
	  if (done) {
	    this._from = this._to;
	    this._update(this._to);
	    this._done = true;
	    this.emit('end');
	    return this;
	  }
	
	  // tween
	  var from = this._from;
	  var to = this._to;
	  var curr = this._curr;
	  var fn = this._ease;
	  var p = (now - this._start) / duration;
	  var n = fn(p);
	
	  // array
	  if (this.isArray) {
	    for (var i = 0; i < from.length; ++i) {
	      curr[i] = from[i] + (to[i] - from[i]) * n;
	    }
	
	    this._update(curr);
	    return this;
	  }
	
	  // objech
	  for (var k in from) {
	    curr[k] = from[k] + (to[k] - from[k]) * n;
	  }
	
	  this._update(curr);
	  return this;
	};
	
	/**
	 * Set update function to `fn` or
	 * when no argument is given this performs
	 * a "step".
	 *
	 * @param {Function} fn
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.update = function(fn){
	  if (0 == arguments.length) return this.step();
	  this._update = fn;
	  return this;
	};

/***/ },
/* 193 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var type;
	try {
	  type = __webpack_require__(195);
	} catch (_) {
	  type = __webpack_require__(195);
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = clone;
	
	/**
	 * Clones objects.
	 *
	 * @param {Mixed} any object
	 * @api public
	 */
	
	function clone(obj){
	  switch (type(obj)) {
	    case 'object':
	      var copy = {};
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          copy[key] = clone(obj[key]);
	        }
	      }
	      return copy;
	
	    case 'array':
	      var copy = new Array(obj.length);
	      for (var i = 0, l = obj.length; i < l; i++) {
	        copy[i] = clone(obj[i]);
	      }
	      return copy;
	
	    case 'regexp':
	      // from millermedeiros/amd-utils - MIT
	      var flags = '';
	      flags += obj.multiline ? 'm' : '';
	      flags += obj.global ? 'g' : '';
	      flags += obj.ignoreCase ? 'i' : '';
	      return new RegExp(obj.source, flags);
	
	    case 'date':
	      return new Date(obj.getTime());
	
	    default: // string, number, boolean, 
	      return obj;
	  }
	}


/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * toString ref.
	 */
	
	var toString = Object.prototype.toString;
	
	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	    case '[object Error]': return 'error';
	  }
	
	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val !== val) return 'nan';
	  if (val && val.nodeType === 1) return 'element';
	
	  val = val.valueOf
	    ? val.valueOf()
	    : Object.prototype.valueOf.apply(val)
	
	  return typeof val;
	};


/***/ },
/* 196 */
/***/ function(module, exports) {

	
	// easing functions from "Tween.js"
	
	exports.linear = function(n){
	  return n;
	};
	
	exports.inQuad = function(n){
	  return n * n;
	};
	
	exports.outQuad = function(n){
	  return n * (2 - n);
	};
	
	exports.inOutQuad = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n;
	  return - 0.5 * (--n * (n - 2) - 1);
	};
	
	exports.inCube = function(n){
	  return n * n * n;
	};
	
	exports.outCube = function(n){
	  return --n * n * n + 1;
	};
	
	exports.inOutCube = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n;
	  return 0.5 * ((n -= 2 ) * n * n + 2);
	};
	
	exports.inQuart = function(n){
	  return n * n * n * n;
	};
	
	exports.outQuart = function(n){
	  return 1 - (--n * n * n * n);
	};
	
	exports.inOutQuart = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n;
	  return -0.5 * ((n -= 2) * n * n * n - 2);
	};
	
	exports.inQuint = function(n){
	  return n * n * n * n * n;
	}
	
	exports.outQuint = function(n){
	  return --n * n * n * n * n + 1;
	}
	
	exports.inOutQuint = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n * n;
	  return 0.5 * ((n -= 2) * n * n * n * n + 2);
	};
	
	exports.inSine = function(n){
	  return 1 - Math.cos(n * Math.PI / 2 );
	};
	
	exports.outSine = function(n){
	  return Math.sin(n * Math.PI / 2);
	};
	
	exports.inOutSine = function(n){
	  return .5 * (1 - Math.cos(Math.PI * n));
	};
	
	exports.inExpo = function(n){
	  return 0 == n ? 0 : Math.pow(1024, n - 1);
	};
	
	exports.outExpo = function(n){
	  return 1 == n ? n : 1 - Math.pow(2, -10 * n);
	};
	
	exports.inOutExpo = function(n){
	  if (0 == n) return 0;
	  if (1 == n) return 1;
	  if ((n *= 2) < 1) return .5 * Math.pow(1024, n - 1);
	  return .5 * (-Math.pow(2, -10 * (n - 1)) + 2);
	};
	
	exports.inCirc = function(n){
	  return 1 - Math.sqrt(1 - n * n);
	};
	
	exports.outCirc = function(n){
	  return Math.sqrt(1 - (--n * n));
	};
	
	exports.inOutCirc = function(n){
	  n *= 2
	  if (n < 1) return -0.5 * (Math.sqrt(1 - n * n) - 1);
	  return 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
	};
	
	exports.inBack = function(n){
	  var s = 1.70158;
	  return n * n * (( s + 1 ) * n - s);
	};
	
	exports.outBack = function(n){
	  var s = 1.70158;
	  return --n * n * ((s + 1) * n + s) + 1;
	};
	
	exports.inOutBack = function(n){
	  var s = 1.70158 * 1.525;
	  if ( ( n *= 2 ) < 1 ) return 0.5 * ( n * n * ( ( s + 1 ) * n - s ) );
	  return 0.5 * ( ( n -= 2 ) * n * ( ( s + 1 ) * n + s ) + 2 );
	};
	
	exports.inBounce = function(n){
	  return 1 - exports.outBounce(1 - n);
	};
	
	exports.outBounce = function(n){
	  if ( n < ( 1 / 2.75 ) ) {
	    return 7.5625 * n * n;
	  } else if ( n < ( 2 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 1.5 / 2.75 ) ) * n + 0.75;
	  } else if ( n < ( 2.5 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 2.25 / 2.75 ) ) * n + 0.9375;
	  } else {
	    return 7.5625 * ( n -= ( 2.625 / 2.75 ) ) * n + 0.984375;
	  }
	};
	
	exports.inOutBounce = function(n){
	  if (n < .5) return exports.inBounce(n * 2) * .5;
	  return exports.outBounce(n * 2 - 1) * .5 + .5;
	};
	
	// aliases
	
	exports['in-quad'] = exports.inQuad;
	exports['out-quad'] = exports.outQuad;
	exports['in-out-quad'] = exports.inOutQuad;
	exports['in-cube'] = exports.inCube;
	exports['out-cube'] = exports.outCube;
	exports['in-out-cube'] = exports.inOutCube;
	exports['in-quart'] = exports.inQuart;
	exports['out-quart'] = exports.outQuart;
	exports['in-out-quart'] = exports.inOutQuart;
	exports['in-quint'] = exports.inQuint;
	exports['out-quint'] = exports.outQuint;
	exports['in-out-quint'] = exports.inOutQuint;
	exports['in-sine'] = exports.inSine;
	exports['out-sine'] = exports.outSine;
	exports['in-out-sine'] = exports.inOutSine;
	exports['in-expo'] = exports.inExpo;
	exports['out-expo'] = exports.outExpo;
	exports['in-out-expo'] = exports.inOutExpo;
	exports['in-circ'] = exports.inCirc;
	exports['out-circ'] = exports.outCirc;
	exports['in-out-circ'] = exports.inOutCirc;
	exports['in-back'] = exports.inBack;
	exports['out-back'] = exports.outBack;
	exports['in-out-back'] = exports.inOutBack;
	exports['in-bounce'] = exports.inBounce;
	exports['out-bounce'] = exports.outBounce;
	exports['in-out-bounce'] = exports.inOutBounce;


/***/ },
/* 197 */
/***/ function(module, exports) {

	/**
	 * Expose `requestAnimationFrame()`.
	 */
	
	exports = module.exports = window.requestAnimationFrame
	  || window.webkitRequestAnimationFrame
	  || window.mozRequestAnimationFrame
	  || fallback;
	
	/**
	 * Fallback implementation.
	 */
	
	var prev = new Date().getTime();
	function fallback(fn) {
	  var curr = new Date().getTime();
	  var ms = Math.max(0, 16 - (curr - prev));
	  var req = setTimeout(fn, ms);
	  prev = curr;
	  return req;
	}
	
	/**
	 * Cancel.
	 */
	
	var cancel = window.cancelAnimationFrame
	  || window.webkitCancelAnimationFrame
	  || window.mozCancelAnimationFrame
	  || window.clearTimeout;
	
	exports.cancel = function(id){
	  cancel.call(window, id);
	};


/***/ },
/* 198 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var event = {
	  /**
	   * openUrl
	   * @param  {string} url
	   */
	  openURL: function openURL(url) {
	    location.href = url;
	  }
	
	};
	
	var meta = {
	  event: [{
	    name: 'openURL',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('event', event, meta);
	  }
	};

/***/ },
/* 199 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var pageInfo = {
	
	  setTitle: function setTitle(title) {
	    title = title || 'Weex HTML5';
	    try {
	      title = decodeURIComponent(title);
	    } catch (e) {}
	    document.title = title;
	  }
	};
	
	var meta = {
	  pageInfo: [{
	    name: 'setTitle',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('pageInfo', pageInfo, meta);
	  }
	};

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib, XMLHttpRequest */
	/* deps: httpurl */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	__webpack_require__(135);
	
	var utils = void 0;
	
	var jsonpCnt = 0;
	var ERROR_STATE = -1;
	
	var TYPE_JSON = 'application/json;charset=UTF-8';
	var TYPE_FORM = 'application/x-www-form-urlencoded';
	
	var REG_FORM = /^(?:[^&=]+=[^&=]+)(?:&[^&=]+=[^&=]+)*$/;
	
	function _jsonp(config, callback, progressCallback) {
	  var cbName = 'jsonp_' + ++jsonpCnt;
	  var url = void 0;
	
	  if (!config.url) {
	    console.error('[h5-render] config.url should be set in _jsonp for \'fetch\' API.');
	  }
	
	  global[cbName] = function (cb) {
	    return function (response) {
	      callback(response);
	      delete global[cb];
	    };
	  }(cbName);
	
	  var script = document.createElement('script');
	  try {
	    url = lib.httpurl(config.url);
	  } catch (err) {
	    console.error('[h5-render] invalid config.url in _jsonp for \'fetch\' API: ' + config.url);
	  }
	  url.params.callback = cbName;
	  script.type = 'text/javascript';
	  script.src = url.toString();
	  // script.onerror is not working on IE or safari.
	  // but they are not considered here.
	  script.onerror = function (cb) {
	    return function (err) {
	      console.error('[h5-render] unexpected error in _jsonp for \'fetch\' API', err);
	      callback(err);
	      delete global[cb];
	    };
	  }(cbName);
	  var head = document.getElementsByTagName('head')[0];
	  head.insertBefore(script, null);
	}
	
	function _xhr(config, callback, progressCallback) {
	  var xhr = new XMLHttpRequest();
	  xhr.responseType = config.type;
	  xhr.open(config.method, config.url, true);
	
	  var headers = config.headers || {};
	  for (var k in headers) {
	    xhr.setRequestHeader(k, headers[k]);
	  }
	
	  xhr.onload = function (res) {
	    callback({
	      status: xhr.status,
	      ok: xhr.status >= 200 && xhr.status < 300,
	      statusText: xhr.statusText,
	      data: xhr.response,
	      headers: xhr.getAllResponseHeaders().split('\n').reduce(function (obj, headerStr) {
	        var headerArr = headerStr.match(/(.+): (.+)/);
	        if (headerArr) {
	          obj[headerArr[1]] = headerArr[2];
	        }
	        return obj;
	      }, {})
	    });
	  };
	
	  if (progressCallback) {
	    xhr.onprogress = function (e) {
	      progressCallback({
	        readyState: xhr.readyState,
	        status: xhr.status,
	        length: e.loaded,
	        total: e.total,
	        statusText: xhr.statusText,
	        headers: xhr.getAllResponseHeaders().split('\n').reduce(function (obj, headerStr) {
	          var headerArr = headerStr.match(/(.+): (.+)/);
	          if (headerArr) {
	            obj[headerArr[1]] = headerArr[2];
	          }
	          return obj;
	        }, {})
	      });
	    };
	  }
	
	  xhr.onerror = function (err) {
	    console.error('[h5-render] unexpected error in _xhr for \'fetch\' API', err);
	    callback({
	      status: ERROR_STATE,
	      ok: false,
	      statusText: '',
	      data: '',
	      headers: {}
	    });
	  };
	
	  xhr.send(config.body);
	}
	
	var stream = {
	
	  /**
	   * sendHttp
	   * @deprecated
	   * Note: This API is deprecated. Please use stream.fetch instead.
	   * send a http request through XHR.
	   * @param  {obj} params
	   *  - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH',
	   *  - url: url requested
	   * @param  {string} callbackId
	   */
	  sendHttp: function sendHttp(param, callbackId) {
	    if (typeof param === 'string') {
	      try {
	        param = JSON.parse(param);
	      } catch (e) {
	        return;
	      }
	    }
	    if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) !== 'object' || !param.url) {
	      return console.error('[h5-render] invalid config or invalid config.url for sendHttp API');
	    }
	
	    var sender = this.sender;
	    var method = param.method || 'GET';
	    var xhr = new XMLHttpRequest();
	    xhr.open(method, param.url, true);
	    xhr.onload = function () {
	      sender.performCallback(callbackId, this.responseText);
	    };
	    xhr.onerror = function (error) {
	      return console.error('[h5-render] unexpected error in sendHttp API', error);
	      // sender.performCallback(
	      //   callbackId,
	      //   new Error('unexpected error in sendHttp API')
	      // )
	    };
	    xhr.send();
	  },
	
	  /**
	   * fetch
	   * use stream.fetch to request for a json file, a plain text file or
	   * a arraybuffer for a file stream. (You can use Blob and FileReader
	   * API implemented by most modern browsers to read a arraybuffer.)
	   * @param  {object} options config options
	   *   - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH'
	   *   - headers {obj}
	   *   - url {string}
	   *   - mode {string} 'cors' | 'no-cors' | 'same-origin' | 'navigate'
	   *   - body
	   *   - type {string} 'json' | 'jsonp' | 'text'
	   * @param  {string} callbackId
	   * @param  {string} progressCallbackId
	   */
	  fetch: function fetch(options, callbackId, progressCallbackId) {
	    var DEFAULT_METHOD = 'GET';
	    var DEFAULT_MODE = 'cors';
	    var DEFAULT_TYPE = 'text';
	
	    var methodOptions = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH'];
	    var modeOptions = ['cors', 'no-cors', 'same-origin', 'navigate'];
	    var typeOptions = ['text', 'json', 'jsonp', 'arraybuffer'];
	
	    // const fallback = false  // fallback from 'fetch' API to XHR.
	    var sender = this.sender;
	
	    var config = utils.extend({}, options);
	
	    // validate options.method
	    if (typeof config.method === 'undefined') {
	      config.method = DEFAULT_METHOD;
	      console.warn('[h5-render] options.method for \'fetch\' API has been set to ' + 'default value \'' + config.method + '\'');
	    } else if (methodOptions.indexOf((config.method + '').toUpperCase()) === -1) {
	      return console.error('[h5-render] options.method \'' + config.method + '\' for \'fetch\' API should be one of ' + methodOptions + '.');
	    }
	
	    // validate options.url
	    if (!config.url) {
	      return console.error('[h5-render] options.url should be set for \'fetch\' API.');
	    }
	
	    // validate options.mode
	    if (typeof config.mode === 'undefined') {
	      config.mode = DEFAULT_MODE;
	    } else if (modeOptions.indexOf((config.mode + '').toLowerCase()) === -1) {
	      return console.error('[h5-render] options.mode \'' + config.mode + '\' for \'fetch\' API should be one of ' + modeOptions + '.');
	    }
	
	    // validate options.type
	    if (typeof config.type === 'undefined') {
	      config.type = DEFAULT_TYPE;
	      console.warn('[h5-render] options.type for \'fetch\' API has been set to ' + 'default value \'' + config.type + '\'.');
	    } else if (typeOptions.indexOf((config.type + '').toLowerCase()) === -1) {
	      return console.error('[h5-render] options.type \'' + config.type + '\' for \'fetch\' API should be one of ' + typeOptions + '.');
	    }
	
	    // validate options.headers
	    config.headers = config.headers || {};
	    if (!utils.isPlainObject(config.headers)) {
	      return console.error('[h5-render] options.headers should be a plain object');
	    }
	
	    // validate options.body
	    var body = config.body;
	    if (!config.headers['Content-Type'] && body) {
	      if (utils.isPlainObject(body)) {
	        // is a json data
	        try {
	          config.body = JSON.stringify(body);
	          config.headers['Content-Type'] = TYPE_JSON;
	        } catch (e) {}
	      } else if (utils.getType(body) === 'string' && body.match(REG_FORM)) {
	        // is form-data
	        config.body = encodeURI(body);
	        config.headers['Content-Type'] = TYPE_FORM;
	      }
	    }
	
	    // validate options.timeout
	    config.timeout = parseInt(config.timeout, 10) || 2500;
	
	    var _callArgs = [config, function (res) {
	      sender.performCallback(callbackId, res);
	    }];
	    if (progressCallbackId) {
	      _callArgs.push(function (res) {
	        // Set 'keepAlive' to true for sending continuous callbacks
	        sender.performCallback(progressCallbackId, res, true);
	      });
	    }
	
	    if (config.type === 'jsonp') {
	      _jsonp.apply(this, _callArgs);
	    } else {
	      _xhr.apply(this, _callArgs);
	    }
	  }
	
	};
	
	var meta = {
	  stream: [{
	    name: 'sendHttp',
	    args: ['object', 'function']
	  }, {
	    name: 'fetch',
	    args: ['object', 'function', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    utils = Weex.utils;
	    Weex.registerApiModule('stream', stream, meta);
	  }
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modals = __webpack_require__(202);
	
	var _modals2 = _interopRequireDefault(_modals);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var msg = {
	
	  // duration: default is 0.8 seconds.
	  toast: function toast(config) {
	    _modals2.default.toast(config.message, config.duration);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - callback
	  alert: function alert(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function () {
	      sender.performCallback(callbackId);
	    };
	    _modals2.default.alert(config);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  confirm: function confirm(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val);
	    };
	    _modals2.default.confirm(config);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  prompt: function prompt(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val);
	    };
	    _modals2.default.prompt(config);
	  }
	};
	
	var meta = {
	  modal: [{
	    name: 'toast',
	    args: ['object']
	  }, {
	    name: 'alert',
	    args: ['object', 'function']
	  }, {
	    name: 'confirm',
	    args: ['object', 'function']
	  }, {
	    name: 'prompt',
	    args: ['object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('modal', msg, meta);
	  }
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Alert = __webpack_require__(203)
	var Confirm = __webpack_require__(209)
	var Prompt = __webpack_require__(212)
	var toast = __webpack_require__(215)
	
	var modal = {
	
	  toast: function (msg, duration) {
	    toast.push(msg, duration)
	  },
	
	  alert: function (config) {
	    new Alert(config).show()
	  },
	
	  prompt: function (config) {
	    new Prompt(config).show()
	  },
	
	  confirm: function (config) {
	    new Confirm(config).show()
	  }
	
	}
	
	!window.lib && (window.lib = {})
	window.lib.modal = modal
	
	module.exports = modal

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(204)
	__webpack_require__(207)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Alert(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  Modal.call(this)
	  this.node.classList.add('amfe-alert')
	}
	
	Alert.prototype = Object.create(Modal.prototype)
	
	Alert.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var button = document.createElement('div')
	  button.classList.add(BUTTON_CLASS, 'alert-ok')
	  button.appendChild(document.createTextNode(this.okTitle))
	  buttonGroup.appendChild(button)
	}
	
	Alert.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var button = this.node.querySelector('.' + BUTTON_CLASS)
	  button.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback()
	  }.bind(this))
	}
	
	module.exports = Alert


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(205)
	
	// there will be only one instance of modal.
	var MODAL_WRAP_CLASS = 'amfe-modal-wrap'
	var MODAL_NODE_CLASS = 'amfe-modal-node'
	
	function Modal() {
	  this.wrap = document.querySelector(MODAL_WRAP_CLASS)
	  this.node = document.querySelector(MODAL_NODE_CLASS)
	  if (!this.wrap) {
	    this.createWrap()
	  }
	  if (!this.node) {
	    this.createNode()
	  }
	  this.clearNode()
	  this.createNodeContent()
	  this.bindEvents()
	}
	
	Modal.prototype = {
	
	  show: function () {
	    this.wrap.style.display = 'block'
	    this.node.classList.remove('hide')
	  },
	
	  destroy: function () {
	    document.body.removeChild(this.wrap)
	    document.body.removeChild(this.node)
	    this.wrap = null
	    this.node = null
	  },
	
	  createWrap: function () {
	    this.wrap = document.createElement('div')
	    this.wrap.className = MODAL_WRAP_CLASS
	    document.body.appendChild(this.wrap)
	  },
	
	  createNode: function () {
	    this.node = document.createElement('div')
	    this.node.classList.add(MODAL_NODE_CLASS, 'hide')
	    document.body.appendChild(this.node)
	  },
	
	  clearNode: function () {
	    this.node.innerHTML = ''
	  },
	
	  createNodeContent: function () {
	
	    // do nothing.
	    // child classes can override this method.
	  },
	
	  bindEvents: function () {
	    this.wrap.addEventListener('click', function (e) {
	      e.preventDefault()
	      e.stopPropagation()
	    })
	  }
	}
	
	module.exports = Modal


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(206);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./modal.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./modal.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-modal-wrap {\n  display: none;\n  position: fixed;\n  z-index: 999999999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #000;\n  opacity: 0.5;\n}\n\n.amfe-modal-node {\n  position: fixed;\n  z-index: 9999999999;\n  top: 50%;\n  left: 50%;\n  width: 6.666667rem;\n  min-height: 2.666667rem;\n  border-radius: 0.066667rem;\n  -webkit-transform: translate(-50%, -50%);\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n}\n.amfe-modal-node.hide {\n  display: none;\n}\n.amfe-modal-node .content {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  width: 100%;\n  min-height: 1.866667rem;\n  box-sizing: border-box;\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  padding: 0.213333rem;\n  border-bottom: 1px solid #ddd;\n}\n.amfe-modal-node .btn-group {\n  width: 100%;\n  height: 0.8rem;\n  font-size: 0.373333rem;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  border: none;\n}\n.amfe-modal-node .btn-group .btn {\n  box-sizing: border-box;\n  height: 0.8rem;\n  line-height: 0.8rem;\n  margin: 0;\n  padding: 0;\n  border: none;\n  background: none;\n}\n", ""]);
	
	// exports


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(208);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./alert.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./alert.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-alert .amfe-alert-ok {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(204)
	__webpack_require__(210)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Confirm(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-confirm')
	}
	
	Confirm.prototype = Object.create(Modal.prototype)
	
	Confirm.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Confirm.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  btnOk.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.okTitle)
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.cancelTitle)
	  }.bind(this))
	}
	
	module.exports = Confirm


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(211);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./confirm.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./confirm.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-confirm .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-confirm .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(204)
	__webpack_require__(213)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	var INPUT_WRAP_CLASS = 'input-wrap'
	var INPUT_CLASS = 'input'
	
	function Prompt(config) {
	  this.msg = config.message || ''
	  this.defaultMsg = config.default || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-prompt')
	}
	
	Prompt.prototype = Object.create(Modal.prototype)
	
	Prompt.prototype.createNodeContent = function () {
	
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var inputWrap = document.createElement('div')
	  inputWrap.classList.add(INPUT_WRAP_CLASS)
	  content.appendChild(inputWrap)
	  var input = document.createElement('input')
	  input.classList.add(INPUT_CLASS)
	  input.type = 'text'
	  input.autofocus = true
	  input.placeholder = this.defaultMsg
	  inputWrap.appendChild(input)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Prompt.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  var that = this
	  btnOk.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.okTitle,
	      data: val
	    })
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.cancelTitle,
	      data: val
	    })
	  }.bind(this))
	}
	
	module.exports = Prompt


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(214);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./prompt.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./prompt.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-prompt .input-wrap {\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: 0.133333rem;\n  // padding: 0.24rem 0.213333rem 0.213333rem;\n  height: 0.96rem;\n}\n.amfe-prompt .input-wrap .input {\n  box-sizing: border-box;\n  width: 100%;\n  height: 0.56rem;\n  line-height: 0.56rem;\n  font-size: 0.32rem;\n  border: 1px solid #999;\n}\n.amfe-prompt .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-prompt .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(216)
	
	var queue = []
	var timer
	var isProcessing = false
	var toastWin
	var TOAST_WIN_CLASS_NAME = 'amfe-toast'
	
	var DEFAULT_DURATION = 0.8
	
	function showToastWindow(msg, callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    toastWin = document.createElement('div')
	    toastWin.classList.add(TOAST_WIN_CLASS_NAME, 'hide')
	    document.body.appendChild(toastWin)
	  }
	  toastWin.innerHTML = msg
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  setTimeout(function () {
	    toastWin.classList.remove('hide')
	  }, 0)
	}
	
	function hideToastWindow(callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    return
	  }
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  toastWin.classList.add('hide')
	}
	
	var toast = {
	
	  push: function (msg, duration) {
	    queue.push({
	      msg: msg,
	      duration: duration || DEFAULT_DURATION
	    })
	    this.show()
	  },
	
	  show: function () {
	    var that = this
	
	    // All messages had been toasted already, so remove the toast window,
	    if (!queue.length) {
	      toastWin && toastWin.parentNode.removeChild(toastWin)
	      toastWin = null
	      return
	    }
	
	    // the previous toast is not ended yet.
	    if (isProcessing) {
	      return
	    }
	    isProcessing = true
	
	    var toastInfo = queue.shift()
	    showToastWindow(toastInfo.msg, function () {
	      timer = setTimeout(function () {
	        timer = null
	        hideToastWindow(function () {
	          isProcessing = false
	          that.show()
	        })
	      }, toastInfo.duration * 1000)
	    })
	  }
	
	}
	
	module.exports = {
	  push: toast.push.bind(toast)
	}


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(217);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./toast.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./toast.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-toast {\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  position: fixed;\n  box-sizing: border-box;\n  max-width: 80%;\n  bottom: 2.666667rem;\n  left: 50%;\n  padding: 0.213333rem;\n  background-color: #000;\n  color: #fff;\n  text-align: center;\n  opacity: 0.6;\n  transition: all 0.4s ease-in-out;\n  border-radius: 0.066667rem;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%);\n}\n\n.amfe-toast.hide {\n  opacity: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lib = __webpack_require__(219);
	
	var _data = {};
	
	var animation = {
	
	  /**
	   * transition
	   * @param  {string} ref        [description]
	   * @param  {obj} config     [description]
	   * @param  {string} callbackId [description]
	   */
	  transition: function transition(ref, config, callbackId) {
	    var refData = _data[ref];
	    var stylesKey = JSON.stringify(config.styles);
	    var weexInstance = this;
	    // If the same component perform a animation with exactly the same
	    // styles in a sequence with so short interval that the prev animation
	    // is still in playing, then the next animation should be ignored.
	    if (refData && refData[stylesKey]) {
	      return;
	    }
	    if (!refData) {
	      refData = _data[ref] = {};
	    }
	    refData[stylesKey] = true;
	
	    var component = this.getComponentManager().getComponent(ref);
	    return (0, _lib.transitionOnce)(component, config, function () {
	      // Remove the stylesKey in refData so that the same animation
	      // can be played again after current animation is already finished.
	      delete refData[stylesKey];
	      weexInstance.sender.performCallback(callbackId);
	    });
	  }
	};
	
	var meta = {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('animation', animation, meta);
	  }
	};

/***/ },
/* 219 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	
	  /**
	   * config:
	   *   - styles
	   *   - duration [Number] milliseconds(ms)
	   *   - timingFunction [string]
	   *   - dealy [Number] milliseconds(ms)
	   */
	  transitionOnce: function transitionOnce(comp, config, callback) {
	    var styles = config.styles || {};
	    var duration = config.duration || 1000; // ms
	    var timingFunction = config.timingFunction || 'ease';
	    var delay = config.delay || 0; // ms
	    var transitionValue = 'all ' + duration + 'ms ' + timingFunction + ' ' + delay + 'ms';
	    var dom = comp.node;
	    var transitionEndHandler = function transitionEndHandler(e) {
	      e.stopPropagation();
	      dom.removeEventListener('webkitTransitionEnd', transitionEndHandler);
	      dom.removeEventListener('transitionend', transitionEndHandler);
	      dom.style.transition = '';
	      dom.style.webkitTransition = '';
	      callback();
	    };
	    dom.style.transition = transitionValue;
	    dom.style.webkitTransition = transitionValue;
	    dom.addEventListener('webkitTransitionEnd', transitionEndHandler);
	    dom.addEventListener('transitionend', transitionEndHandler);
	    comp.updateStyle(styles);
	  }
	
	};

/***/ },
/* 220 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var webview = {
	
	  // ref: ref of the web component.
	  goBack: function goBack(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.goBack) {
	      console.error('error: the specified component has no method of' + ' goBack. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.goBack();
	  },
	
	  // ref: ref of the web component.
	  goForward: function goForward(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.goForward) {
	      console.error('error: the specified component has no method of' + ' goForward. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.goForward();
	  },
	
	  // ref: ref of the web component.
	  reload: function reload(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.reload) {
	      console.error('error: the specified component has no method of' + ' reload. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.reload();
	  }
	
	};
	
	var meta = {
	  webview: [{
	    name: 'goBack',
	    args: ['string']
	  }, {
	    name: 'goForward',
	    args: ['string']
	  }, {
	    name: 'reload',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('webview', webview, meta);
	  }
	};

/***/ },
/* 221 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var navigator = {
	
	  // config
	  //  - url: the url to push
	  //  - animated: this configuration item is native only
	  //  callback is not currently supported
	  push: function push(config, callbackId) {
	    window.location.href = config.url;
	    this.sender.performCallback(callbackId);
	  },
	
	  // config
	  //  - animated: this configuration item is native only
	  //  callback is note currently supported
	  pop: function pop(config, callbackId) {
	    window.history.back();
	    this.sender.performCallback(callbackId);
	  }
	
	};
	
	var meta = {
	  navigator: [{
	    name: 'push',
	    args: ['object', 'function']
	  }, {
	    name: 'pop',
	    args: ['object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('navigator', navigator, meta);
	  }
	};

/***/ },
/* 222 */
/***/ function(module, exports) {

	/* global localStorage */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var supportLocalStorage = typeof localStorage !== 'undefined';
	var SUCCESS = 'success';
	var FAILED = 'failed';
	var INVALID_PARAM = 'invalid_param';
	var UNDEFINED = 'undefined';
	
	var storage = {
	
	  /**
	   * When passed a key name and value, will add that key to the storage,
	   * or update that key's value if it already exists.
	   * @param {string} key
	   * @param {string} value
	   * @param {function} callbackId
	   */
	  setItem: function setItem(key, value, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key || !value) {
	      sender.performCallback(callbackId, {
	        result: 'failed',
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    try {
	      localStorage.setItem(key, value);
	      sender.performCallback(callbackId, {
	        result: SUCCESS,
	        data: UNDEFINED
	      });
	    } catch (e) {
	      // accept any exception thrown during a storage attempt as a quota error
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: UNDEFINED
	      });
	    }
	  },
	
	  /**
	   * When passed a key name, will return that key's value.
	   * @param {string} key
	   * @param {function} callbackId
	   */
	  getItem: function getItem(key, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key) {
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    var val = localStorage.getItem(key);
	    sender.performCallback(callbackId, {
	      result: val ? SUCCESS : FAILED,
	      data: val || UNDEFINED
	    });
	  },
	
	  /**
	   *When passed a key name, will remove that key from the storage.
	   * @param {string} key
	   * @param {function} callbackId
	   */
	  removeItem: function removeItem(key, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key) {
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    localStorage.removeItem(key);
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: UNDEFINED
	    });
	  },
	
	  /**
	   * Returns an integer representing the number of data items stored in the Storage object.
	   * @param {function} callbackId
	   */
	  length: function length(callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    var len = localStorage.length;
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: len
	    });
	  },
	
	  /**
	   * Returns an array that contains all keys stored in Storage object.
	   * @param {function} callbackId
	   */
	  getAllKeys: function getAllKeys(callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    var _arr = [];
	    for (var i = 0; i < localStorage.length; i++) {
	      _arr.push(localStorage.key(i));
	    }
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: _arr
	    });
	  }
	};
	
	var meta = {
	  storage: [{
	    name: 'setItem',
	    args: ['string', 'string', 'function']
	  }, {
	    name: 'getItem',
	    args: ['string', 'function']
	  }, {
	    name: 'removeItem',
	    args: ['string', 'function']
	  }, {
	    name: 'length',
	    args: ['function']
	  }, {
	    name: 'getAllKeys',
	    args: ['function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('storage', storage, meta);
	  }
	};

/***/ },
/* 223 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	
	AUCTION:
	taskQueue
	Clipboard.setString()  NOW not works, facing to user-act lose of taskQueue.
	
	works in Chrome Firefox Opera. but not in Safari.
	@see https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Browser_compatibility
	
	Clipboard.getString() unimplemented. There is no easy way to do paste from clipboard to js variable.
	
	So look out your app behavior, when downgrade to html5 render.
	Any idea is welcome.
	**/
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var WEEX_CLIPBOARD_ID = '__weex_clipboard_id__';
	
	var clipboard = {
	
	  getString: function getString(callbackId) {
	    // not supported in html5
	    console.log('clipboard.getString() is not supported now.');
	  },
	
	  setString: function setString(text) {
	    // not support safari
	    if (typeof text === 'string' && text !== '' && document.execCommand) {
	      var tempInput = element();
	      tempInput.value = text;
	
	      tempInput.select();
	      document.execCommand('copy');
	      // var out = document.execCommand('copy');
	      // console.log("execCommand out is " + out);
	      tempInput.value = '';
	      tempInput.blur();
	    } else {
	      console.log('only support string input now');
	    }
	  }
	
	};
	
	function element() {
	  var tempInput = document.getElementById(WEEX_CLIPBOARD_ID);
	  if (tempInput === undefined) {
	    tempInput = document.createElement('input');
	    tempInput.setAttribute('id', WEEX_CLIPBOARD_ID);
	    tempInput.style.cssText = 'height:1px;width:1px;border:none;';
	    // tempInput.style.cssText = "height:40px;width:300px;border:solid;"
	    document.body.appendChild(tempInput);
	  }
	  return tempInput;
	}
	
	var meta = {
	  clipboard: [{
	    name: 'getString',
	    args: ['function']
	  }, {
	    name: 'setString',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('clipboard', clipboard, meta);
	  }
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTliYTZiN2JiN2UzMmJlNWQxZTkiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9zdHlsZS9iYXNlLmNzcz8wNmI0Iiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL3N0eWxlL2Jhc2UuY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL2h0bWw1L3NoYXJlZC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9zaGFyZWQvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvY29uZmlnLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9kZWZhdWx0L2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9zdGF0aWMvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9jdHJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvY3RybC9pbml0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvZnJhbWVVcGRhdGVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9idW5kbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9idW5kbGUvYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvdm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9jb3JlL3N0YXRlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvY29yZS93YXRjaGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvcmUvZGVwLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvY29yZS9vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvcmUvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC92bS9jb21waWxlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3ZtL2RpcmVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3ZtL2RvbS1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC92bS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL21pc2MuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL2RlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2FwcC9jdHJsL21pc2MuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvZGlmZmVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9saWZlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL2JyaWRnZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9taXNjLmpzIiwid2VicGFjazovLy8uL2h0bWw1L3Zkb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcGkvbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2RvbS9jb21wb25lbnRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZG9tL2FwcGVhcldhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL2xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9wcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9zZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L29wZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC92YWx1ZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L3Bvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvc3RpY2t5LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvZmxleGJveC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L2xhenlsb2FkLmpzIiwid2VicGFjazovLy8uL34vbGF6eWltZy9zcmMvYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xhenlpbWcvfi9hcHBlYXJqcy9zcmMvYXBwZWFyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9hdG9taWMuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbnZkL2J1aWxkL2VudmQuY29tbW9uLmpzIiwid2VicGFjazovLy8uL34vaHR0cHVybC9idWlsZC9odHRwdXJsLmNvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9nZXN0dXJlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9yb290LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9kaXYuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2ltYWdlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW1hZ2UvaW1hZ2UuY3NzPzhlNWQiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbWFnZS9pbWFnZS5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy90ZXh0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC92bGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9saXN0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzcz9hZmUxIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9tb3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xpc3QvaGxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9yZWZyZXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9yZWZyZXNoL3JlZnJlc2guY3NzPzUxNjQiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2gvcmVmcmVzaC5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvbG9hZGluZy5jc3M/MzhhMSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbG9hZGluZy9sb2FkaW5nLmNzcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWJpY2Jlemllci9idWlsZC9jdWJpY2Jlemllci5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmltYXRpb25qcy9idWlsZC9hbmltYXRpb24uY29tbW9uLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL2NhcnJvdXNlbC5jc3M/M2MwMSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3RpbWVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5jc3M/M2Q3ZSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGljYXRvci5jc3M/MTI5NCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2luZGljYXRvci9pbmRpY2F0b3IuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL3RhYmhlYWRlci5jc3M/YTIwZCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3RhYmhlYWRlci90YWJoZWFkZXIuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy92aWRlby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3ZpZGVvL3ZpZGVvLmNzcz85MjU2Iiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdmlkZW8vdmlkZW8uY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3dpdGNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3dpdGNoL3N3aXRjaC5jc3M/MzRkNCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3N3aXRjaC9zd2l0Y2guY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvYS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2VtYmVkLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3Bpbm5lci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5jc3M/MWRlMiIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy93ZWIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC1jbG9uZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC10eXBlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2Nyb2xsLXRvL34vY29tcG9uZW50LXR3ZWVuL34vZWFzZS1jb21wb25lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtcmFmL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvcGFnZUluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbW9kYWxzL3NyYy9hbGVydC5qcyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zcmMvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL21vZGFsLmNzcz82YzZkIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy9tb2RhbC5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2FsZXJ0LmNzcz9iZWFmIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3JjL2NvbmZpcm0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzPzBjOTIiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzIiwid2VicGFjazovLy8uL34vbW9kYWxzL3NyYy9wcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3M/ZDE1YyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zdHlsZXMvcHJvbXB0LmNzcyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zcmMvdG9hc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL3RvYXN0LmNzcz9lMTJmIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2FuaW1hdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvYW5pbWF0aW9uL2xpYi5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvd2Vidmlldy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvbmF2aWdhdG9yLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9zdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9jbGlwYm9hcmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOzs7Ozs7QUFFQTs7OztBQUtBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OztBQUVBLGtCQUFLLE9BQUw7QUFDQSxrQkFBSyxPQUFMO0FBQ0Esa0JBQUssT0FBTDtBQUNBLGtCQUFLLE9BQUw7Ozs7Ozs7Ozs7QUNiQTs7Ozs7bUJBMER3QixJOztBQXhEeEI7O0FBRUE7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7S0FBWSxLOztBQUNaOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUVBOztBQUNBOztBQUdBOzs7Ozs7QUFFQSxLQUFNLHVCQUF1QixHQUE3Qjs7OztBQUNBLEtBQU0sZ0JBQWdCLE9BQU8sVUFBUCxHQUFvQixvQkFBMUM7QUFDQSxLQUFNLGtCQUFrQixNQUF4QjtBQUNBLEtBQU0sOEJBQThCLG1CQUFwQzs7QUFFQSxRQUFPLGFBQVAsR0FBdUI7QUFDckIsZ0JBQWEsaUJBQU8sV0FEQztBQUVyQixZQUFTLElBQUksR0FBSixDQUFRLE1BQVIsR0FBaUIsSUFBSSxHQUFKLENBQVEsTUFBUixDQUFlLE9BQWhDLEdBQTBDLElBRjlCO0FBR3JCLGVBQVksSUFBSSxHQUFKLENBQVEsTUFBUixHQUFpQixJQUFJLEdBQUosQ0FBUSxNQUFSLENBQWUsT0FBZixDQUF1QixHQUF4QyxHQUE4QyxJQUhyQztBQUlyQixhQUFVLEtBSlc7QUFLckIsV0FBUSxJQUFJLEdBQUosQ0FBUSxPQUFSLEdB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTyxVQUFVLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxHQUFHO0FBQ1I7QUFDQSxHOzs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsVUFBVTtBQUNiO0FBQ0EsRzs7Ozs7O0FDZkEsZUFBYyxzQjs7Ozs7O0FDQWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxH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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0U7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBlOWJhNmI3YmI3ZTMyYmU1ZDFlOVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgV2VleCBmcm9tICcuL3JlbmRlcidcblxuLyoqXG4gKiBpbnN0YWxsIGNvbXBvbmVudHMgYW5kIEFQSXNcbiAqL1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9iYXNlL3Jvb3QnXG5pbXBvcnQgZGl2IGZyb20gJy4vYmFzZS9kaXYnXG5pbXBvcnQgY29tcG9uZW50cyBmcm9tICcuL2V4dGVuZC9jb21wb25lbnRzJ1xuaW1wb3J0IGFwaSBmcm9tICcuL2V4dGVuZC9hcGknXG5cbldlZXguaW5zdGFsbChyb290KVxuV2VleC5pbnN0YWxsKGRpdilcbldlZXguaW5zdGFsbChjb21wb25lbnRzKVxuV2VleC5pbnN0YWxsKGFwaSlcblxuZXhwb3J0IGRlZmF1bHQgV2VleFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2luZGV4LmpzXG4gKiovIiwiLyogZ2xvYmFsIGxpYiwgV2ViU29ja2V0ICovXG5cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgJy4vc3R5bGUvYmFzZS5jc3MnXG5cbmltcG9ydCAnLi4vcnVudGltZSdcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZydcbmltcG9ydCB7IGxvYWQgfSBmcm9tICcuL2xvYWRlcidcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgU2VuZGVyLCByZWNlaXZlciB9IGZyb20gJy4uL2JyaWRnZSdcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vYmFzZS9jb21wb25lbnQnXG5pbXBvcnQgQXRvbWljIGZyb20gJy4uL2Jhc2UvYXRvbWljJ1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vZG9tL2NvbXBvbmVudE1hbmFnZXInXG5pbXBvcnQgeyBiaW5kIGFzIGJpbmRSZWdpc3RlciB9IGZyb20gJy4vcmVnaXN0ZXInXG5cbmltcG9ydCAnZW52ZCdcbmltcG9ydCAnaHR0cHVybCdcblxuLy8gZ2VzdHVyZVxuaW1wb3J0ICcuL2dlc3R1cmUnXG5cbmNvbnN0IERFRkFVTFRfREVTSUdOX1dJRFRIID0gNzUwXG5jb25zdCBERUZBVUxUX1NDQUxFID0gd2luZG93LmlubmVyV2lkdGggLyBERUZBVUxUX0RFU0lHTl9XSURUSFxuY29uc3QgREVGQVVMVF9ST09UX0lEID0gJ3dlZXgnXG5jb25zdCBERUZBVUxUX0pTT05QX0NBTExCQUNLX05BTUUgPSAnd2VleEpzb25wQ2FsbGJhY2snXG5cbmdsb2JhbC5XWEVudmlyb25tZW50ID0ge1xuICB3ZWV4VmVyc2lvbjogY29uZmlnLndlZXhWZXJzaW9uLFxuICBhcHBOYW1lOiBsaWIuZW52LmFsaWFwcCA/IGxpYi5lbnYuYWxpYXBwLmFwcG5hbWUgOiBudWxsLFxuICBhcHBWZXJzaW9uOiBsaWIuZW52LmFsaWFwcCA/IGxpYi5lbnYuYWxpYXBwLnZlcnNpb24udmFsIDogbnVsbCxcbiAgcGxhdGZvcm06ICdXZWInLFxuICBvc05hbWU6IGxpYi5lbnYuYnJvd3NlciA/IGxpYi5lbnYuYnJvd3Nlci5uYW1lIDogbnVsbCxcbiAgb3NWZXJzaW9uOiBsaWIuZW52LmJyb3dzZXIgPyBsaWIuZW52LmJyb3dzZXIudmVyc2lvbi52YWwgOiBudWxsLFxuICBkZXZpY2VXaWR0aDogREVGQVVMVF9ERVNJR05fV0lEVEgsXG4gIGRldmljZUhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC8gREVGQVVMVF9TQ0FMRVxufVxuXG5jb25zdCBfd2VleEluc3RhbmNlID0ge31cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG47IChmdW5jdGlvbiBpbml0aWFsaXplV2l0aFVybFBhcmFtcyAoKSB7XG4gIC8vIGluIGNhc3BlcmpzIHRoZSBwcm90b2NvbCBpcyBmaWxlLlxuICBpZiAobG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL2ZpbGUvKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcGFyYW1zID0gbGliLmh0dHB1cmwobG9jYXRpb24uaHJlZikucGFyYW1zXG5cbiAgLy8gc2V0IGdsb2JhbCAnZGVidWcnIGNvbmZpZyB0byB0cnVlIGlmIHRoZXJlJ3MgYSBkZWJ1ZyBmbGFnIGluIGN1cnJlbnQgdXJsLlxuICBjb25zdCBkZWJ1ZyA9IHBhcmFtc1snZGVidWcnXVxuICBpZiAoZGVidWcgPT09IHRydWUgfHwgZGVidWcgPT09ICd0cnVlJykge1xuICAgIGNvbmZpZy5kZWJ1ZyA9IHRydWVcbiAgfVxuXG4gICFjb25maWcuZGVidWcgJiYgKGNvbnNvbGUuZGVidWcgPSBub29wKVxufSkoKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXZWV4IChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXZWV4KSkge1xuICAgIHJldHVybiBuZXcgV2VleChvcHRpb25zKVxuICB9XG5cbiAgLy8gV2lkdGggb2YgdGhlIHJvb3QgY29udGFpbmVyLiBEZWZhdWx0IGlzIHdpbmRvdy5pbm5lcldpZHRoLlxuICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aFxuICB0aGlzLmJ1bmRsZVVybCA9IG9wdGlvbnMuYnVuZGxlVXJsIHx8IGxvY2F0aW9uLmhyZWZcbiAgdGhpcy5pbnN0YW5jZUlkID0gb3B0aW9ucy5hcHBJZFxuICB0aGlzLnJvb3RJZCA9IG9wdGlvbnMucm9vdElkIHx8IChERUZBVUxUX1JPT1RfSUQgKyB1dGlscy5nZXRSYW5kb20oMTApKVxuICB0aGlzLmRlc2lnbldpZHRoID0gb3B0aW9ucy5kZXNpZ25XaWR0aCB8fCBERUZBVUxUX0RFU0lHTl9XSURUSFxuICB0aGlzLmpzb25wQ2FsbGJhY2sgPSBvcHRpb25zLmpzb25wQ2FsbGJhY2sgfHwgREVGQVVMVF9KU09OUF9DQUxMQkFDS19OQU1FXG4gIHRoaXMuc291cmNlID0gb3B0aW9ucy5zb3VyY2VcbiAgdGhpcy5sb2FkZXIgPSBvcHRpb25zLmxvYWRlclxuICB0aGlzLmVtYmVkID0gb3B0aW9ucy5lbWJlZFxuXG4gIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YVxuICB0aGlzLnNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuZGVzaWduV2lkdGhcbiAgcmVjZWl2ZXIuaW5pdCh0aGlzKVxuICB0aGlzLnNlbmRlciA9IG5ldyBTZW5kZXIodGhpcylcblxuICBfd2VleEluc3RhbmNlW3RoaXMuaW5zdGFuY2VJZF0gPSB0aGlzXG5cbiAgLy8gbG9hZCBidW5kbGUuXG4gIGxvYWQoe1xuICAgIGpzb25wQ2FsbGJhY2s6IHRoaXMuanNvbnBDYWxsYmFjayxcbiAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgIGxvYWRlcjogdGhpcy5sb2FkZXJcbiAgfSwgZnVuY3Rpb24gKGVyciwgYXBwQ29kZSkge1xuICAgIGlmICghZXJyKSB7XG4gICAgICB0aGlzLmNyZWF0ZUFwcChjb25maWcsIGFwcENvZGUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignbG9hZCBidW5kbGUgZXJyOicsIGVycilcbiAgICB9XG4gIH0uYmluZCh0aGlzKSlcbn1cblxuV2VleC5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKHV0aWxzLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgbmV3IFdlZXgoY29uZmlnKVxuICAgIH0pXG4gIH1cbiAgZWxzZSBpZiAodXRpbHMuZ2V0VHlwZShvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXcgV2VleChvcHRpb25zKVxuICB9XG59XG5cbldlZXguZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICByZXR1cm4gX3dlZXhJbnN0YW5jZVtpbnN0YW5jZUlkXVxufVxuXG5XZWV4LnByb3RvdHlwZSA9IHtcblxuICBjcmVhdGVBcHA6IGZ1bmN0aW9uIChjb25maWcsIGFwcENvZGUpIHtcbiAgICBsZXQgcm9vdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5yb290SWQpXG4gICAgaWYgKCFyb290KSB7XG4gICAgICByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHJvb3QuaWQgPSB0aGlzLnJvb3RJZFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyb290KVxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gd2luZG93LmNyZWF0ZUluc3RhbmNlKFxuICAgICAgdGhpcy5pbnN0YW5jZUlkLFxuICAgICAgYXBwQ29kZSxcbiAgICAgIHtcbiAgICAgICAgYnVuZGxlVXJsOiB0aGlzLmJ1bmRsZVVybCxcbiAgICAgICAgZGVidWc6IGNvbmZpZy5kZWJ1Z1xuICAgICAgfSxcbiAgICAgIHRoaXMuZGF0YVxuICAgIClcblxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBjcmVhdGVJbnN0YW5jZSBlcnJvcjogZ2V0IHZvaWQgZm9yIGluc3RhbmNlLicpXG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXScsIGluc3RhbmNlKVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdGhpcy5hcHBJbnN0YW5jZSA9IHJlc1xuICAgICAgICAvLyBXZWV4Ll9pbnN0YW5jZXNbdGhpcy5pbnN0YW5jZUlkXSA9IHRoaXMucm9vdFxuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXScsIGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5hcHBJbnN0YW5jZSA9IGluc3RhbmNlXG5cbiAgICAvLyBEbyBub3QgZGVzdHJveSBpbnN0YW5jZSBiZWZvcmUgdW5sb2FkLCBiZWNhdXNlIGluIG1vc3QgYnJvd3NlclxuICAgIC8vIHByZXNzIGJhY2sgYnV0dG9uIHRvIGJhY2sgdG8gdGhpcyBwYWdlIHdpbGwgbm90IHJlZnJlc2hcbiAgICAvLyB0aGUgd2luZG93IGFuZCB0aGUgaW5zdGFuY2Ugd2lsbCBub3QgYmUgcmVjcmVhdGVkIHRoZW4uXG4gICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gfSlcbiAgfSxcblxuICBnZXRDb21wb25lbnRNYW5hZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb25lbnRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRNYW5hZ2VyID0gQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZSh0aGlzLmluc3RhbmNlSWQpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRNYW5hZ2VyXG4gIH0sXG5cbiAgZ2V0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMucm9vdElkKVxuICB9XG59XG5cbldlZXguc3RvcFRoZVdvcmxkID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHtcbiAgaWYgKCFpbnN0YW5jZUlkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF93ZWV4SW5zdGFuY2UpLm1hcChmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICAgICAgV2VleC5zdG9wVGhlV29ybGQoaW5zdGFuY2VJZClcbiAgICB9KVxuICB9XG4gIHdpbmRvdy5kZXN0cm95SW5zdGFuY2UoaW5zdGFuY2VJZClcbn1cblxuLy8gZm9yIHdlZXgtdG9vbGtpdC5cbjsgKGZ1bmN0aW9uIHN0YXJ0UmVmcmVzaENvbnRyb2xsZXIgKCkge1xuICBpZiAobG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL2ZpbGUvKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChsb2NhdGlvbi5zZWFyY2guaW5kZXhPZignaG90LXJlbG9hZF9jb250cm9sbGVyJykgPT09IC0xKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBXZWJTb2NrZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5pbmZvKCdhdXRvIHJlZnJlc2ggbmVlZCBXZWJTb2NrZXQgc3VwcG9ydCcpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgaG9zdCA9IGxvY2F0aW9uLmhvc3RuYW1lXG4gIGNvbnN0IHBvcnQgPSA4MDgyXG4gIGNvbnN0IGNsaWVudCA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vJyArIGhvc3QgKyAnOicgKyBwb3J0ICsgJy8nLFxuICAgICdlY2hvLXByb3RvY29sJ1xuICApXG4gIGNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdyZWZyZXNoIGNvbnRyb2xsZXIgd2Vic29ja2V0IGNvbm5lY3Rpb24gZXJyb3InKVxuICB9XG4gIGNsaWVudC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZDogXFwnJyArIGUuZGF0YSArICdcXCcnKVxuICAgIGlmIChlLmRhdGEgPT09ICdyZWZyZXNoJykge1xuICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gIH1cbn0pKClcblxuYmluZFJlZ2lzdGVyKFdlZXgpXG5cbnV0aWxzLmV4dGVuZChXZWV4LCB7XG4gIENvbXBvbmVudCxcbiAgQXRvbWljLFxuICBDb21wb25lbnRNYW5hZ2VyLFxuICB1dGlscyxcbiAgY29uZmlnXG59KVxuXG5nbG9iYWwud2VleCA9IFdlZXhcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYmFzZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL3JlbmRlci9zdHlsZS9iYXNlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiKiB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgdGV4dC1zaXplLWFkanVzdDogbm9uZTtcXG59XFxuXFxudWwsIG9sIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbi53ZWV4LWNvbnRhaW5lciB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LXNocmluazogMDtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgYm94LWFsaWduOiBzdHJldGNoO1xcbiAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlcjogMCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtaW4td2lkdGg6IDA7XFxufVxcblxcbi53ZWV4LWVsZW1lbnQge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbiAgYm9yZGVyOiAwIHNvbGlkIGJsYWNrO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG1pbi13aWR0aDogMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL3N0eWxlL2Jhc2UuY3NzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAnLi9zaGFyZWQnXG4vLyBpbXBvcnQgaW5pdCBmcm9tICcuLi8uLi9ydW50aW1lL2luaXQnXG5pbXBvcnQgaW5pdCBmcm9tICcuL2luaXQnXG5pbXBvcnQgZnJhbWV3b3JrcyBmcm9tICcuL2NvbmZpZydcbmltcG9ydCB7IERvY3VtZW50LCBFbGVtZW50LCBDb21tZW50IH0gZnJvbSAnLi4vLi4vdmRvbSdcbi8vIGltcG9ydCB7IHN1YnZlcnNpb24gfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlLmpzb24nXG5pbXBvcnQgKiBhcyBtZXRob2RzIGZyb20gJy4uLy4uL2RlZmF1bHQvYXBpL21ldGhvZHMnXG5pbXBvcnQgTGlzdGVuZXIgZnJvbSAnLi4vZG9tL2NvbXBvbmVudE1hbmFnZXInXG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgRG9jdW1lbnQsIEVsZW1lbnQsIENvbW1lbnQsIExpc3RlbmVyLCBmcmFtZXdvcmtzLFxuICBzZW5kVGFza3MgKC4uLmFyZ3MpIHtcbiAgICBnbG9iYWwuY2FsbE5hdGl2ZSguLi5hcmdzKVxuICB9XG59XG5cbmNvbnN0IHJ1bnRpbWUgPSBpbml0KGNvbmZpZylcblxuLy8gY29uc3QgeyBuYXRpdmUsIHRyYW5zZm9ybWVyIH0gPSBzdWJ2ZXJzaW9uXG5cbmZvciAoY29uc3QgbWV0aG9kTmFtZSBpbiBydW50aW1lKSB7XG4gIGdsb2JhbFttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0gcnVudGltZVttZXRob2ROYW1lXSguLi5hcmdzKVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihyZXQudG9TdHJpbmcoKSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbi8vIGdsb2JhbC5mcmFtZXdvcmtWZXJzaW9uID0gbmF0aXZlXG4vLyBnbG9iYWwudHJhbnNmb3JtVmVyc2lvbiA9IHRyYW5zZm9ybWVyXG5cbi8qKlxuICogcmVnaXN0ZXIgbWV0aG9kc1xuICovXG5nbG9iYWwucmVnaXN0ZXJNZXRob2RzKG1ldGhvZHMpXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0ICcuLi8uLi9zaGFyZWQvcHJvbWlzZSdcbi8vIGltcG9ydCAnLi4vLi4vc2hhcmVkL2NvbnNvbGUnXG5cbmV4cG9ydCB7XG4gIGV4dGVuZCxcbiAgZGVmLFxuICByZW1vdmUsXG4gIGhhc093bixcbiAgYmluZCxcbiAgdG9BcnJheSxcbiAgaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Rcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvc2hhcmVkLmpzXG4gKiovIiwiLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQgKHRhcmdldCwgLi4uc3JjKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zcmMpXG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgZmlyc3QgPSBzcmMuc2hpZnQoKVxuICAgIGZvciAoY29uc3Qga2V5IGluIGZpcnN0KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGZpcnN0W2tleV1cbiAgICB9XG4gICAgaWYgKHNyYy5sZW5ndGgpIHtcbiAgICAgIGV4dGVuZCh0YXJnZXQsIC4uLnNyYylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnVtZXJhYmxlXVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHsqfSBpdGVtXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBsZXQgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnRcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGkpXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF1cbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5jb25zdCBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSdcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklOR1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9zaGFyZWQvdXRpbHMuanNcbiAqKi8iLCIvLyBmaXggUHJvbWlzZSBQcm9ibGVtIG9uIEpTQ29udGV4dCBvZiBpT1M3fjhcbi8vIEBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNTg2NlxuLy8gZ2xvYmFsLlByb21pc2UgPSBudWxsXG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKVxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKVxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKVxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlJylcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvc2hhcmVkL3Byb21pc2UuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgdGVzdCAgICA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZih0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL193a3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KVxuICAgICwga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldClyZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KWV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XHJcbiAgYW5PYmplY3QoTyk7XHJcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcclxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICwgaSA9IDBcclxuICAgICwgUDtcclxuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XHJcbiAgcmV0dXJuIE87XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxyXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXHJcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xyXG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIHJlc3VsdCA9IFtdXHJcbiAgICAsIGtleTtcclxuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xyXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcclxuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXHJcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcclxubW9kdWxlLmV4cG9ydHMgPSAoXHJcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcclxuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcclxuICBPID0gdG9PYmplY3QoTyk7XHJcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XHJcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpXG4gICwgQXJyYXlQcm90byAgPSBBcnJheS5wcm90b3R5cGU7XG5pZihBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcclxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXHJcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxyXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXHJcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcblxyXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcclxuICBPID0gdG9JT2JqZWN0KE8pO1xyXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcclxuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xyXG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XHJcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxyXG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZShoZWFkKXtcbiAgICAgIGZuICAgPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICBpZihoZWFkKW5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmKGlzTm9kZSl7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gICAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmKCFoZWFkKXtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImxldCBmcmFtZXdvcmtzXG5cbmNvbnN0IHZlcnNpb25SZWdFeHAgPSAvXlxcL1xcLyAqKFxce1teXFx9XSpcXH0pICpcXHI/XFxuL1xuXG5mdW5jdGlvbiBjaGVja1ZlcnNpb24gKGNvZGUpIHtcbiAgbGV0IGluZm9cbiAgY29uc3QgcmVzdWx0ID0gdmVyc2lvblJlZ0V4cC5leGVjKGNvZGUpXG4gIGlmIChyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgaW5mbyA9IEpTT04ucGFyc2UocmVzdWx0WzFdKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gaW5mb1xufVxuXG5jb25zdCBpbnN0YW5jZU1hcCA9IHt9XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlIChpZCwgY29kZSwgY29uZmlnLCBkYXRhKSB7XG4gIGxldCBpbmZvID0gaW5zdGFuY2VNYXBbaWRdXG4gIGlmICghaW5mbykge1xuICAgIGluZm8gPSBjaGVja1ZlcnNpb24oY29kZSkgfHwge31cbiAgICBpZiAoIWZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdKSB7XG4gICAgICBpbmZvLmZyYW1ld29yayA9ICdXZWV4J1xuICAgIH1cbiAgICBpbnN0YW5jZU1hcFtpZF0gPSBpbmZvXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9XG4gICAgY29uZmlnLmJ1bmRsZVZlcnNpb24gPSBpbmZvLnZlcnNpb25cbiAgICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBjcmVhdGUgYW4gJHtpbmZvLmZyYW1ld29ya31AJHtjb25maWcuYnVuZGxlVmVyc2lvbn0gaW5zdGFuY2UgZnJvbSAke2NvbmZpZy5idW5kbGVWZXJzaW9ufWApXG4gICAgcmV0dXJuIGZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdLmNyZWF0ZUluc3RhbmNlKGlkLCBjb2RlLCBjb25maWcsIGRhdGEpXG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aWR9XCJgKVxufVxuXG5jb25zdCBtZXRob2RzID0ge1xuICBjcmVhdGVJbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBnZW5Jbml0IChtZXRob2ROYW1lKSB7XG4gIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBmcmFtZXdvcmtzKSB7XG4gICAgICBjb25zdCBmcmFtZXdvcmsgPSBmcmFtZXdvcmtzW25hbWVdXG4gICAgICBpZiAoZnJhbWV3b3JrICYmIGZyYW1ld29ya1ttZXRob2ROYW1lXSkge1xuICAgICAgICBmcmFtZXdvcmtbbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5zdGFuY2UgKG1ldGhvZE5hbWUpIHtcbiAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSBhcmdzWzBdXG4gICAgY29uc3QgaW5mbyA9IGluc3RhbmNlTWFwW2lkXVxuICAgIGlmIChpbmZvICYmIGZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdKSB7XG4gICAgICByZXR1cm4gZnJhbWV3b3Jrc1tpbmZvLmZyYW1ld29ya11bbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aWR9XCJgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkYXB0SW5zdGFuY2UgKG1ldGhvZE5hbWUsIG5hdGl2ZU1ldGhvZE5hbWUpIHtcbiAgbWV0aG9kc1tuYXRpdmVNZXRob2ROYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSBhcmdzWzBdXG4gICAgY29uc3QgaW5mbyA9IGluc3RhbmNlTWFwW2lkXVxuICAgIGlmIChpbmZvICYmIGZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdKSB7XG4gICAgICByZXR1cm4gZnJhbWV3b3Jrc1tpbmZvLmZyYW1ld29ya11bbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aWR9XCJgKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXQgKGNvbmZpZykge1xuICBmcmFtZXdvcmtzID0gY29uZmlnLmZyYW1ld29ya3NcbiAgZm9yIChjb25zdCBuYW1lIGluIGZyYW1ld29ya3MpIHtcbiAgICBjb25zdCBmcmFtZXdvcmsgPSBmcmFtZXdvcmtzW25hbWVdXG4gICAgZnJhbWV3b3JrLmluaXQoY29uZmlnKVxuICB9XG5cbiAgOyBbJ2Rlc3Ryb3lJbnN0YW5jZScsICdyZWZyZXNoSW5zdGFuY2UnLCAncmVjZWl2ZVRhc2tzJywgJ2dldFJvb3QnXS5mb3JFYWNoKGdlbkluc3RhbmNlKVxuXG4gIDsgWydyZWdpc3RlckNvbXBvbmVudHMnLCAncmVnaXN0ZXJNb2R1bGVzJywgJ3JlZ2lzdGVyTWV0aG9kcyddLmZvckVhY2goZ2VuSW5pdClcblxuICBhZGFwdEluc3RhbmNlKCdyZWNlaXZlVGFza3MnLCAnY2FsbEpTJylcblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvaW5pdC5qc1xuICoqLyIsIi8vIGJ1aWx0IGJ5IG5wbSBydW4gYnVpbGQ6Y29uZmlnXG5cbmltcG9ydCAqIGFzIFdlZXggZnJvbSAnLi9kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFdlZXhcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2NvbmZpZy5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlldyBNYWluIGVudHJ5LCBpbnN0YW5jZSBtYW5hZ2VyXG4gKlxuICogLSBjcmVhdGVJbnN0YW5jZShpbnN0YW5jZUlkLCBjb2RlLCBvcHRpb25zLCBkYXRhKVxuICogLSByZWZyZXNoSW5zdGFuY2UoaW5zdGFuY2VJZCwgZGF0YSlcbiAqIC0gZGVzdHJveUluc3RhbmNlKGluc3RhbmNlSWQpXG4gKiAtIHJlZ2lzdGVyQ29tcG9uZW50cyhjb21wb25lbnRzKVxuICogLSByZWdpc3Rlck1vZHVsZXMobW9kdWxlcylcbiAqIC0gZ2V0Um9vdChpbnN0YW5jZUlkKVxuICogLSBpbnN0YW5jZU1hcFxuICogLSBjYWxsSlMoaW5zdGFuY2VJZCwgdGFza3MpXG4gKiAgIC0gZmlyZUV2ZW50KHJlZiwgdHlwZSwgZGF0YSlcbiAqICAgLSBjYWxsYmFjayhmdW5jSWQsIGRhdGEpXG4gKi9cbmV4cG9ydCB7IGNyZWF0ZUluc3RhbmNlIH0gZnJvbSAnLi4vc3RhdGljL2NyZWF0ZSdcbmV4cG9ydCB7IGluaXQsIHJlZnJlc2hJbnN0YW5jZSwgZGVzdHJveUluc3RhbmNlIH0gZnJvbSAnLi4vLi4vLi4vZGVmYXVsdC9zdGF0aWMvbGlmZSdcbmV4cG9ydCB7IHJlZ2lzdGVyQ29tcG9uZW50cywgcmVnaXN0ZXJNb2R1bGVzLCByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi8uLi9kZWZhdWx0L3N0YXRpYy9yZWdpc3RlcidcbmV4cG9ydCB7IHJlY2VpdmVUYXNrcyB9IGZyb20gJy4uLy4uLy4uL2RlZmF1bHQvc3RhdGljL2JyaWRnZSdcbmV4cG9ydCB7IGdldFJvb3QgfSBmcm9tICcuLi8uLi8uLi9kZWZhdWx0L3N0YXRpYy9taXNjJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvZGVmYXVsdC9pbmRleC5qc1xuICoqLyIsImltcG9ydCBBcHBJbnN0YW5jZSBmcm9tICcuLi9hcHAnXG5pbXBvcnQgeyBpbnN0YW5jZU1hcCB9IGZyb20gJy4uLy4uLy4uL2RlZmF1bHQvc3RhdGljL21hcCdcblxuLyoqXG4gKiBjcmVhdGUgYSBXZWV4IGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvZGVcbiAqIEBwYXJhbSAge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbiBgSEFTX0xPR2AgZW5hYmxlIHByaW50IGxvZ1xuICogQHBhcmFtICB7b2JqZWN0fSBbZGF0YV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlIChpbnN0YW5jZUlkLCBjb2RlLCBvcHRpb25zLCBkYXRhKSB7XG4gIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IHJlc3VsdFxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgQXBwSW5zdGFuY2UoaW5zdGFuY2VJZCwgb3B0aW9ucylcbiAgICBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXSA9IGluc3RhbmNlXG4gICAgcmVzdWx0ID0gaW5zdGFuY2UuaW5pdChjb2RlLCBkYXRhKVxuICB9XG4gIGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0IHx8IGluc3RhbmNlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9zdGF0aWMvY3JlYXRlLmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBXZWV4IGluc3RhbmNlIGNvbnN0cnVjdG9yICYgZGVmaW5pdGlvblxuICovXG5pbXBvcnQgKiBhcyBjdHJsIGZyb20gJy4vY3RybCdcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IEFwcEluc3RhbmNlIGZyb20gJy4uLy4uLy4uL2RlZmF1bHQvYXBwL2luc3RhbmNlJ1xuXG5leHRlbmQoQXBwSW5zdGFuY2UucHJvdG90eXBlLCBjdHJsKVxuXG5leHBvcnQgZGVmYXVsdCBBcHBJbnN0YW5jZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvYXBwL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBpbnN0YW5jZSBjb250cm9scyBmcm9tIG5hdGl2ZVxuICpcbiAqIC0gaW5pdCBidW5kbGVcbiAqIC0gZmlyZSBldmVudFxuICogLSBjYWxsYmFja1xuICogLSBkZXN0cm95XG4gKlxuICogY29ycmVzcG9uZGVkIHdpdGggdGhlIEFQSSBvZiBpbnN0YW5jZSBtYW5hZ2VyIChmcmFtZXdvcmsuanMpXG4gKi9cbmV4cG9ydCB7IGluaXQgfSBmcm9tICcuL2luaXQnXG5cbmV4cG9ydCB7XG5cdHVwZGF0ZUFjdGlvbnMsXG4gIGRlc3Ryb3ksXG4gIGdldFJvb3RFbGVtZW50LFxuICBmaXJlRXZlbnQsXG4gIGNhbGxiYWNrLFxuICByZWZyZXNoRGF0YVxufSBmcm9tICcuLi8uLi8uLi8uLi9kZWZhdWx0L2FwcC9jdHJsL21pc2MnXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvY3RybC9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogaW5zdGFuY2UgY29udHJvbHMgZnJvbSBuYXRpdmVcbiAqXG4gKiAtIGluaXQgYnVuZGxlXG4gKiAtIGZpcmUgZXZlbnRcbiAqIC0gY2FsbGJhY2tcbiAqIC0gZGVzdHJveVxuICpcbiAqIGNvcnJlc3BvbmRlZCB3aXRoIHRoZSBBUEkgb2YgaW5zdGFuY2UgbWFuYWdlciAoZnJhbWV3b3JrLmpzKVxuICovXG5cbmltcG9ydCB7IGJpbmQgfSBmcm9tICcuLi8uLi8uLi91dGlscydcblxuaW1wb3J0IHtcbiAgZGVmaW5lLFxuICBib290c3RyYXAsXG4gIHJlZ2lzdGVyXG59IGZyb20gJy4uL2J1bmRsZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQgKGNvZGUsIGRhdGEpIHtcbiAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gSW50aWFsaXplIGFuIGluc3RhbmNlIHdpdGg6XFxuJywgZGF0YSlcblxuICBsZXQgcmVzdWx0XG4gIC8vIEBzZWU6IGxpYi9hcHAvYnVuZGxlLmpzXG4gIGNvbnN0IGJ1bmRsZURlZmluZSA9IGJpbmQoZGVmaW5lLCB0aGlzKVxuICBjb25zdCBidW5kbGVCb290c3RyYXAgPSAobmFtZSwgY29uZmlnLCBfZGF0YSkgPT4ge1xuICAgIHJlc3VsdCA9IGJvb3RzdHJhcCh0aGlzLCBuYW1lLCBjb25maWcsIF9kYXRhIHx8IGRhdGEpXG4gICAgdGhpcy51cGRhdGVBY3Rpb25zKClcbiAgICB0aGlzLmRvYy5saXN0ZW5lci5jcmVhdGVGaW5pc2goKVxuICAgIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIEFmdGVyIGludGlhbGl6ZWQgYW4gaW5zdGFuY2UoJHt0aGlzLmlkfSlgKVxuICB9XG5cbiAgLy8gYmFja3dhcmQocmVnaXN0ZXIvcmVuZGVyKVxuICBjb25zdCBidW5kbGVSZWdpc3RlciA9IGJpbmQocmVnaXN0ZXIsIHRoaXMpXG4gIGNvbnN0IGJ1bmRsZVJlbmRlciA9IChuYW1lLCBfZGF0YSkgPT4ge1xuICAgIHJlc3VsdCA9IGJvb3RzdHJhcCh0aGlzLCBuYW1lLCB7fSwgX2RhdGEpXG4gIH1cblxuICBjb25zdCBidW5kbGVSZXF1aXJlID0gbmFtZSA9PiBfZGF0YSA9PiB7XG4gICAgcmVzdWx0ID0gYm9vdHN0cmFwKHRoaXMsIG5hbWUsIHt9LCBfZGF0YSlcbiAgfVxuXG4gIGNvbnN0IGJ1bmRsZURvY3VtZW50ID0gdGhpcy5kb2NcblxuICBsZXQgZnVuY3Rpb25Cb2R5XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBgZnVuY3Rpb24gKCkgey4uLn1gIC0+IGB7Li4ufWBcbiAgICAvLyBub3QgdmVyeSBzdHJpY3RcbiAgICBmdW5jdGlvbkJvZHkgPSBjb2RlLnRvU3RyaW5nKCkuc3Vic3RyKDEyKVxuICB9XG4gIGVsc2UgaWYgKGNvZGUpIHtcbiAgICBmdW5jdGlvbkJvZHkgPSBjb2RlLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNvbnN0IHsgV1hFbnZpcm9ubWVudCB9ID0gZ2xvYmFsXG5cbiAgaWYgKFdYRW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbihcbiAgICAgICdkZWZpbmUnLFxuICAgICAgJ3JlcXVpcmUnLFxuICAgICAgJ2RvY3VtZW50JyxcbiAgICAgICdib290c3RyYXAnLFxuICAgICAgJ3JlZ2lzdGVyJyxcbiAgICAgICdyZW5kZXInLFxuICAgICAgJ19fd2VleF9kZWZpbmVfXycsIC8vIGFsaWFzIGZvciBkZWZpbmVcbiAgICAgICdfX3dlZXhfYm9vdHN0cmFwX18nLCAvLyBhbGlhcyBmb3IgYm9vdHN0cmFwXG4gICAgICBmdW5jdGlvbkJvZHlcbiAgICApXG5cbiAgICBmbihcbiAgICAgIGJ1bmRsZURlZmluZSxcbiAgICAgIGJ1bmRsZVJlcXVpcmUsXG4gICAgICBidW5kbGVEb2N1bWVudCxcbiAgICAgIGJ1bmRsZUJvb3RzdHJhcCxcbiAgICAgIGJ1bmRsZVJlZ2lzdGVyLFxuICAgICAgYnVuZGxlUmVuZGVyLFxuICAgICAgYnVuZGxlRGVmaW5lLFxuICAgICAgYnVuZGxlQm9vdHN0cmFwKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvYXBwL2N0cmwvaW5pdC5qc1xuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuXG4ndXNlIHN0cmljdCdcblxuLy8gY29uc3QgV0VBUFBfU1RZTEVfSUQgPSAnd2VhcHAtc3R5bGUnXG5cbmltcG9ydCBmcmFtZVVwZGF0ZXIgZnJvbSAnLi9mcmFtZVVwZGF0ZXInXG5leHBvcnQgeyBmcmFtZVVwZGF0ZXIgfVxuXG5leHBvcnQge1xuICBleHRlbmQsXG4gIGRlZixcbiAgcmVtb3ZlLFxuICBoYXNPd24sXG4gIGJpbmQsXG4gIHRvQXJyYXksXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICB0eXBvZlxufSBmcm9tICcuLi8uLi9kZWZhdWx0L3V0aWwnXG5cbmltcG9ydCB7IGlzQXJyYXksIHNsaWNlIH0gZnJvbSAnLi9hcnJheSdcbmV4cG9ydCB7IGlzQXJyYXksIHNsaWNlIH1cblxuZXhwb3J0IGNvbnN0IHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddXG5cbmxldCBfaXNXZWJwU3VwcG9ydGVkID0gZmFsc2VcblxuOyAoZnVuY3Rpb24gaXNTdXBwb3J0V2VicCAoKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgd2ViUCA9IG5ldyBJbWFnZSgpXG4gICAgd2ViUC5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmpvQUFBQlhSVUpRVmxBNElDNEFBQUN5QWdDZEEnXG4gICAgICAgICAgICAgICsgJ1NvQ0FBSUFMbWswbWswaUlpSWlJZ0JvU3lnQUJjNldXZ0FBL3ZlZmYvMFBQOGJBLy9Md1lBQUEnXG4gICAgd2ViUC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod2ViUC5oZWlnaHQgPT09IDIpIHtcbiAgICAgICAgX2lzV2VicFN1cHBvcnRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nLlxuICB9XG59KSgpXG5cbmxldCBfaXNTdGlja3lTdXBwb3J0ZWQgPSBmYWxzZVxuXG47IChmdW5jdGlvbiBpc1N1cHBvcnRTdGlja3kgKCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29uc3QgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZVxuICBlbGVtZW50U3R5bGUuY3NzVGV4dCA9IHZlbmRvcnMuY29uY2F0KFsnJ10pLm1hcChmdW5jdGlvbiAodmVuZG9yKSB7XG4gICAgcmV0dXJuICdwb3NpdGlvbjonXG4gICAgICArICh2ZW5kb3IgPyAnLScgKyB2ZW5kb3IgKyAnLScgOiAnJylcbiAgICAgICsgJ3N0aWNreSdcbiAgfSkuam9pbignOycpICsgJzsnXG4gIF9pc1N0aWNreVN1cHBvcnRlZCA9IGVsZW1lbnRTdHlsZS5wb3NpdGlvbi5pbmRleE9mKCdzdGlja3knKSAhPT0gLTFcbn0pKClcblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCAodG8sIGZyb20pIHtcbi8vICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuLy8gICAgIHRvW2tleV0gPSBmcm9tW2tleV1cbi8vICAgfVxuLy8gICByZXR1cm4gdG9cbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuLy8gICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iailcbi8vICAgICAuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnXG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXG4gICAgLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRTdHlsZSAoY3NzLCBzdHlsZUlkLCByZXBsYWNlKSB7XG4gIGxldCBzdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlSWQpXG4gIGlmIChzdHlsZSAmJiByZXBsYWNlKSB7XG4gICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSlcbiAgICBzdHlsZSA9IG51bGxcbiAgfVxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2NzcydcbiAgICBzdHlsZUlkICYmIChzdHlsZS5pZCA9IHN0eWxlSWQpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSlcbiAgfVxuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlRnJvbUFycmF5IChhcnIpIHtcbiAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBjb25zdCByZXMgPSBbXVxuICBjb25zdCB1bmlxdWUgPSB7fVxuICBsZXQgdmFsXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhbCA9IGFycltpXVxuICAgIGlmICh1bmlxdWVbdmFsXSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdW5pcXVlW3ZhbF0gPSB0cnVlXG4gICAgcmVzLnB1c2godmFsKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFdlYnAgKCkge1xuICByZXR1cm4gX2lzV2VicFN1cHBvcnRlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0U3RpY2t5ICgpIHtcbiAgcmV0dXJuIF9pc1N0aWNreVN1cHBvcnRlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tIChudW0pIHtcbiAgY29uc3QgX2RlZmF1bHROdW0gPSAxMFxuICBpZiAodHlwZW9mIG51bSAhPT0gJ251bWJlcicgfHwgbnVtIDw9IDApIHtcbiAgICBudW0gPSBfZGVmYXVsdE51bVxuICB9XG4gIGNvbnN0IF9tYXggPSBNYXRoLnBvdygxMCwgbnVtKVxuICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgTWF0aC5yYW5kb20oKSAqIF9tYXgpICUgX21heFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmdiIChjb2xvcikge1xuICBsZXQgbWF0Y2hcbiAgY29sb3IgPSBjb2xvciArICcnXG4gIG1hdGNoID0gY29sb3IubWF0Y2goLyMoW1xcZGEtZkEtRl17Mn0pKFtcXGRhLWZBLUZdezJ9KShbXFxkYS1mQS1GXXsyfSkvKVxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnQobWF0Y2hbMV0sIDE2KSxcbiAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdLCAxNiksXG4gICAgICBiOiBwYXJzZUludChtYXRjaFszXSwgMTYpXG4gICAgfVxuICB9XG4gIG1hdGNoID0gY29sb3IubWF0Y2goL3JnYlxcKChcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKylcXCkvKVxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgICAgZzogcGFyc2VJbnQobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnQobWF0Y2hbM10pXG4gICAgfVxuICB9XG59XG5cbi8vIGRpcmVjdGlvbjogJ2wnIHwgJ3InLCBkZWZhdWx0IGlzICdyJ1xuLy8gbnVtOiBob3cgbWFueSB0aW1lcyB0byBsb29wLCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG5leHBvcnQgZnVuY3Rpb24gbG9vcEFycmF5IChhcnIsIG51bSwgZGlyZWN0aW9uKSB7XG4gIGlmICghaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IGlzTGVmdCA9IChkaXJlY3Rpb24gKyAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ2wnXG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGhcbiAgbnVtID0gbnVtICUgbGVuXG4gIGlmIChudW0gPCAwKSB7XG4gICAgbnVtID0gLW51bVxuICAgIGlzTGVmdCA9ICFpc0xlZnRcbiAgfVxuICBpZiAobnVtID09PSAwKSB7XG4gICAgcmV0dXJuIGFyclxuICB9XG4gIGxldCBscCwgcnBcbiAgaWYgKGlzTGVmdCkge1xuICAgIGxwID0gYXJyLnNsaWNlKDAsIG51bSlcbiAgICBycCA9IGFyci5zbGljZShudW0pXG4gIH1cbiAgZWxzZSB7XG4gICAgbHAgPSBhcnIuc2xpY2UoMCwgbGVuIC0gbnVtKVxuICAgIHJwID0gYXJyLnNsaWNlKGxlbiAtIG51bSlcbiAgfVxuICByZXR1cm4gcnAuY29uY2F0KGxwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUgKGZ1bmMsIHdhaXQpIHtcbiAgbGV0IHJlc3VsdFxuICBsZXQgdGltZXJJZCA9IG51bGxcbiAgbGV0IHByZXZpb3VzID0gMFxuICBsZXQgY29udGV4dFxuICBsZXQgYXJnc1xuICBjb25zdCBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmV2aW91cyA9IERhdGUubm93KClcbiAgICB0aW1lcklkID0gbnVsbFxuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKVxuICAgIGNvbnRleHQgPSB0aGlzXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKVxuICAgICAgdGltZXJJZCA9IG51bGxcbiAgICAgIHByZXZpb3VzID0gbm93XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aW1lcklkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci91dGlscy9pbmRleC5qc1xuICoqLyIsImV4cG9ydCB7XG4gIGV4dGVuZCxcbiAgZGVmLFxuICByZW1vdmUsXG4gIGhhc093bixcbiAgYmluZCxcbiAgdG9BcnJheSxcbiAgaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Rcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzJ1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICBjb25zdCBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApXG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5leHBvcnQgY29uc3QgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fVxuXG5sZXQgX1NldFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgU2V0LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLykpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXRcbn1cbmVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH1cbiAgX1NldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldFtrZXldICE9PSB1bmRlZmluZWRcbiAgfVxuICBfU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5zZXRba2V5XSA9IDFcbiAgfVxuICBfU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgfVxufVxuXG5leHBvcnQgeyBfU2V0IH1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl1cbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZ1xuZXhwb3J0IGNvbnN0IGNhbWVsaXplID0gY2FjaGVkKHN0ciA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCB0b1VwcGVyKVxufSlcblxuZnVuY3Rpb24gdG9VcHBlciAoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnXG59XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuY29uc3QgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZ1xuZXhwb3J0IGNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZChzdHIgPT4ge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBvZiAodikge1xuICBjb25zdCBzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpXG4gIHJldHVybiBzLnN1YnN0cmluZyg4LCBzLmxlbmd0aCAtIDEpLnRvTG93ZXJDYXNlKClcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC91dGlsL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgZnVuY3Rpb24gKGNhbGxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsbGJhY2ssIDE2KVxuICAgICAgICAgIH1cblxubGV0IHJhZklkXG5jb25zdCBvYnNlcnZlcnMgPSBbXVxubGV0IHBhdXNlZCA9IGZhbHNlXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmFmSWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJhZklkID0gcmFmKGZ1bmN0aW9uIHJ1bkxvb3AgKCkge1xuICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlcnNbaV0oKVxuICAgICAgICB9XG4gICAgICAgIHJhZihydW5Mb29wKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXBhdXNlZFxuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gdHJ1ZVxuICAgIHJhZklkID0gdW5kZWZpbmVkXG4gIH0sXG5cbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLnN0YXJ0KClcbiAgfSxcblxuICBhZGRVcGRhdGVPYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVNZXRob2QpIHtcbiAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlTWV0aG9kKVxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci91dGlscy9mcmFtZVVwZGF0ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkgKGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheVxuICAgID8gQXJyYXkuaXNBcnJheShhcnIpXG4gICAgOiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGljZSAoYXJyLCBzdGFydCwgZW5kKSB7XG4gIGlmIChpc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH1cbiAgY29uc3Qgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyLCBzdGFydCwgZW5kKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3V0aWxzL2FycmF5LmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBhcGkgdGhhdCBpbnZva2VkIGJ5IGpzIGJ1bmRsZSBjb2RlXG4gKlxuICogLSBkZWZpbmUobmFtZSwgZmFjdG9yeSk6IGRlZmluZSBhIG5ldyBjb21wb3NlZCBjb21wb25lbnQgdHlwZVxuICogLSBib290c3RyYXAodHlwZSwgY29uZmlnLCBkYXRhKTogcmVxdWlyZSBhIGNlcnRhaW4gdHlwZSAmXG4gKiAgICAgICAgIHJlbmRlciB3aXRoIChvcHRpb25hbCkgZGF0YVxuICpcbiAqIGRlcHJlY2F0ZWQ6XG4gKiAtIHJlZ2lzdGVyKHR5cGUsIG9wdGlvbnMpOiByZWdpc3RlciBhIG5ldyBjb21wb3NlZCBjb21wb25lbnQgdHlwZVxuICogLSByZW5kZXIodHlwZSwgZGF0YSk6IHJlbmRlciBieSBhIGNlcnRhaW4gdHlwZSB3aXRoIChvcHRpb25hbCkgZGF0YVxuICogLSByZXF1aXJlKHR5cGUpKGRhdGEpOiByZXF1aXJlIGEgdHlwZSB0aGVuIHJlbmRlciB3aXRoIGRhdGFcbiAqL1xuXG5leHBvcnQgeyBib290c3RyYXAgfSBmcm9tICcuL2Jvb3RzdHJhcCdcbmV4cG9ydCB7IGNsZWFyQ29tbW9uTW9kdWxlcywgZGVmaW5lLCByZWdpc3RlciB9IGZyb20gJy4uLy4uLy4uLy4uL2RlZmF1bHQvYXBwL2J1bmRsZS9kZWZpbmUnXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvYnVuZGxlL2luZGV4LmpzXG4gKiovIiwiLy8gaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInXG5pbXBvcnQgVm0gZnJvbSAnLi4vLi4vLi4vLi4vZGVmYXVsdC92bSdcbi8vIGltcG9ydCAqIGFzIGRvd25ncmFkZSBmcm9tICcuLi9kb3duZ3JhZGUnXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnXG5pbXBvcnQge1xuICBpc1dlZXhDb21wb25lbnQsXG4gIGlzTnBtTW9kdWxlLFxuICByZW1vdmVXZWV4UHJlZml4LFxuICByZW1vdmVKU1N1cmZpeFxufSBmcm9tICcuLi8uLi8uLi8uLi9kZWZhdWx0L2FwcC9idW5kbGUvbWlzYydcblxuZXhwb3J0IGZ1bmN0aW9uIGJvb3RzdHJhcCAoYXBwLCBuYW1lLCBjb25maWcsIGRhdGEpIHtcbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gYm9vdHN0cmFwIGZvciAke25hbWV9YClcblxuICBsZXQgY2xlYW5OYW1lXG5cbiAgaWYgKGlzV2VleENvbXBvbmVudChuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcbiAgfVxuICBlbHNlIGlmIChpc05wbU1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG4gICAgLy8gY2hlY2sgaWYgZGVmaW5lIGJ5IG9sZCAnZGVmaW5lJyBtZXRob2RcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWFwcC5jdXN0b21Db21wb25lbnRNYXBbY2xlYW5OYW1lXSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSXQncyBub3QgYSBjb21wb25lbnQ6ICR7bmFtZX1gKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBXcm9uZyBjb21wb25lbnQgbmFtZTogJHtuYW1lfWApXG4gIH1cblxuICBjb25maWcgPSBpc1BsYWluT2JqZWN0KGNvbmZpZykgPyBjb25maWcgOiB7fVxuXG4gIGNvbnNvbGUubG9nKGB0cmFuc2Zvcm1lclZlcnNpb246ICR7Y29uZmlnLnRyYW5zZm9ybWVyVmVyc2lvbn0sIGBcbiAgICArIGBhdmFpbGFibGUgdHJhbnNmb3JtZXJWZXJzaW9uOiAke2dsb2JhbC50cmFuc2Zvcm1WZXJzaW9ufWApXG5cbiAgLy8gaWYgKHR5cGVvZiBjb25maWcudHJhbnNmb3JtZXJWZXJzaW9uID09PSAnc3RyaW5nJyAmJlxuICAvLyAgIHR5cGVvZiBnbG9iYWwudHJhbnNmb3JtZXJWZXJzaW9uID09PSAnc3RyaW5nJyAmJlxuICAvLyAgICFzZW12ZXIuc2F0aXNmaWVzKGNvbmZpZy50cmFuc2Zvcm1lclZlcnNpb24sXG4gIC8vICAgICBnbG9iYWwudHJhbnNmb3JtZXJWZXJzaW9uKSkge1xuICAvLyAgIHJldHVybiBuZXcgRXJyb3IoYEpTIEJ1bmRsZSB2ZXJzaW9uOiAke2NvbmZpZy50cmFuc2Zvcm1lclZlcnNpb259IGAgK1xuICAvLyAgICAgYG5vdCBjb21wYXRpYmxlIHdpdGggJHtnbG9iYWwudHJhbnNmb3JtZXJWZXJzaW9ufWApXG4gIC8vIH1cblxuICAvLyBjb25zdCBfY2hlY2tEb3duZ3JhZGUgPSBkb3duZ3JhZGUuY2hlY2soY29uZmlnLmRvd25ncmFkZSlcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIC8vIGlmIChfY2hlY2tEb3duZ3JhZGUuaXNEb3duZ3JhZGUpIHtcbiAgLy8gICBhcHAuY2FsbFRhc2tzKFt7XG4gIC8vICAgICBtb2R1bGU6ICdpbnN0YW5jZVdyYXAnLFxuICAvLyAgICAgbWV0aG9kOiAnZXJyb3InLFxuICAvLyAgICAgYXJnczogW1xuICAvLyAgICAgICBfY2hlY2tEb3duZ3JhZGUuZXJyb3JUeXBlLFxuICAvLyAgICAgICBfY2hlY2tEb3duZ3JhZGUuY29kZSxcbiAgLy8gICAgICAgX2NoZWNrRG93bmdyYWRlLmVycm9yTWVzc2FnZVxuICAvLyAgICAgXVxuICAvLyAgIH1dKVxuICAvLyAgIHJldHVybiBuZXcgRXJyb3IoYERvd25ncmFkZVske19jaGVja0Rvd25ncmFkZS5jb2RlfV06ICR7X2NoZWNrRG93bmdyYWRlLmVycm9yTWVzc2FnZX1gKVxuICAvLyB9XG5cbiAgYXBwLnZtID0gbmV3IFZtKGNsZWFuTmFtZSwgbnVsbCwgeyBfYXBwOiBhcHAgfSwgbnVsbCwgZGF0YSlcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9idW5kbGUvYm9vdHN0cmFwLmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBWaWV3TW9kZWwgQ29uc3RydWN0b3IgJiBkZWZpbml0aW9uXG4gKi9cblxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCB7XG4gIGluaXRTdGF0ZVxufSBmcm9tICcuLi9jb3JlL3N0YXRlJ1xuaW1wb3J0IHtcbiAgYnVpbGRcbn0gZnJvbSAnLi9jb21waWxlcidcbmltcG9ydCB7XG4gIGluaXRFdmVudHMsXG4gIG1peGluRXZlbnRzXG59IGZyb20gJy4vZXZlbnRzJ1xuaW1wb3J0IHtcbiAgcmVnaXN0ZXJNb2R1bGVzLFxuICByZWdpc3Rlck1ldGhvZHNcbn0gZnJvbSAnLi4vYXBwL3JlZ2lzdGVyJ1xuXG4vKipcbiAqIFZpZXdNb2RlbCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICBjb21wb25lbnQgb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmVudFZtICAgd2hpY2ggY29udGFpbnMgX2FwcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEVsICAgcm9vdCBlbGVtZW50IG9yIGZyYWcgYmxvY2tcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXJnZWREYXRhIGV4dGVybmFsIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBleHRlcm5hbEV2ZW50cyBleHRlcm5hbCBldmVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVm0gKFxuICB0eXBlLFxuICBvcHRpb25zLFxuICBwYXJlbnRWbSxcbiAgcGFyZW50RWwsXG4gIG1lcmdlZERhdGEsXG4gIGV4dGVybmFsRXZlbnRzXG4pIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50Vm0uX3JlYWxQYXJlbnQgPyBwYXJlbnRWbS5fcmVhbFBhcmVudCA6IHBhcmVudFZtXG4gIHRoaXMuX2FwcCA9IHBhcmVudFZtLl9hcHBcbiAgcGFyZW50Vm0uX2NoaWxkcmVuVm1zICYmIHBhcmVudFZtLl9jaGlsZHJlblZtcy5wdXNoKHRoaXMpXG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX2FwcC5jdXN0b21Db21wb25lbnRNYXBbdHlwZV0gfHwge31cbiAgfVxuICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IHt9XG5cbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5fbWV0aG9kcyA9IG9wdGlvbnMubWV0aG9kcyB8fCB7fVxuICB0aGlzLl9jb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQgfHwge31cbiAgdGhpcy5fY3NzID0gb3B0aW9ucy5zdHlsZSB8fCB7fVxuICB0aGlzLl9pZHMgPSB7fVxuICB0aGlzLl92bUV2ZW50cyA9IHt9XG4gIHRoaXMuX2NoaWxkcmVuVm1zID0gW11cbiAgdGhpcy5fdHlwZSA9IHR5cGVcblxuICAvLyBiaW5kIGV2ZW50cyBhbmQgbGlmZWN5Y2xlc1xuICBpbml0RXZlbnRzKHRoaXMsIGV4dGVybmFsRXZlbnRzKVxuXG4gIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIFwiaW5pdFwiIGxpZmVjeWNsZSBpbiBWbSgke3RoaXMuX3R5cGV9KWApXG4gIHRoaXMuJGVtaXQoJ2hvb2s6aW5pdCcpXG4gIHRoaXMuX2luaXRlZCA9IHRydWVcblxuICAvLyBwcm94eSBkYXRhIGFuZCBtZXRob2RzXG4gIC8vIG9ic2VydmUgZGF0YSBhbmQgYWRkIHRoaXMgdG8gdm1zXG4gIHRoaXMuX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGEoKSA6IGRhdGFcbiAgaWYgKG1lcmdlZERhdGEpIHtcbiAgICBleHRlbmQodGhpcy5fZGF0YSwgbWVyZ2VkRGF0YSlcbiAgfVxuICBpbml0U3RhdGUodGhpcylcblxuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBcImNyZWF0ZWRcIiBsaWZlY3ljbGUgaW4gVm0oJHt0aGlzLl90eXBlfSlgKVxuICB0aGlzLiRlbWl0KCdob29rOmNyZWF0ZWQnKVxuICB0aGlzLl9jcmVhdGVkID0gdHJ1ZVxuXG4gIC8vIGJhY2t3YXJkIG9sZCByZWFkeSBlbnRyeVxuICBpZiAob3B0aW9ucy5tZXRob2RzICYmIG9wdGlvbnMubWV0aG9kcy5yZWFkeSkge1xuICAgIGNvbnNvbGUud2FybignXCJleHBvcnRzLm1ldGhvZHMucmVhZHlcIiBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAgICdwbGVhc2UgdXNlIFwiZXhwb3J0cy5jcmVhdGVkXCIgaW5zdGVhZCcpXG4gICAgb3B0aW9ucy5tZXRob2RzLnJlYWR5LmNhbGwodGhpcylcbiAgfVxuXG4gIC8vIGlmIG5vIHBhcmVudEVsZW1lbnQgdGhlbiBzcGVjaWZ5IHRoZSBkb2N1bWVudEVsZW1lbnRcbiAgdGhpcy5fcGFyZW50RWwgPSBwYXJlbnRFbCB8fCB0aGlzLl9hcHAuZG9jLmRvY3VtZW50RWxlbWVudFxuICBidWlsZCh0aGlzKVxufVxuXG5taXhpbkV2ZW50cyhWbS5wcm90b3R5cGUpXG5cbmV4dGVuZChWbSwge1xuICByZWdpc3Rlck1vZHVsZXMsXG4gIHJlZ2lzdGVyTWV0aG9kc1xufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC92bS9pbmRleC5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCBXYXRjaGVyIGZyb20gJy4vd2F0Y2hlcidcbmltcG9ydCBEZXAgZnJvbSAnLi9kZXAnXG5pbXBvcnQge1xuICBvYnNlcnZlLFxuICBwcm94eSxcbiAgdW5wcm94eVxufSBmcm9tICcuL29ic2VydmVyJ1xuaW1wb3J0IHtcbiAgaXNQbGFpbk9iamVjdCxcbiAgYmluZFxufSBmcm9tICcuLi91dGlsJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXVxuICBpbml0RGF0YSh2bSlcbiAgaW5pdENvbXB1dGVkKHZtKVxuICBpbml0TWV0aG9kcyh2bSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICBsZXQgZGF0YSA9IHZtLl9kYXRhXG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgcHJveHkodm0sIGtleXNbaV0pXG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdm0pXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSkge1xuICBjb25zdCBjb21wdXRlZCA9IHZtLl9jb21wdXRlZFxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgIGNvbnN0IHVzZXJEZWYgPSBjb21wdXRlZFtrZXldXG4gICAgICBjb25zdCBkZWYgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRlZi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdm0pXG4gICAgICAgIGRlZi5zZXQgPSBub29wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgICA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdm0pXG4gICAgICAgICAgICA6IGJpbmQodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgICBkZWYuc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgICAgICA/IGJpbmQodXNlckRlZi5zZXQsIHZtKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBrZXksIGRlZilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUNvbXB1dGVkR2V0dGVyIChnZXR0ZXIsIG93bmVyKSB7XG4gIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBudWxsLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICB3YXRjaGVyLmV2YWx1YXRlKClcbiAgICB9XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIHdhdGNoZXIuZGVwZW5kKClcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB2bS5fbWV0aG9kc1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAobGV0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB2bVtrZXldID0gbWV0aG9kc1trZXldXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29yZS9zdGF0ZS5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCBEZXAgZnJvbSAnLi9kZXAnXG4vLyBpbXBvcnQgeyBwdXNoV2F0Y2hlciB9IGZyb20gJy4vYmF0Y2hlcidcbmltcG9ydCB7XG4gIHdhcm4sXG4gIHJlbW92ZSxcbiAgZXh0ZW5kLFxuICBpc09iamVjdCxcbiAgcGFyc2VQYXRoLFxuICBfU2V0IGFzIFNldFxufSBmcm9tICcuLi91dGlsJ1xuXG5sZXQgdWlkID0gMFxubGV0IHByZXZUYXJnZXRcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHR3b1dheVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gc3luY1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxhenlcbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3ByZVByb2Nlc3NdXG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwb3N0UHJvY2Vzc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdhdGNoZXIgKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAvLyBtaXggaW4gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIGNvbnN0IGlzRm4gPSB0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJ1xuICB0aGlzLnZtID0gdm1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcylcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGblxuICB0aGlzLmNiID0gY2JcbiAgdGhpcy5pZCA9ICsrdWlkIC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlXG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenkgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW11cbiAgdGhpcy5uZXdEZXBzID0gW11cbiAgdGhpcy5kZXBJZHMgPSBuZXcgU2V0KClcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgU2V0KClcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbilcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdGYWlsZWQgd2F0Y2hpbmcgcGF0aDogJyArIGV4cE9yRm4gK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKVxuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KClcbiAgLy8gc3RhdGUgZm9yIGF2b2lkaW5nIGZhbHNlIHRyaWdnZXJzIGZvciBkZWVwIGFuZCBBcnJheVxuICAvLyB3YXRjaGVycyBkdXJpbmcgdm0uX2RpZ2VzdCgpXG4gIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJlZm9yZUdldCgpXG4gIGNvbnN0IHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh0aGlzLnZtLCB0aGlzLnZtKVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSlcbiAgfVxuICB0aGlzLmFmdGVyR2V0KClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogUHJlcGFyZSBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcHJldlRhcmdldCA9IERlcC50YXJnZXRcbiAgRGVwLnRhcmdldCA9IHRoaXNcbn1cblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7RGVwfSBkZXBcbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIGNvbnN0IGlkID0gZGVwLmlkXG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZClcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApXG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IHByZXZUYXJnZXRcbiAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV1cbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICB9XG4gIGxldCB0bXAgPSB0aGlzLmRlcElkc1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzXG4gIHRoaXMubmV3RGVwSWRzID0gdG1wXG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKClcbiAgdG1wID0gdGhpcy5kZXBzXG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xuICB0aGlzLm5ld0RlcHMgPSB0bXBcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDBcbn1cblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaGFsbG93XG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ydW4oKVxuICB9XG4gIC8vIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gIC8vICAgdGhpcy5ydW4oKVxuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIGlmIHF1ZXVlZCwgb25seSBvdmVyd3JpdGUgc2hhbGxvdyB3aXRoIG5vbi1zaGFsbG93LFxuICAvLyAgIC8vIGJ1dCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuXG4gIC8vICAgdGhpcy5zaGFsbG93ID0gdGhpcy5xdWV1ZWRcbiAgLy8gICAgID8gc2hhbGxvd1xuICAvLyAgICAgICA/IHRoaXMuc2hhbGxvd1xuICAvLyAgICAgICA6IGZhbHNlXG4gIC8vICAgICA6ICEhc2hhbGxvd1xuICAvLyAgIHRoaXMucXVldWVkID0gdHJ1ZVxuICAvLyAgIHB1c2hXYXRjaGVyKHRoaXMpXG4gIC8vIH1cbn1cblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoKVxuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgICAvLyBub24tc2hhbGxvdyB1cGRhdGUgKGNhdXNlZCBieSBhIHZtIGRpZ2VzdCkuXG4gICAgICAoKGlzT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmRlZXApICYmICF0aGlzLnNoYWxsb3cpXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBhdm9pZCBvdmVyd3JpdGluZyBhbm90aGVyIHdhdGNoZXIgdGhhdCBpcyBiZWluZ1xuICAvLyBjb2xsZWN0ZWQuXG4gIGNvbnN0IGN1cnJlbnQgPSBEZXAudGFyZ2V0XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpXG4gIHRoaXMuZGlydHkgPSBmYWxzZVxuICBEZXAudGFyZ2V0ID0gY3VycmVudFxufVxuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKClcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZCBvciBpcyBwZXJmb3JtaW5nIGEgdi1mb3JcbiAgICAvLyByZS1yZW5kZXIgKHRoZSB3YXRjaGVyIGxpc3QgaXMgdGhlbiBmaWx0ZXJlZCBieSB2LWZvcikuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcylcbiAgICB9XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKVxuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlXG4gICAgdGhpcy52bSA9IHRoaXMuY2IgPSB0aGlzLnZhbHVlID0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogUmVjcnVzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge1NldH0gc2VlblxuICovXG5cbmNvbnN0IHNlZW5PYmplY3RzID0gbmV3IFNldCgpXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIGxldCBpLCBrZXlzLCBpc0EsIGlzT1xuICBpZiAoIXNlZW4pIHtcbiAgICBzZWVuID0gc2Vlbk9iamVjdHNcbiAgICBzZWVuLmNsZWFyKClcbiAgfVxuICBpc0EgPSBBcnJheS5pc0FycmF5KHZhbClcbiAgaXNPID0gaXNPYmplY3QodmFsKVxuICBpZiAoaXNBIHx8IGlzTykge1xuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICBjb25zdCBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkXG4gICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxbaV0sIHNlZW4pXG4gICAgfSBlbHNlIGlmIChpc08pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICBpID0ga2V5cy5sZW5ndGhcbiAgICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2VlbilcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9jb3JlL3dhdGNoZXIuanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHsgcmVtb3ZlIH0gZnJvbSAnLi4vdXRpbCdcblxubGV0IHVpZCA9IDBcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrXG4gIHRoaXMuc3VicyA9IFtdXG59XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGxcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yilcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yilcbn1cblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKVxufVxuXG4vKipcbiAqIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgb2YgYSBuZXcgdmFsdWUuXG4gKi9cblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpXG4gIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9jb3JlL2RlcC5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCBEZXAgZnJvbSAnLi9kZXAnXG5pbXBvcnQgeyBhcnJheU1ldGhvZHMgfSBmcm9tICcuL2FycmF5J1xuaW1wb3J0IHtcbiAgZGVmLFxuICByZW1vdmUsXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBoYXNQcm90byxcbiAgaGFzT3duLFxuICBpc1Jlc2VydmVkXG59IGZyb20gJy4uL3V0aWwnXG5cbmNvbnN0IGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcylcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKClcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcylcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudFxuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKVxuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSlcbiAgfVxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIHRoaXMuY29udmVydChrZXksIG9ialtrZXldKVxuICB9XG59XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBpbnRvIGdldHRlci9zZXR0ZXIgc28gd2UgY2FuIGVtaXRcbiAqIHRoZSBldmVudHMgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQvY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIGRlZmluZVJlYWN0aXZlKHRoaXMudmFsdWUsIGtleSwgdmFsKVxufVxuXG4vKipcbiAqIEFkZCBhbiBvd25lciB2bSwgc28gdGhhdCB3aGVuICRzZXQvJGRlbGV0ZSBtdXRhdGlvbnNcbiAqIGhhcHBlbiB3ZSBjYW4gbm90aWZ5IG93bmVyIHZtcyB0byBwcm94eSB0aGUga2V5cyBhbmRcbiAqIGRpZ2VzdCB0aGUgd2F0Y2hlcnMuIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0XG4gKiBpcyBvYnNlcnZlZCBhcyBhbiBpbnN0YW5jZSdzIHJvb3QgJGRhdGEuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyB8fCAodGhpcy52bXMgPSBbXSkpLnB1c2godm0pXG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICByZW1vdmUodGhpcy52bXMsIHZtKVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKi9cblxuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjXG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pXG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7T2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICogQHN0YXRpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgb2JcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX19cbiAgfSBlbHNlIGlmIChcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKVxuICB9XG4gIGlmIChvYiAmJiB2bSkge1xuICAgIG9iLmFkZFZtKHZtKVxuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAob2JqLCBrZXksIHZhbCkge1xuICBjb25zdCBkZXAgPSBuZXcgRGVwKClcblxuICBjb25zdCBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpXG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgY29uc3QgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0XG4gIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldFxuXG4gIGxldCBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsXG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKClcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAobGV0IGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBlID0gdmFsdWVbaV1cbiAgICAgICAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWxcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbClcbiAgICAgIGRlcC5ub3RpZnkoKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0IChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNwbGljZShrZXksIDEsIHZhbClcbiAgfVxuICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKG9iai5faXNWdWUpIHtcbiAgICBzZXQob2JqLl9kYXRhLCBrZXksIHZhbClcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvYiA9IG9iai5fX29iX19cbiAgaWYgKCFvYikge1xuICAgIG9ialtrZXldID0gdmFsXG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuY29udmVydChrZXksIHZhbClcbiAgb2IuZGVwLm5vdGlmeSgpXG4gIGlmIChvYi52bXMpIHtcbiAgICBsZXQgaSA9IG9iLnZtcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCB2bSA9IG9iLnZtc1tpXVxuICAgICAgcHJveHkodm0sIGtleSlcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVsIChvYmosIGtleSkge1xuICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgb2JqW2tleV1cbiAgY29uc3Qgb2IgPSBvYmouX19vYl9fXG5cbiAgaWYgKCFvYikge1xuICAgIGlmIChvYmouX2lzVnVlKSB7XG4gICAgICBkZWxldGUgb2JqLl9kYXRhW2tleV1cbiAgICAgIG9iai4kZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KClcbiAgaWYgKG9iLnZtcykge1xuICAgIGxldCBpID0gb2Iudm1zLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IHZtID0gb2Iudm1zW2ldXG4gICAgICB1bnByb3h5KHZtLCBrZXkpXG4gICAgICB2bS4kZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBLRVlfV09SRFMgPSBbJyRpbmRleCcsICckdmFsdWUnLCAnJGV2ZW50J11cbmV4cG9ydCBmdW5jdGlvbiBwcm94eSAodm0sIGtleSkge1xuICBpZiAoS0VZX1dPUkRTLmluZGV4T2Yoa2V5KSA+IC0xIHx8ICFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodm0sIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgICAgICByZXR1cm4gdm0uX2RhdGFba2V5XVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgICAgICB2bS5fZGF0YVtrZXldID0gdmFsXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5wcm94eSAodm0sIGtleSkge1xuICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgIGRlbGV0ZSB2bVtrZXldXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9jb3JlL29ic2VydmVyLmpzXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbCdcblxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZVxuZXhwb3J0IGNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgY29uc3Qgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF1cbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgbGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShpKVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICBjb25zdCBvYiA9IHRoaXMuX19vYl9fXG4gICAgbGV0IGluc2VydGVkXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZClcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KVxufSlcblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIGEgbmV3IHZhbHVlXG4gKiBhbmQgZW1pdHMgY29ycmVzcG9uZGluZyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHsqfSAtIHJlcGxhY2VkIGVsZW1lbnRcbiAqL1xuXG5kZWYoXG4gIGFycmF5UHJvdG8sXG4gICckc2V0JyxcbiAgZnVuY3Rpb24gJHNldCAoaW5kZXgsIHZhbCkge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbmRleCArIDFcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxLCB2YWwpWzBdXG4gIH1cbilcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGF0IGdpdmVuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5kZWYoXG4gIGFycmF5UHJvdG8sXG4gICckcmVtb3ZlJyxcbiAgZnVuY3Rpb24gJHJlbW92ZSAoaW5kZXgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4T2YoaW5kZXgpXG4gICAgfVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbilcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9jb3JlL2FycmF5LmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBWaWV3TW9kZWwgdGVtcGxhdGUgcGFyc2VyICYgZGF0YS1iaW5kaW5nIHByb2Nlc3NcbiAqXG4gKiByZXF1aXJlZDpcbiAqIGluZGV4LmpzOiBWbVxuICogZG9tLWhlbHBlci5qczogY3JlYXRlRWxlbWVudCwgY3JlYXRlQmxvY2tcbiAqIGRvbS1oZWxwZXIuanM6IGF0dGFjaFRhcmdldCwgbW92ZVRhcmdldCwgcmVtb3ZlVGFyZ2V0XG4gKiBkaXJlY3RpdmUuanM6IGJpbmRFbGVtZW50LCBiaW5kU3ViVm0sIHNldElkLCB3YXRjaFxuICogZXZlbnRzLmpzOiAkb25cbiAqL1xuXG5pbXBvcnQge1xuICBleHRlbmQsXG4gIGlzT2JqZWN0LFxuICBiaW5kXG59IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge1xuICBpbml0RGF0YSxcbiAgaW5pdENvbXB1dGVkXG59IGZyb20gJy4uL2NvcmUvc3RhdGUnXG5pbXBvcnQge1xuICBiaW5kRWxlbWVudCxcbiAgc2V0SWQsXG4gIGJpbmRTdWJWbSxcbiAgYmluZFN1YlZtQWZ0ZXJJbml0aWFsaXplZCxcbiAgYXBwbHlOYWl0dmVDb21wb25lbnRPcHRpb25zLFxuICB3YXRjaFxufSBmcm9tICcuL2RpcmVjdGl2ZSdcbmltcG9ydCB7XG4gIGNyZWF0ZUJsb2NrLFxuICBjcmVhdGVCb2R5LFxuICBjcmVhdGVFbGVtZW50LFxuICBhdHRhY2hUYXJnZXQsXG4gIG1vdmVUYXJnZXQsXG4gIHJlbW92ZVRhcmdldFxufSBmcm9tICcuL2RvbS1oZWxwZXInXG5cbi8qKlxuICogYnVpbGQoZXh0ZXJuYWxEaXJzKVxuICogICBjcmVhdGVWbSgpXG4gKiAgIG1lcmdlKGV4dGVybmFsRGlycywgZGlycylcbiAqICAgY29tcGlsZSh0ZW1wbGF0ZSwgcGFyZW50Tm9kZSlcbiAqICAgICBpZiAodHlwZSBpcyBjb250ZW50KSBjcmVhdGUgY29udGVudE5vZGVcbiAqICAgICBlbHNlIGlmIChkaXJzIGhhdmUgdi1mb3IpIGZvcmVhY2ggLT4gY3JlYXRlIGNvbnRleHRcbiAqICAgICAgIC0+IGNvbXBpbGUodGVtcGxhdGVXaXRob3V0Rm9yLCBwYXJlbnROb2RlKTogZGlmZihsaXN0KSBvbmNoYW5nZVxuICogICAgIGVsc2UgaWYgKGRpcnMgaGF2ZSB2LWlmKSBhc3NlcnRcbiAqICAgICAgIC0+IGNvbXBpbGUodGVtcGxhdGVXaXRob3V0SWYsIHBhcmVudE5vZGUpOiB0b2dnbGUoc2hvd24pIG9uY2hhbmdlXG4gKiAgICAgZWxzZSBpZiAodHlwZSBpcyBkeW5hbWljKVxuICogICAgICAgLT4gY29tcGlsZSh0ZW1wbGF0ZVdpdGhvdXREeW5hbWljVHlwZSwgcGFyZW50Tm9kZSk6IHdhdGNoKHR5cGUpIG9uY2hhbmdlXG4gKiAgICAgZWxzZSBpZiAodHlwZSBpcyBjdXN0b20pXG4gKiAgICAgICBhZGRDaGlsZFZtKHZtLCBwYXJlbnRWbSlcbiAqICAgICAgIGJ1aWxkKGV4dGVybmFsRGlycylcbiAqICAgICAgIGZvcmVhY2ggY2hpbGROb2RlcyAtPiBjb21waWxlKGNoaWxkTm9kZSwgdGVtcGxhdGUpXG4gKiAgICAgZWxzZSBpZiAodHlwZSBpcyBuYXRpdmUpXG4gKiAgICAgICBzZXQoZGlycyk6IHVwZGF0ZShpZC9hdHRyL3N0eWxlL2NsYXNzKSBvbmNoYW5nZVxuICogICAgICAgYXBwZW5kKHRlbXBsYXRlLCBwYXJlbnROb2RlKVxuICogICAgICAgZm9yZWFjaCBjaGlsZE5vZGVzIC0+IGNvbXBpbGUoY2hpbGROb2RlLCB0ZW1wbGF0ZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkICh2bSkge1xuICBjb25zdCBvcHQgPSB2bS5fb3B0aW9ucyB8fCB7fVxuICBjb25zdCB0ZW1wbGF0ZSA9IG9wdC50ZW1wbGF0ZSB8fCB7fVxuXG4gIGlmIChvcHQucmVwbGFjZSkge1xuICAgIGlmICh0ZW1wbGF0ZS5jaGlsZHJlbiAmJiB0ZW1wbGF0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbXBpbGUodm0sIHRlbXBsYXRlLmNoaWxkcmVuWzBdLCB2bS5fcGFyZW50RWwpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29tcGlsZSh2bSwgdGVtcGxhdGUuY2hpbGRyZW4sIHZtLl9wYXJlbnRFbClcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgY29tcGlsZSh2bSwgdGVtcGxhdGUsIHZtLl9wYXJlbnRFbClcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIFwicmVhZHlcIiBsaWZlY3ljbGUgaW4gVm0oJHt2bS5fdHlwZX0pYClcbiAgdm0uJGVtaXQoJ2hvb2s6cmVhZHknKVxuICB2bS5fcmVhZHkgPSB0cnVlXG59XG5cbi8qKlxuICogR2VuZXJhdGUgZWxlbWVudHMgYnkgY2hpbGQgb3IgY2hpbGRyZW4gYW5kIGFwcGVuZCB0byBwYXJlbnQgZWxlbWVudHMuXG4gKiBSb290IGVsZW1lbnQgaW5mbyB3b3VsZCBiZSBtZXJnZWQgaWYgaGFzLiBUaGUgZmlyc3QgYXJndW1lbnQgbWF5IGJlIGFuIGFycmF5XG4gKiBpZiB0aGUgcm9vdCBlbGVtZW50IHdpdGggb3B0aW9ucy5yZXBsYWNlIGhhcyBub3Qgb25seSBvbmUgY2hpbGQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgIGRlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICBtZXRhXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHZtLCB0YXJnZXQsIGRlc3QsIG1ldGEpIHtcbiAgY29uc3QgYXBwID0gdm0uX2FwcCB8fCB7fVxuXG4gIGlmIChhcHAubGFzdFNpZ25hbCA9PT0gLTEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0YXJnZXRJc0ZyYWdtZW50KHRhcmdldCkpIHtcbiAgICBjb21waWxlRnJhZ21lbnQodm0sIHRhcmdldCwgZGVzdCwgbWV0YSlcbiAgICByZXR1cm5cbiAgfVxuICBtZXRhID0gbWV0YSB8fCB7fVxuICBpZiAodGFyZ2V0SXNDb250ZW50KHRhcmdldCkpIHtcbiAgICBjb25zb2xlLmRlYnVnKCdbSlMgRnJhbWV3b3JrXSBjb21waWxlIFwiY29udGVudFwiIGJsb2NrIGJ5JywgdGFyZ2V0KVxuICAgIHZtLl9jb250ZW50ID0gY3JlYXRlQmxvY2sodm0sIGRlc3QpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGFyZ2V0TmVlZENoZWNrUmVwZWF0KHRhcmdldCwgbWV0YSkpIHtcbiAgICBjb25zb2xlLmRlYnVnKCdbSlMgRnJhbWV3b3JrXSBjb21waWxlIFwicmVwZWF0XCIgbG9naWMgYnknLCB0YXJnZXQpXG4gICAgY29tcGlsZVJlcGVhdCh2bSwgdGFyZ2V0LCBkZXN0KVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0YXJnZXROZWVkQ2hlY2tTaG93bih0YXJnZXQsIG1ldGEpKSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSBcImlmXCIgbG9naWMgYnknLCB0YXJnZXQpXG4gICAgY29tcGlsZVNob3duKHZtLCB0YXJnZXQsIGRlc3QsIG1ldGEpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdHlwZUdldHRlciA9IG1ldGEudHlwZSB8fCB0YXJnZXQudHlwZVxuICBpZiAodGFyZ2V0TmVlZENoZWNrVHlwZSh0eXBlR2V0dGVyLCBtZXRhKSkge1xuICAgIGNvbXBpbGVUeXBlKHZtLCB0YXJnZXQsIGRlc3QsIHR5cGVHZXR0ZXIsIG1ldGEpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVHZXR0ZXJcbiAgY29uc3QgY29tcG9uZW50ID0gdGFyZ2V0SXNDb21wb3NlZCh2bSwgdGFyZ2V0LCB0eXBlKVxuICBpZiAoY29tcG9uZW50KSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSBjb21wb3NlZCBjb21wb25lbnQgYnknLCB0YXJnZXQpXG4gICAgY29tcGlsZUN1c3RvbUNvbXBvbmVudCh2bSwgY29tcG9uZW50LCB0YXJnZXQsIGRlc3QsIHR5cGUsIG1ldGEpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSBuYXRpdmUgY29tcG9uZW50IGJ5JywgdGFyZ2V0KVxuICBjb21waWxlTmF0aXZlQ29tcG9uZW50KHZtLCB0YXJnZXQsIGRlc3QsIHR5cGUpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGFyZ2V0IGlzIGEgZnJhZ21lbnQgKGFuIGFycmF5KS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRhcmdldElzRnJhZ21lbnQgKHRhcmdldCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGFyZ2V0IHR5cGUgaXMgY29udGVudC9zbG90LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0SXNDb250ZW50ICh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC50eXBlID09PSAnY29udGVudCcgfHwgdGFyZ2V0LnR5cGUgPT09ICdzbG90J1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRhcmdldCBuZWVkIHRvIGNvbXBpbGUgYnkgYSBsaXN0LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSAgbWV0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0TmVlZENoZWNrUmVwZWF0ICh0YXJnZXQsIG1ldGEpIHtcbiAgcmV0dXJuICFtZXRhLmhhc093blByb3BlcnR5KCdyZXBlYXQnKSAmJiB0YXJnZXQucmVwZWF0XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGFyZ2V0IG5lZWQgdG8gY29tcGlsZSBieSBhIGJvb2xlYW4gdmFsdWUuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgdGFyZ2V0XG4gKiBAcGFyYW0gIHtvYmplY3R9ICBtZXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0YXJnZXROZWVkQ2hlY2tTaG93biAodGFyZ2V0LCBtZXRhKSB7XG4gIHJldHVybiAhbWV0YS5oYXNPd25Qcm9wZXJ0eSgnc2hvd24nKSAmJiB0YXJnZXQuc2hvd25cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgbmVlZCB0byBjb21waWxlIGJ5IGEgZHluYW1pYyB0eXBlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xmdW5jdGlvbn0gdHlwZUdldHRlclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICBtZXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0YXJnZXROZWVkQ2hlY2tUeXBlICh0eXBlR2V0dGVyLCBtZXRhKSB7XG4gIHJldHVybiAodHlwZW9mIHR5cGVHZXR0ZXIgPT09ICdmdW5jdGlvbicpICYmICFtZXRhLmhhc093blByb3BlcnR5KCd0eXBlJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGtpbmQgb2YgY29tcG9uZW50IGlzIGNvbXBvc2VkLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRhcmdldElzQ29tcG9zZWQgKHZtLCB0YXJnZXQsIHR5cGUpIHtcbiAgbGV0IGNvbXBvbmVudFxuICBpZiAodm0uX2FwcCAmJiB2bS5fYXBwLmN1c3RvbUNvbXBvbmVudE1hcCkge1xuICAgIGNvbXBvbmVudCA9IHZtLl9hcHAuY3VzdG9tQ29tcG9uZW50TWFwW3R5cGVdXG4gIH1cbiAgaWYgKHZtLl9vcHRpb25zICYmIHZtLl9vcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICBjb21wb25lbnQgPSB2bS5fb3B0aW9ucy5jb21wb25lbnRzW3R5cGVdXG4gIH1cbiAgaWYgKHRhcmdldC5jb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQgPSBjb21wb25lbnQgfHwge31cbiAgfVxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIGxpc3Qgb2YgdGFyZ2V0cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUZyYWdtZW50ICh2bSwgdGFyZ2V0LCBkZXN0LCBtZXRhKSB7XG4gIGNvbnN0IGZyYWdCbG9jayA9IGNyZWF0ZUJsb2NrKHZtLCBkZXN0KVxuICB0YXJnZXQuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBjb21waWxlKHZtLCBjaGlsZCwgZnJhZ0Jsb2NrLCBtZXRhKVxuICB9KVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0YXJnZXQgd2l0aCByZXBlYXQgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVSZXBlYXQgKHZtLCB0YXJnZXQsIGRlc3QpIHtcbiAgY29uc3QgcmVwZWF0ID0gdGFyZ2V0LnJlcGVhdFxuICBjb25zdCBvbGRTdHlsZSA9IHR5cGVvZiByZXBlYXQgPT09ICdmdW5jdGlvbidcbiAgbGV0IGdldHRlciA9IHJlcGVhdC5nZXR0ZXIgfHwgcmVwZWF0LmV4cHJlc3Npb24gfHwgcmVwZWF0XG4gIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZ2V0dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfVxuICB9XG4gIGNvbnN0IGtleSA9IHJlcGVhdC5rZXkgfHwgJyRpbmRleCdcbiAgY29uc3QgdmFsdWUgPSByZXBlYXQudmFsdWUgfHwgJyR2YWx1ZSdcbiAgY29uc3QgdHJhY2tCeSA9IHJlcGVhdC50cmFja0J5IHx8IHRhcmdldC50cmFja0J5IHx8XG4gICAgKHRhcmdldC5hdHRyICYmIHRhcmdldC5hdHRyLnRyYWNrQnkpXG5cbiAgY29uc3QgZnJhZ0Jsb2NrID0gY3JlYXRlQmxvY2sodm0sIGRlc3QpXG4gIGZyYWdCbG9jay5jaGlsZHJlbiA9IFtdXG4gIGZyYWdCbG9jay5kYXRhID0gW11cbiAgZnJhZ0Jsb2NrLnZtcyA9IFtdXG5cbiAgYmluZFJlcGVhdCh2bSwgdGFyZ2V0LCBmcmFnQmxvY2ssIHsgZ2V0dGVyLCBrZXksIHZhbHVlLCB0cmFja0J5LCBvbGRTdHlsZSB9KVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0YXJnZXQgd2l0aCBpZiBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVTaG93biAodm0sIHRhcmdldCwgZGVzdCwgbWV0YSkge1xuICBjb25zdCBuZXdNZXRhID0geyBzaG93bjogdHJ1ZSB9XG4gIGNvbnN0IGZyYWdCbG9jayA9IGNyZWF0ZUJsb2NrKHZtLCBkZXN0KVxuXG4gIGlmIChkZXN0LmVsZW1lbnQgJiYgZGVzdC5jaGlsZHJlbikge1xuICAgIGRlc3QuY2hpbGRyZW4ucHVzaChmcmFnQmxvY2spXG4gIH1cblxuICBpZiAobWV0YS5yZXBlYXQpIHtcbiAgICBuZXdNZXRhLnJlcGVhdCA9IG1ldGEucmVwZWF0XG4gIH1cblxuICBiaW5kU2hvd24odm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBuZXdNZXRhKVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0YXJnZXQgd2l0aCBkeW5hbWljIGNvbXBvbmVudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZUdldHRlclxuICovXG5mdW5jdGlvbiBjb21waWxlVHlwZSAodm0sIHRhcmdldCwgZGVzdCwgdHlwZUdldHRlciwgbWV0YSkge1xuICBjb25zdCB0eXBlID0gdHlwZUdldHRlci5jYWxsKHZtKVxuICBjb25zdCBuZXdNZXRhID0gZXh0ZW5kKHsgdHlwZSB9LCBtZXRhKVxuICBjb25zdCBmcmFnQmxvY2sgPSBjcmVhdGVCbG9jayh2bSwgZGVzdClcblxuICBpZiAoZGVzdC5lbGVtZW50ICYmIGRlc3QuY2hpbGRyZW4pIHtcbiAgICBkZXN0LmNoaWxkcmVuLnB1c2goZnJhZ0Jsb2NrKVxuICB9XG5cbiAgd2F0Y2godm0sIHR5cGVHZXR0ZXIsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG5ld01ldGEgPSBleHRlbmQoeyB0eXBlOiB2YWx1ZSB9LCBtZXRhKVxuICAgIHJlbW92ZVRhcmdldCh2bSwgZnJhZ0Jsb2NrLCB0cnVlKVxuICAgIGNvbXBpbGUodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBuZXdNZXRhKVxuICB9KVxuXG4gIGNvbXBpbGUodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBuZXdNZXRhKVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBjb21wb3NlZCBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDdXN0b21Db21wb25lbnQgKHZtLCBjb21wb25lbnQsIHRhcmdldCwgZGVzdCwgdHlwZSwgbWV0YSkge1xuICBjb25zdCBDdG9yID0gdm0uY29uc3RydWN0b3JcbiAgY29uc3Qgc3ViVm0gPSBuZXcgQ3Rvcih0eXBlLCBjb21wb25lbnQsIHZtLCBkZXN0LCB1bmRlZmluZWQsIHtcbiAgICAnaG9vazppbml0JzogZnVuY3Rpb24gKCkge1xuICAgICAgc2V0SWQodm0sIG51bGwsIHRhcmdldC5pZCwgdGhpcylcbiAgICAgIC8vIGJpbmQgdGVtcGxhdGUgZWFybGllciBiZWNhdXNlIG9mIGxpZmVjeWNsZSBpc3N1ZXNcbiAgICAgIHRoaXMuX2V4dGVybmFsQmluZGluZyA9IHtcbiAgICAgICAgcGFyZW50OiB2bSxcbiAgICAgICAgdGVtcGxhdGU6IHRhcmdldFxuICAgICAgfVxuICAgIH0sXG4gICAgJ2hvb2s6Y3JlYXRlZCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGJpbmRTdWJWbSh2bSwgdGhpcywgdGFyZ2V0LCBtZXRhLnJlcGVhdClcbiAgICB9LFxuICAgICdob29rOnJlYWR5JzogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgICAgY29tcGlsZUNoaWxkcmVuKHZtLCB0YXJnZXQsIHRoaXMuX2NvbnRlbnQpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICBiaW5kU3ViVm1BZnRlckluaXRpYWxpemVkKHZtLCBzdWJWbSwgdGFyZ2V0KVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGVsZW1lbnQgZnJvbSB0ZW1wbGF0ZSBhbmQgYXR0YWNoIHRvIHRoZSBkZXN0IGlmIG5lZWRlZC5cbiAqIFRoZSB0aW1lIHRvIGF0dGFjaCBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIG1vZGUgc3RhdHVzIGlzIG5vZGUgb3IgdHJlZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGVtcGxhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjb21waWxlTmF0aXZlQ29tcG9uZW50ICh2bSwgdGVtcGxhdGUsIGRlc3QsIHR5cGUpIHtcbiAgYXBwbHlOYWl0dmVDb21wb25lbnRPcHRpb25zKHRlbXBsYXRlKVxuXG4gIGxldCBlbGVtZW50XG4gIGlmIChkZXN0LnJlZiA9PT0gJ19kb2N1bWVudEVsZW1lbnQnKSB7XG4gICAgLy8gaWYgaXRzIHBhcmVudCBpcyBkb2N1bWVudEVsZW1lbnQgdGhlbiBpdCdzIGEgYm9keVxuICAgIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIGNvbXBpbGUgdG8gY3JlYXRlIGJvZHkgZm9yICR7dHlwZX1gKVxuICAgIGVsZW1lbnQgPSBjcmVhdGVCb2R5KHZtLCB0eXBlKVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIGNvbXBpbGUgdG8gY3JlYXRlIGVsZW1lbnQgZm9yICR7dHlwZX1gKVxuICAgIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHZtLCB0eXBlKVxuICB9XG5cbiAgaWYgKCF2bS5fcm9vdEVsKSB7XG4gICAgdm0uX3Jvb3RFbCA9IGVsZW1lbnRcbiAgICAvLyBiaW5kIGV2ZW50IGVhcmxpZXIgYmVjYXVzZSBvZiBsaWZlY3ljbGUgaXNzdWVzXG4gICAgY29uc3QgYmluZGluZyA9IHZtLl9leHRlcm5hbEJpbmRpbmcgfHwge31cbiAgICBjb25zdCB0YXJnZXQgPSBiaW5kaW5nLnRlbXBsYXRlXG4gICAgY29uc3QgcGFyZW50Vm0gPSBiaW5kaW5nLnBhcmVudFxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmV2ZW50cyAmJiBwYXJlbnRWbSAmJiBlbGVtZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdGFyZ2V0LmV2ZW50cykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcGFyZW50Vm1bdGFyZ2V0LmV2ZW50c1t0eXBlXV1cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50KHR5cGUsIGJpbmQoaGFuZGxlciwgcGFyZW50Vm0pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmluZEVsZW1lbnQodm0sIGVsZW1lbnQsIHRlbXBsYXRlKVxuXG4gIGlmICh0ZW1wbGF0ZS5hdHRyICYmIHRlbXBsYXRlLmF0dHIuYXBwZW5kKSB7IC8vIGJhY2t3YXJkLCBhcHBlbmQgcHJvcCBpbiBhdHRyXG4gICAgdGVtcGxhdGUuYXBwZW5kID0gdGVtcGxhdGUuYXR0ci5hcHBlbmRcbiAgfVxuXG4gIGlmICh0ZW1wbGF0ZS5hcHBlbmQpIHsgLy8gZ2l2ZSB0aGUgYXBwZW5kIGF0dHJpYnV0ZSBmb3IgaW9zIGFkYXB0YXRpb25cbiAgICBlbGVtZW50LmF0dHIgPSBlbGVtZW50LmF0dHIgfHwge31cbiAgICBlbGVtZW50LmF0dHIuYXBwZW5kID0gdGVtcGxhdGUuYXBwZW5kXG4gIH1cblxuICBjb25zdCB0cmVlTW9kZSA9IHRlbXBsYXRlLmFwcGVuZCA9PT0gJ3RyZWUnXG4gIGNvbnN0IGFwcCA9IHZtLl9hcHAgfHwge31cbiAgaWYgKGFwcC5sYXN0U2lnbmFsICE9PSAtMSAmJiAhdHJlZU1vZGUpIHtcbiAgICBjb25zb2xlLmRlYnVnKCdbSlMgRnJhbWV3b3JrXSBjb21waWxlIHRvIGFwcGVuZCBzaW5nbGUgbm9kZSBmb3InLCBlbGVtZW50KVxuICAgIGFwcC5sYXN0U2lnbmFsID0gYXR0YWNoVGFyZ2V0KHZtLCBlbGVtZW50LCBkZXN0KVxuICB9XG4gIGlmIChhcHAubGFzdFNpZ25hbCAhPT0gLTEpIHtcbiAgICBjb21waWxlQ2hpbGRyZW4odm0sIHRlbXBsYXRlLCBlbGVtZW50KVxuICB9XG4gIGlmIChhcHAubGFzdFNpZ25hbCAhPT0gLTEgJiYgdHJlZU1vZGUpIHtcbiAgICBjb25zb2xlLmRlYnVnKCdbSlMgRnJhbWV3b3JrXSBjb21waWxlIHRvIGFwcGVuZCB3aG9sZSB0cmVlIGZvcicsIGVsZW1lbnQpXG4gICAgYXBwLmxhc3RTaWduYWwgPSBhdHRhY2hUYXJnZXQodm0sIGVsZW1lbnQsIGRlc3QpXG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYWxsIGNoaWxkcmVuIHRvIGEgY2VydGFpbiBwYXJlbnQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGVtcGxhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDaGlsZHJlbiAodm0sIHRlbXBsYXRlLCBkZXN0KSB7XG4gIGNvbnN0IGFwcCA9IHZtLl9hcHAgfHwge31cbiAgY29uc3QgY2hpbGRyZW4gPSB0ZW1wbGF0ZS5jaGlsZHJlblxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiB7XG4gICAgICBjb21waWxlKHZtLCBjaGlsZCwgZGVzdClcbiAgICAgIHJldHVybiBhcHAubGFzdFNpZ25hbCAhPT0gLTFcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogV2F0Y2ggdGhlIGxpc3QgdXBkYXRlIGFuZCByZWZyZXNoIHRoZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmcmFnQmxvY2sge3ZtcywgZGF0YSwgY2hpbGRyZW59XG4gKiBAcGFyYW0ge29iamVjdH0gaW5mbyAgICAgIHtnZXR0ZXIsIGtleSwgdmFsdWUsIHRyYWNrQnksIG9sZFN0eWxlfVxuICovXG5mdW5jdGlvbiBiaW5kUmVwZWF0ICh2bSwgdGFyZ2V0LCBmcmFnQmxvY2ssIGluZm8pIHtcbiAgY29uc3Qgdm1zID0gZnJhZ0Jsb2NrLnZtc1xuICBjb25zdCBjaGlsZHJlbiA9IGZyYWdCbG9jay5jaGlsZHJlblxuICBjb25zdCB7IGdldHRlciwgdHJhY2tCeSwgb2xkU3R5bGUgfSA9IGluZm9cbiAgY29uc3Qga2V5TmFtZSA9IGluZm8ua2V5XG4gIGNvbnN0IHZhbHVlTmFtZSA9IGluZm8udmFsdWVcblxuICBmdW5jdGlvbiBjb21waWxlSXRlbSAoaXRlbSwgaW5kZXgsIGNvbnRleHQpIHtcbiAgICBsZXQgbWVyZ2VkRGF0YVxuICAgIGlmIChvbGRTdHlsZSkge1xuICAgICAgbWVyZ2VkRGF0YSA9IGl0ZW1cbiAgICAgIGlmIChpc09iamVjdChpdGVtKSkge1xuICAgICAgICBtZXJnZWREYXRhW2tleU5hbWVdID0gaW5kZXhcbiAgICAgICAgaWYgKCFtZXJnZWREYXRhLmhhc093blByb3BlcnR5KCdJTkRFWCcpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lcmdlZERhdGEsICdJTkRFWCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0pTIEZyYW1ld29ya10gXCJJTkRFWFwiIGluIHJlcGVhdCBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAgICAgICAgICAgICAncGxlYXNlIHVzZSBcIiRpbmRleFwiIGluc3RlYWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIEVhY2ggbGlzdCBpdGVtIG11c3QgYmUgYW4gb2JqZWN0IGluIG9sZC1zdHlsZSByZXBlYXQsICdcbiAgICAgICAgICArICdwbGVhc2UgdXNlIGByZXBlYXQ9e3t2IGluIGxpc3R9fWAgaW5zdGVhZC4nKVxuICAgICAgICBtZXJnZWREYXRhID0ge31cbiAgICAgICAgbWVyZ2VkRGF0YVtrZXlOYW1lXSA9IGluZGV4XG4gICAgICAgIG1lcmdlZERhdGFbdmFsdWVOYW1lXSA9IGl0ZW1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBtZXJnZWREYXRhID0ge31cbiAgICAgIG1lcmdlZERhdGFba2V5TmFtZV0gPSBpbmRleFxuICAgICAgbWVyZ2VkRGF0YVt2YWx1ZU5hbWVdID0gaXRlbVxuICAgIH1cbiAgICBjb25zdCBuZXdDb250ZXh0ID0gbWVyZ2VDb250ZXh0KGNvbnRleHQsIG1lcmdlZERhdGEpXG4gICAgdm1zLnB1c2gobmV3Q29udGV4dClcbiAgICBjb21waWxlKG5ld0NvbnRleHQsIHRhcmdldCwgZnJhZ0Jsb2NrLCB7IHJlcGVhdDogaXRlbSB9KVxuICB9XG5cbiAgY29uc3QgbGlzdCA9IHdhdGNoQmxvY2sodm0sIGZyYWdCbG9jaywgZ2V0dGVyLCAncmVwZWF0JyxcbiAgICAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gdGhlIFwicmVwZWF0XCIgaXRlbSBoYXMgY2hhbmdlZCcsIGRhdGEpXG4gICAgICBpZiAoIWZyYWdCbG9jaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBjaGlsZHJlbi5zbGljZSgpXG4gICAgICBjb25zdCBvbGRWbXMgPSB2bXMuc2xpY2UoKVxuICAgICAgY29uc3Qgb2xkRGF0YSA9IGZyYWdCbG9jay5kYXRhLnNsaWNlKClcbiAgICAgIC8vIDEuIGNvbGxlY3QgYWxsIG5ldyByZWZzIHRyYWNrIGJ5XG4gICAgICBjb25zdCB0cmFja01hcCA9IHt9XG4gICAgICBjb25zdCByZXVzZWRNYXAgPSB7fVxuICAgICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSB0cmFja0J5ID8gaXRlbVt0cmFja0J5XSA6IChvbGRTdHlsZSA/IGl0ZW1ba2V5TmFtZV0gOiBpbmRleClcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCBrZXkgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tNYXBba2V5XSA9IGl0ZW1cbiAgICAgIH0pXG5cbiAgICAgIC8vIDIuIHJlbW92ZSB1bnVzZWQgZWxlbWVudCBmb3JlYWNoIG9sZCBpdGVtXG4gICAgICBjb25zdCByZXVzZWRMaXN0ID0gW11cbiAgICAgIG9sZERhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHJhY2tCeSA/IGl0ZW1bdHJhY2tCeV0gOiAob2xkU3R5bGUgPyBpdGVtW2tleU5hbWVdIDogaW5kZXgpXG4gICAgICAgIGlmICh0cmFja01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmV1c2VkTWFwW2tleV0gPSB7XG4gICAgICAgICAgICBpdGVtLCBpbmRleCwga2V5LFxuICAgICAgICAgICAgdGFyZ2V0OiBvbGRDaGlsZHJlbltpbmRleF0sXG4gICAgICAgICAgICB2bTogb2xkVm1zW2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXVzZWRMaXN0LnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZW1vdmVUYXJnZXQodm0sIG9sZENoaWxkcmVuW2luZGV4XSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gMy4gY3JlYXRlIG5ldyBlbGVtZW50IGZvcmVhY2ggbmV3IGl0ZW1cbiAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDBcbiAgICAgIHZtcy5sZW5ndGggPSAwXG4gICAgICBmcmFnQmxvY2suZGF0YSA9IGRhdGEuc2xpY2UoKVxuICAgICAgZnJhZ0Jsb2NrLnVwZGF0ZU1hcmsgPSBmcmFnQmxvY2suc3RhcnRcblxuICAgICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSB0cmFja0J5ID8gaXRlbVt0cmFja0J5XSA6IChvbGRTdHlsZSA/IGl0ZW1ba2V5TmFtZV0gOiBpbmRleClcbiAgICAgICAgY29uc3QgcmV1c2VkID0gcmV1c2VkTWFwW2tleV1cbiAgICAgICAgaWYgKHJldXNlZCkge1xuICAgICAgICAgIGlmIChyZXVzZWQuaXRlbSA9PT0gcmV1c2VkTGlzdFswXSkge1xuICAgICAgICAgICAgcmV1c2VkTGlzdC5zaGlmdCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV1c2VkTGlzdC4kcmVtb3ZlKHJldXNlZC5pdGVtKVxuICAgICAgICAgICAgbW92ZVRhcmdldCh2bSwgcmV1c2VkLnRhcmdldCwgZnJhZ0Jsb2NrLnVwZGF0ZU1hcmssIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2gocmV1c2VkLnRhcmdldClcbiAgICAgICAgICB2bXMucHVzaChyZXVzZWQudm0pXG4gICAgICAgICAgaWYgKG9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXVzZWQudm0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV1c2VkLnZtW3ZhbHVlTmFtZV0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldXNlZC52bVtrZXlOYW1lXSA9IGluZGV4XG4gICAgICAgICAgZnJhZ0Jsb2NrLnVwZGF0ZU1hcmsgPSByZXVzZWQudGFyZ2V0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29tcGlsZUl0ZW0oaXRlbSwgaW5kZXgsIHZtKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBkZWxldGUgZnJhZ0Jsb2NrLnVwZGF0ZU1hcmtcbiAgICB9XG4gIClcblxuICBmcmFnQmxvY2suZGF0YSA9IGxpc3Quc2xpY2UoMClcbiAgbGlzdC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbXBpbGVJdGVtKGl0ZW0sIGluZGV4LCB2bSlcbiAgfSlcbn1cblxuLyoqXG4gKiBXYXRjaCB0aGUgZGlzcGxheSB1cGRhdGUgYW5kIGFkZC9yZW1vdmUgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge29iamVjdH0gZnJhZ0Jsb2NrXG4gKiBAcGFyYW0gIHtvYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gYmluZFNob3duICh2bSwgdGFyZ2V0LCBmcmFnQmxvY2ssIG1ldGEpIHtcbiAgY29uc3QgZGlzcGxheSA9IHdhdGNoQmxvY2sodm0sIGZyYWdCbG9jaywgdGFyZ2V0LnNob3duLCAnc2hvd24nLFxuICAgIChkaXNwbGF5KSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdbSlMgRnJhbWV3b3JrXSB0aGUgXCJpZlwiIGl0ZW0gd2FzIGNoYW5nZWQnLCBkaXNwbGF5KVxuXG4gICAgICBpZiAoIWZyYWdCbG9jayB8fCAhIWZyYWdCbG9jay5kaXNwbGF5ID09PSAhIWRpc3BsYXkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBmcmFnQmxvY2suZGlzcGxheSA9ICEhZGlzcGxheVxuICAgICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgICAgY29tcGlsZSh2bSwgdGFyZ2V0LCBmcmFnQmxvY2ssIG1ldGEpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlVGFyZ2V0KHZtLCBmcmFnQmxvY2ssIHRydWUpXG4gICAgICB9XG4gICAgfVxuICApXG5cbiAgZnJhZ0Jsb2NrLmRpc3BsYXkgPSAhIWRpc3BsYXlcbiAgaWYgKGRpc3BsYXkpIHtcbiAgICBjb21waWxlKHZtLCB0YXJnZXQsIGZyYWdCbG9jaywgbWV0YSlcbiAgfVxufVxuXG4vKipcbiAqIFdhdGNoIGNhbGMgdmFsdWUgY2hhbmdlcyBhbmQgYXBwZW5kIGNlcnRhaW4gdHlwZSBhY3Rpb24gdG8gZGlmZmVyLlxuICogSXQgaXMgdXNlZCBmb3IgaWYgb3IgcmVwZWF0IGRhdGEtYmluZGluZyBnZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgIGZyYWdCbG9ja1xuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGNcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gaGFuZGxlclxuICogQHJldHVybiB7YW55fSAgICAgIGluaXQgdmFsdWUgb2YgY2FsY1xuICovXG5mdW5jdGlvbiB3YXRjaEJsb2NrICh2bSwgZnJhZ0Jsb2NrLCBjYWxjLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGNvbnN0IGRpZmZlciA9IHZtICYmIHZtLl9hcHAgJiYgdm0uX2FwcC5kaWZmZXJcbiAgY29uc3QgY29uZmlnID0ge31cbiAgY29uc3QgZGVwdGggPSAoZnJhZ0Jsb2NrLmVsZW1lbnQuZGVwdGggfHwgMCkgKyAxXG5cbiAgcmV0dXJuIHdhdGNoKHZtLCBjYWxjLCAodmFsdWUpID0+IHtcbiAgICBjb25maWcubGF0ZXN0VmFsdWUgPSB2YWx1ZVxuICAgIGlmIChkaWZmZXIgJiYgIWNvbmZpZy5yZWNvcmRlZCkge1xuICAgICAgZGlmZmVyLmFwcGVuZCh0eXBlLCBkZXB0aCwgZnJhZ0Jsb2NrLmJsb2NrSWQsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGF0ZXN0VmFsdWUgPSBjb25maWcubGF0ZXN0VmFsdWVcbiAgICAgICAgaGFuZGxlcihsYXRlc3RWYWx1ZSlcbiAgICAgICAgY29uZmlnLnJlY29yZGVkID0gZmFsc2VcbiAgICAgICAgY29uZmlnLmxhdGVzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICB9KVxuICAgIH1cbiAgICBjb25maWcucmVjb3JkZWQgPSB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogQ2xvbmUgYSBjb250ZXh0IGFuZCBtZXJnZSBjZXJ0YWluIGRhdGEuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBtZXJnZWREYXRhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29udGV4dCAoY29udGV4dCwgbWVyZ2VkRGF0YSkge1xuICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KVxuICBuZXdDb250ZXh0Ll9kYXRhID0gbWVyZ2VkRGF0YVxuICBpbml0RGF0YShuZXdDb250ZXh0KVxuICBpbml0Q29tcHV0ZWQobmV3Q29udGV4dClcbiAgbmV3Q29udGV4dC5fcmVhbFBhcmVudCA9IGNvbnRleHRcbiAgcmV0dXJuIG5ld0NvbnRleHRcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC92bS9jb21waWxlci5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogRGlyZWN0aXZlIFBhcnNlclxuICovXG5cbmltcG9ydCB7IGJpbmQsIHR5cG9mIH0gZnJvbSAnLi4vdXRpbCdcblxuaW1wb3J0IFdhdGNoZXIgZnJvbSAnLi4vY29yZS93YXRjaGVyJ1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5cbmNvbnN0IHsgbmF0aXZlQ29tcG9uZW50TWFwIH0gPSBjb25maWdcblxuY29uc3QgU0VUVEVSUyA9IHtcbiAgYXR0cjogJ3NldEF0dHInLFxuICBzdHlsZTogJ3NldFN0eWxlJyxcbiAgZXZlbnQ6ICdhZGRFdmVudCdcbn1cblxuLyoqXG4gKiBhcHBseSB0aGUgbmF0aXZlIGNvbXBvbmVudCdzIG9wdGlvbnMoc3BlY2lmaWVkIGJ5IHRlbXBsYXRlLnR5cGUpXG4gKiB0byB0aGUgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TmFpdHZlQ29tcG9uZW50T3B0aW9ucyAodGVtcGxhdGUpIHtcbiAgY29uc3QgeyB0eXBlIH0gPSB0ZW1wbGF0ZVxuICBjb25zdCBvcHRpb25zID0gbmF0aXZlQ29tcG9uZW50TWFwW3R5cGVdXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0ZW1wbGF0ZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgdGVtcGxhdGVba2V5XSA9IG9wdGlvbnNba2V5XVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwb2YodGVtcGxhdGVba2V5XSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cG9mKG9wdGlvbnNba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3Via2V5IGluIG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZVtrZXldW3N1YmtleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcGxhdGVba2V5XVtzdWJrZXldID0gb3B0aW9uc1trZXldW3N1YmtleV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBiaW5kIGFsbCBpZCwgYXR0ciwgY2xhc3NuYW1lcywgc3R5bGUsIGV2ZW50cyB0byBhbiBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kRWxlbWVudCAodm0sIGVsLCB0ZW1wbGF0ZSkge1xuICBzZXRJZCh2bSwgZWwsIHRlbXBsYXRlLmlkLCB2bSlcbiAgc2V0QXR0cih2bSwgZWwsIHRlbXBsYXRlLmF0dHIpXG4gIHNldENsYXNzKHZtLCBlbCwgdGVtcGxhdGUuY2xhc3NMaXN0KVxuICBzZXRTdHlsZSh2bSwgZWwsIHRlbXBsYXRlLnN0eWxlKVxuICBiaW5kRXZlbnRzKHZtLCBlbCwgdGVtcGxhdGUuZXZlbnRzKVxufVxuXG4vKipcbiAqIGJpbmQgYWxsIHByb3BzIHRvIHN1YiB2bSBhbmQgYmluZCBhbGwgc3R5bGUsIGV2ZW50cyB0byB0aGUgcm9vdCBlbGVtZW50XG4gKiBvZiB0aGUgc3ViIHZtIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIHJlcGxhY2VkIG11bHRpLW5vZGUgZnJhZ21lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRTdWJWbSAodm0sIHN1YlZtLCB0ZW1wbGF0ZSwgcmVwZWF0SXRlbSkge1xuICBzdWJWbSA9IHN1YlZtIHx8IHt9XG4gIHRlbXBsYXRlID0gdGVtcGxhdGUgfHwge31cblxuICBjb25zdCBvcHRpb25zID0gc3ViVm0uX29wdGlvbnMgfHwge31cblxuICAvLyBiaW5kIHByb3BzXG4gIGxldCBwcm9wcyA9IG9wdGlvbnMucHJvcHNcblxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBwcm9wcyA9IHByb3BzLnJlZHVjZSgocmVzdWx0LCB2YWx1ZSkgPT4ge1xuICAgICAgcmVzdWx0W3ZhbHVlXSA9IHRydWVcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LCB7fSlcbiAgfVxuXG4gIG1lcmdlUHJvcHMocmVwZWF0SXRlbSwgcHJvcHMsIHZtLCBzdWJWbSlcbiAgbWVyZ2VQcm9wcyh0ZW1wbGF0ZS5hdHRyLCBwcm9wcywgdm0sIHN1YlZtKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZFN1YlZtQWZ0ZXJJbml0aWFsaXplZCAodm0sIHN1YlZtLCB0ZW1wbGF0ZSkge1xuICBtZXJnZUNsYXNzU3R5bGUodGVtcGxhdGUuY2xhc3NMaXN0LCB2bSwgc3ViVm0pXG4gIG1lcmdlU3R5bGUodGVtcGxhdGUuc3R5bGUsIHZtLCBzdWJWbSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodGFyZ2V0LCBwcm9wcywgdm0sIHN1YlZtKSB7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCFwcm9wcyB8fCBwcm9wc1trZXldKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtrZXldXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gd2F0Y2godm0sIHZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHN1YlZtW2tleV0gPSB2XG4gICAgICAgIH0pXG4gICAgICAgIHN1YlZtW2tleV0gPSByZXR1cm5WYWx1ZVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN1YlZtW2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZVN0eWxlICh0YXJnZXQsIHZtLCBzdWJWbSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtrZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSB3YXRjaCh2bSwgdmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmIChzdWJWbS5fcm9vdEVsKSB7XG4gICAgICAgICAgc3ViVm0uX3Jvb3RFbC5zZXRTdHlsZShrZXksIHYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBzdWJWbS5fcm9vdEVsLnNldFN0eWxlKGtleSwgcmV0dXJuVmFsdWUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHN1YlZtLl9yb290RWwpIHtcbiAgICAgICAgc3ViVm0uX3Jvb3RFbC5zZXRTdHlsZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzU3R5bGUgKHRhcmdldCwgdm0sIHN1YlZtKSB7XG4gIGNvbnN0IGNzcyA9IHZtLl9vcHRpb25zICYmIHZtLl9vcHRpb25zLnN0eWxlIHx8IHt9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghc3ViVm0uX3Jvb3RFbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHdhdGNoKHZtLCB0YXJnZXQsIHYgPT4ge1xuICAgICAgc2V0Q2xhc3NTdHlsZShzdWJWbS5fcm9vdEVsLCBjc3MsIHYpXG4gICAgfSlcbiAgICBzZXRDbGFzc1N0eWxlKHN1YlZtLl9yb290RWwsIGNzcywgdmFsdWUpXG4gIH1cbiAgZWxzZSBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICBzZXRDbGFzc1N0eWxlKHN1YlZtLl9yb290RWwsIGNzcywgdGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogYmluZCBpZCB0byBhbiBlbGVtZW50XG4gKiBlYWNoIGlkIGlzIHVuaXF1ZSBpbiBhIHdob2xlIHZtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRJZCAodm0sIGVsLCBpZCwgdGFyZ2V0KSB7XG4gIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtYXAsIHtcbiAgICB2bToge1xuICAgICAgdmFsdWU6IHRhcmdldCxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9LFxuICAgIGVsOiB7XG4gICAgICBnZXQ6ICgpID0+IGVsIHx8IHRhcmdldC5fcm9vdEVsLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgfSlcblxuICBpZiAodHlwZW9mIGlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGlkXG4gICAgaWQgPSBoYW5kbGVyLmNhbGwodm0pXG4gICAgaWYgKGlkKSB7XG4gICAgICB2bS5faWRzW2lkXSA9IG1hcFxuICAgIH1cbiAgICB3YXRjaCh2bSwgaGFuZGxlciwgKG5ld0lkKSA9PiB7XG4gICAgICBpZiAobmV3SWQpIHtcbiAgICAgICAgdm0uX2lkc1tuZXdJZF0gPSBtYXBcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2UgaWYgKGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2bS5faWRzW2lkXSA9IG1hcFxuICB9XG59XG5cbi8qKlxuICogYmluZCBhdHRyIHRvIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0ciAodm0sIGVsLCBhdHRyKSB7XG4gIGJpbmREaXIodm0sIGVsLCAnYXR0cicsIGF0dHIpXG59XG5cbmZ1bmN0aW9uIHNldENsYXNzU3R5bGUgKGVsLCBjc3MsIGNsYXNzTGlzdCkge1xuICBjb25zdCBjbGFzc1N0eWxlID0ge31cbiAgY29uc3QgbGVuZ3RoID0gY2xhc3NMaXN0Lmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdHlsZSA9IGNzc1tjbGFzc0xpc3RbaV1dXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgICAgICBjbGFzc1N0eWxlW2tleV0gPSBzdHlsZVtrZXldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsLnNldENsYXNzU3R5bGUoY2xhc3NTdHlsZSlcbn1cblxuLyoqXG4gKiBiaW5kIGNsYXNzbmFtZXMgdG8gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRDbGFzcyAodm0sIGVsLCBjbGFzc0xpc3QpIHtcbiAgaWYgKHR5cGVvZiBjbGFzc0xpc3QgIT09ICdmdW5jdGlvbicgJiYgIUFycmF5LmlzQXJyYXkoY2xhc3NMaXN0KSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTGlzdCkgJiYgIWNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbC5zZXRDbGFzc1N0eWxlKHt9KVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSB2bS5fb3B0aW9ucyAmJiB2bS5fb3B0aW9ucy5zdHlsZSB8fCB7fVxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gd2F0Y2godm0sIGNsYXNzTGlzdCwgdiA9PiB7XG4gICAgICBzZXRDbGFzc1N0eWxlKGVsLCBzdHlsZSwgdilcbiAgICB9KVxuICAgIHNldENsYXNzU3R5bGUoZWwsIHN0eWxlLCB2YWx1ZSlcbiAgfVxuICBlbHNlIHtcbiAgICBzZXRDbGFzc1N0eWxlKGVsLCBzdHlsZSwgY2xhc3NMaXN0KVxuICB9XG59XG5cbi8qKlxuICogYmluZCBzdHlsZSB0byBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlICh2bSwgZWwsIHN0eWxlKSB7XG4gIGJpbmREaXIodm0sIGVsLCAnc3R5bGUnLCBzdHlsZSlcbn1cblxuLyoqXG4gKiBhZGQgYW4gZXZlbnQgdHlwZSBhbmQgaGFuZGxlciB0byBhbiBlbGVtZW50IGFuZCBnZW5lcmF0ZSBhIGRvbSB1cGRhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnQgKHZtLCBlbCwgdHlwZSwgaGFuZGxlcikge1xuICBlbC5hZGRFdmVudCh0eXBlLCBiaW5kKGhhbmRsZXIsIHZtKSlcbn1cblxuLyoqXG4gKiBhZGQgYWxsIGV2ZW50cyBvZiBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudHMgKHZtLCBlbCwgZXZlbnRzKSB7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cylcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGxldCBoYW5kbGVyID0gZXZlbnRzW2tleV1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoYW5kbGVyID0gdm1baGFuZGxlcl1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIFRoZSBtZXRob2QgXCIke2hhbmRsZXJ9XCIgaXMgbm90IGRlZmluZWQuYClcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXZlbnQodm0sIGVsLCBrZXksIGhhbmRsZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBzZXQgYSBzZXJpZXMgb2YgbWVtYmVycyBhcyBhIGtpbmQgb2YgYW4gZWxlbWVudFxuICogZm9yIGV4YW1wbGU6IHN0eWxlLCBhdHRyLCAuLi5cbiAqIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHRoZW4gYmluZCB0aGUgZGF0YSBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGJpbmREaXIgKHZtLCBlbCwgbmFtZSwgZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmluZEtleSh2bSwgZWwsIG5hbWUsIGtleSwgdmFsdWUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxbU0VUVEVSU1tuYW1lXV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBiaW5kIGRhdGEgY2hhbmdlcyB0byBhIGNlcnRhaW4ga2V5IHRvIGEgbmFtZSBzZXJpZXMgaW4gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBiaW5kS2V5ICh2bSwgZWwsIG5hbWUsIGtleSwgY2FsYykge1xuICBjb25zdCBtZXRob2ROYW1lID0gU0VUVEVSU1tuYW1lXVxuICAvLyB3YXRjaCB0aGUgY2FsYywgYW5kIHJldHVybnMgYSB2YWx1ZSBieSBjYWxjLmNhbGwoKVxuICBjb25zdCB2YWx1ZSA9IHdhdGNoKHZtLCBjYWxjLCAodmFsdWUpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyICgpIHtcbiAgICAgIGVsW21ldGhvZE5hbWVdKGtleSwgdmFsdWUpXG4gICAgfVxuICAgIGNvbnN0IGRpZmZlciA9IHZtICYmIHZtLl9hcHAgJiYgdm0uX2FwcC5kaWZmZXJcbiAgICBpZiAoZGlmZmVyKSB7XG4gICAgICBkaWZmZXIuYXBwZW5kKCdlbGVtZW50JywgZWwuZGVwdGgsIGVsLnJlZiwgaGFuZGxlcilcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoYW5kbGVyKClcbiAgICB9XG4gIH0pXG5cbiAgZWxbbWV0aG9kTmFtZV0oa2V5LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiB3YXRjaCBhIGNhbGMgZnVuY3Rpb24gYW5kIGNhbGxiYWNrIGlmIHRoZSBjYWxjIHZhbHVlIGNoYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoICh2bSwgY2FsYywgY2FsbGJhY2spIHtcbiAgY29uc3Qgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBjYWxjLCBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbGJhY2sodmFsdWUpXG4gIH0pXG5cbiAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC92bS9kaXJlY3RpdmUuanNcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCB7XG4gIG5hdGl2ZUNvbXBvbmVudE1hcDoge1xuICAgIHRleHQ6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgY29udGFpbmVyOiB0cnVlLFxuICAgIHNsaWRlcjoge1xuICAgICAgdHlwZTogJ3NsaWRlcicsXG4gICAgICBhcHBlbmQ6ICd0cmVlJ1xuICAgIH0sXG4gICAgY2VsbDoge1xuICAgICAgdHlwZTogJ2NlbGwnLFxuICAgICAgYXBwZW5kOiAndHJlZSdcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9jb25maWcuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgRG9jdW1lbnQgJiBFbGVtZW50IEhlbHBlcnMuXG4gKlxuICogcmVxdWlyZWQ6XG4gKiBEb2N1bWVudCM6IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZUNvbW1lbnQsIGdldFJlZlxuICogRWxlbWVudCM6IGFwcGVuZENoaWxkLCBpbnNlcnRCZWZvcmUsIHJlbW92ZUNoaWxkLCBuZXh0U2libGluZ1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgYm9keSBieSB0eXBlXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb2R5ICh2bSwgdHlwZSkge1xuICBjb25zdCBkb2MgPSB2bS5fYXBwLmRvY1xuICByZXR1cm4gZG9jLmNyZWF0ZUJvZHkodHlwZSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWxlbWVudCBieSB0eXBlXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50ICh2bSwgdHlwZSkge1xuICBjb25zdCBkb2MgPSB2bS5fYXBwLmRvY1xuICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIGZyYWcgYmxvY2sgZm9yIGFuIGVsZW1lbnQuXG4gKiBUaGUgZnJhZyBibG9jayBoYXMgYSBzdGFydGVyLCBlbmRlciBhbmQgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmxvY2sgKHZtLCBlbGVtZW50KSB7XG4gIGNvbnN0IHN0YXJ0ID0gY3JlYXRlQmxvY2tTdGFydCh2bSlcbiAgY29uc3QgZW5kID0gY3JlYXRlQmxvY2tFbmQodm0pXG4gIGNvbnN0IGJsb2NrSWQgPSBsYXN0ZXN0QmxvY2tJZCsrXG4gIGlmIChlbGVtZW50LmVsZW1lbnQpIHtcbiAgICBsZXQgdXBkYXRlTWFyayA9IGVsZW1lbnQudXBkYXRlTWFya1xuICAgIGlmICh1cGRhdGVNYXJrKSB7XG4gICAgICBpZiAodXBkYXRlTWFyay5lbGVtZW50KSB7XG4gICAgICAgIHVwZGF0ZU1hcmsgPSB1cGRhdGVNYXJrLmVuZFxuICAgICAgfVxuICAgICAgZWxlbWVudC5lbGVtZW50Lmluc2VydEFmdGVyKGVuZCwgdXBkYXRlTWFyaylcbiAgICAgIGVsZW1lbnQuZWxlbWVudC5pbnNlcnRBZnRlcihzdGFydCwgdXBkYXRlTWFyaylcbiAgICAgIGVsZW1lbnQudXBkYXRlTWFyayA9IGVuZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnQuZWxlbWVudC5pbnNlcnRCZWZvcmUoc3RhcnQsIGVsZW1lbnQuZW5kKVxuICAgICAgZWxlbWVudC5lbGVtZW50Lmluc2VydEJlZm9yZShlbmQsIGVsZW1lbnQuZW5kKVxuICAgIH1cbiAgICBlbGVtZW50ID0gZWxlbWVudC5lbGVtZW50XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChzdGFydClcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVuZClcbiAgfVxuICByZXR1cm4geyBzdGFydCwgZW5kLCBlbGVtZW50LCBibG9ja0lkIH1cbn1cblxubGV0IGxhc3Rlc3RCbG9ja0lkID0gMVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgYmxvY2sgc3RhcnRlci5cbiAqIFVzaW5nIHRoaXMuX2FwcC5kb2NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGFydCAodm0pIHtcbiAgY29uc3QgZG9jID0gdm0uX2FwcC5kb2NcbiAgY29uc3QgYW5jaG9yID0gZG9jLmNyZWF0ZUNvbW1lbnQoJ3N0YXJ0JylcbiAgcmV0dXJuIGFuY2hvclxufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgYmxvY2sgZW5kZXIuXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrRW5kICh2bSkge1xuICBjb25zdCBkb2MgPSB2bS5fYXBwLmRvY1xuICBjb25zdCBhbmNob3IgPSBkb2MuY3JlYXRlQ29tbWVudCgnZW5kJylcbiAgcmV0dXJuIGFuY2hvclxufVxuXG4vKipcbiAqIEF0dGFjaCB0YXJnZXQgdG8gYSBjZXJ0YWluIGRlc3QgdXNpbmcgYXBwZW5kQ2hpbGQgYnkgZGVmYXVsdC5cbiAqIElmIHRoZSBkZXN0IGlzIGEgZnJhZyBibG9jayB0aGVuIGluc2VydCBiZWZvcmUgdGhlIGVuZGVyLlxuICogSWYgdGhlIHRhcmdldCBpcyBhIGZyYWcgYmxvY2sgdGhlbiBhdHRhY2ggdGhlIHN0YXJ0ZXIgYW5kIGVuZGVyIGluIG9yZGVyLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaFRhcmdldCAodm0sIHRhcmdldCwgZGVzdCkge1xuICBpZiAoZGVzdC5lbGVtZW50KSB7XG4gICAgY29uc3QgYmVmb3JlID0gZGVzdC5lbmRcbiAgICBjb25zdCBhZnRlciA9IGRlc3QudXBkYXRlTWFya1xuICAgIC8vIHB1c2ggbmV3IHRhcmdldCBmb3Igd2F0Y2ggbGlzdCB1cGRhdGUgbGF0ZXJcbiAgICBpZiAoZGVzdC5jaGlsZHJlbikge1xuICAgICAgZGVzdC5jaGlsZHJlbi5wdXNoKHRhcmdldClcbiAgICB9XG4gICAgLy8gZm9yIGNoZWNrIHJlcGVhdCBjYXNlXG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBjb25zdCBzaWduYWwgPSBtb3ZlVGFyZ2V0KHZtLCB0YXJnZXQsIGFmdGVyKVxuICAgICAgZGVzdC51cGRhdGVNYXJrID0gdGFyZ2V0LmVsZW1lbnQgPyB0YXJnZXQuZW5kIDogdGFyZ2V0XG4gICAgICByZXR1cm4gc2lnbmFsXG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldC5lbGVtZW50KSB7XG4gICAgICBkZXN0LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRhcmdldC5zdGFydCwgYmVmb3JlKVxuICAgICAgZGVzdC5lbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQuZW5kLCBiZWZvcmUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGRlc3QuZWxlbWVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBiZWZvcmUpXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgICAgZGVzdC5hcHBlbmRDaGlsZCh0YXJnZXQuc3RhcnQpXG4gICAgICBkZXN0LmFwcGVuZENoaWxkKHRhcmdldC5lbmQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGRlc3QuYXBwZW5kQ2hpbGQodGFyZ2V0KVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1vdmUgdGFyZ2V0IGJlZm9yZSBhIGNlcnRhaW4gZWxlbWVudC4gVGhlIHRhcmdldCBtYXliZSBibG9jayBvciBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtvYmplY3R9IGJlZm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZVRhcmdldCAodm0sIHRhcmdldCwgYWZ0ZXIpIHtcbiAgaWYgKHRhcmdldC5lbGVtZW50KSB7XG4gICAgcmV0dXJuIG1vdmVCbG9jayh0YXJnZXQsIGFmdGVyKVxuICB9XG4gIHJldHVybiBtb3ZlRWxlbWVudCh0YXJnZXQsIGFmdGVyKVxufVxuXG4vKipcbiAqIE1vdmUgZWxlbWVudCBiZWZvcmUgYSBjZXJ0YWluIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0gIHtvYmplY3R9IGJlZm9yZVxuICovXG5mdW5jdGlvbiBtb3ZlRWxlbWVudCAoZWxlbWVudCwgYWZ0ZXIpIHtcbiAgY29uc3QgcGFyZW50ID0gYWZ0ZXIucGFyZW50Tm9kZVxuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIHBhcmVudC5pbnNlcnRBZnRlcihlbGVtZW50LCBhZnRlcilcbiAgfVxufVxuXG4vKipcbiAqIE1vdmUgYWxsIGVsZW1lbnRzIG9mIHRoZSBibG9jayBiZWZvcmUgYSBjZXJ0YWluIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBmcmFnQmxvY2tcbiAqIEBwYXJhbSAge29iamVjdH0gYmVmb3JlXG4gKi9cbmZ1bmN0aW9uIG1vdmVCbG9jayAoZnJhZ0Jsb2NrLCBhZnRlcikge1xuICBjb25zdCBwYXJlbnQgPSBhZnRlci5wYXJlbnROb2RlXG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGxldCBlbCA9IGZyYWdCbG9jay5zdGFydFxuICAgIGxldCBzaWduYWxcbiAgICBjb25zdCBncm91cCA9IFtlbF1cblxuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZnJhZ0Jsb2NrLmVuZCkge1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZ1xuICAgICAgZ3JvdXAucHVzaChlbClcbiAgICB9XG5cbiAgICBsZXQgdGVtcCA9IGFmdGVyXG4gICAgZ3JvdXAuZXZlcnkoKGVsKSA9PiB7XG4gICAgICBzaWduYWwgPSBwYXJlbnQuaW5zZXJ0QWZ0ZXIoZWwsIHRlbXApXG4gICAgICB0ZW1wID0gZWxcbiAgICAgIHJldHVybiBzaWduYWwgIT09IC0xXG4gICAgfSlcblxuICAgIHJldHVybiBzaWduYWxcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSB0YXJnZXQgZnJvbSBET00gdHJlZS5cbiAqIElmIHRoZSB0YXJnZXQgaXMgYSBmcmFnIGJsb2NrIHRoZW4gY2FsbCBfcmVtb3ZlQmxvY2tcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0ICh2bSwgdGFyZ2V0LCBwcmVzZXJ2ZUJsb2NrID0gZmFsc2UpIHtcbiAgaWYgKHRhcmdldC5lbGVtZW50KSB7XG4gICAgcmVtb3ZlQmxvY2sodGFyZ2V0LCBwcmVzZXJ2ZUJsb2NrKVxuICB9XG4gIGVsc2Uge1xuICAgIHJlbW92ZUVsZW1lbnQodGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2VydGFpbiBlbGVtZW50LlxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQgKHRhcmdldCkge1xuICBjb25zdCBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgZnJhZyBibG9jay5cbiAqIFRoZSBzZWNvbmQgcGFyYW0gZGVjaWRlcyB3aGV0aGVyIHRoZSBibG9jayBzZWxmIHNob3VsZCBiZSByZW1vdmVkIHRvby5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBmcmFnQmxvY2tcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHByZXNlcnZlQmxvY2s9ZmFsc2VcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQmxvY2sgKGZyYWdCbG9jaywgcHJlc2VydmVCbG9jayA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGxldCBlbCA9IGZyYWdCbG9jay5zdGFydC5uZXh0U2libGluZ1xuXG4gIHdoaWxlIChlbCAmJiBlbCAhPT0gZnJhZ0Jsb2NrLmVuZCkge1xuICAgIHJlc3VsdC5wdXNoKGVsKVxuICAgIGVsID0gZWwubmV4dFNpYmxpbmdcbiAgfVxuXG4gIGlmICghcHJlc2VydmVCbG9jaykge1xuICAgIHJlbW92ZUVsZW1lbnQoZnJhZ0Jsb2NrLnN0YXJ0KVxuICB9XG4gIHJlc3VsdC5mb3JFYWNoKChlbCkgPT4ge1xuICAgIHJlbW92ZUVsZW1lbnQoZWwpXG4gIH0pXG4gIGlmICghcHJlc2VydmVCbG9jaykge1xuICAgIHJlbW92ZUVsZW1lbnQoZnJhZ0Jsb2NrLmVuZClcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdm0vZG9tLWhlbHBlci5qc1xuICoqLyIsImZ1bmN0aW9uIEV2dCAodHlwZSwgZGV0YWlsKSB7XG4gIGlmIChkZXRhaWwgaW5zdGFuY2VvZiBFdnQpIHtcbiAgICByZXR1cm4gZGV0YWlsXG4gIH1cblxuICB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgdGhpcy5kZXRhaWwgPSBkZXRhaWxcbiAgdGhpcy50eXBlID0gdHlwZVxuXG4gIGxldCBzaG91bGRTdG9wID0gZmFsc2VcbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHNob3VsZFN0b3AgPSB0cnVlXG4gIH1cbiAgdGhpcy5oYXNTdG9wcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzaG91bGRTdG9wXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRlbWl0ICh0eXBlLCBkZXRhaWwpIHtcbiAgY29uc3QgZXZlbnRzID0gdGhpcy5fdm1FdmVudHNcbiAgY29uc3QgaGFuZGxlckxpc3QgPSBldmVudHNbdHlwZV1cbiAgaWYgKGhhbmRsZXJMaXN0KSB7XG4gICAgY29uc3QgZXZ0ID0gbmV3IEV2dCh0eXBlLCBkZXRhaWwpXG4gICAgaGFuZGxlckxpc3QuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2dClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkZGlzcGF0Y2ggKHR5cGUsIGRldGFpbCkge1xuICBjb25zdCBldnQgPSBuZXcgRXZ0KHR5cGUsIGRldGFpbClcbiAgdGhpcy4kZW1pdCh0eXBlLCBldnQpXG5cbiAgaWYgKCFldnQuaGFzU3RvcHBlZCgpICYmIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuJGRpc3BhdGNoKSB7XG4gICAgdGhpcy5fcGFyZW50LiRkaXNwYXRjaCh0eXBlLCBldnQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRicm9hZGNhc3QgKHR5cGUsIGRldGFpbCkge1xuICBjb25zdCBldnQgPSBuZXcgRXZ0KHR5cGUsIGRldGFpbClcbiAgdGhpcy4kZW1pdCh0eXBlLCBldnQpXG5cbiAgaWYgKCFldnQuaGFzU3RvcHBlZCgpICYmIHRoaXMuX2NoaWxkcmVuVm1zKSB7XG4gICAgdGhpcy5fY2hpbGRyZW5WbXMuZm9yRWFjaCgoc3ViVm0pID0+IHtcbiAgICAgIHN1YlZtLiRicm9hZGNhc3QodHlwZSwgZXZ0KVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRvbiAodHlwZSwgaGFuZGxlcikge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBldmVudHMgPSB0aGlzLl92bUV2ZW50c1xuICBjb25zdCBoYW5kbGVyTGlzdCA9IGV2ZW50c1t0eXBlXSB8fCBbXVxuICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXIpXG4gIGV2ZW50c1t0eXBlXSA9IGhhbmRsZXJMaXN0XG5cbiAgLy8gZml4ZWQgb2xkIHZlcnNpb24gbGlmZWN5Y2xlIGRlc2lnblxuICBpZiAodHlwZSA9PT0gJ2hvb2s6cmVhZHknICYmIHRoaXMuX3JlYWR5KSB7XG4gICAgdGhpcy4kZW1pdCgnaG9vazpyZWFkeScpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRvZmYgKHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgZXZlbnRzID0gdGhpcy5fdm1FdmVudHNcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgZGVsZXRlIGV2ZW50c1t0eXBlXVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGhhbmRsZXJMaXN0ID0gZXZlbnRzW3R5cGVdXG4gIGlmICghaGFuZGxlckxpc3QpIHtcbiAgICByZXR1cm5cbiAgfVxuICBoYW5kbGVyTGlzdC4kcmVtb3ZlKGhhbmRsZXIpXG59XG5cbmNvbnN0IExJRkVfQ1lDTEVfVFlQRVMgPSBbJ2luaXQnLCAnY3JlYXRlZCcsICdyZWFkeSddXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RXZlbnRzICh2bSwgZXh0ZXJuYWxFdmVudHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLl9vcHRpb25zIHx8IHt9XG4gIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IHt9XG4gIGZvciAoY29uc3QgdHlwZTEgaW4gZXZlbnRzKSB7XG4gICAgdm0uJG9uKHR5cGUxLCBldmVudHNbdHlwZTFdKVxuICB9XG4gIGZvciAoY29uc3QgdHlwZTIgaW4gZXh0ZXJuYWxFdmVudHMpIHtcbiAgICB2bS4kb24odHlwZTIsIGV4dGVybmFsRXZlbnRzW3R5cGUyXSlcbiAgfVxuICBMSUZFX0NZQ0xFX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICB2bS4kb24oYGhvb2s6JHt0eXBlfWAsIG9wdGlvbnNbdHlwZV0pXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbkV2ZW50cyAodm0pIHtcbiAgdm0uJGVtaXQgPSAkZW1pdFxuICB2bS4kZGlzcGF0Y2ggPSAkZGlzcGF0Y2hcbiAgdm0uJGJyb2FkY2FzdCA9ICRicm9hZGNhc3RcbiAgdm0uJG9uID0gJG9uXG4gIHZtLiRvZmYgPSAkb2ZmXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdm0vZXZlbnRzLmpzXG4gKiovIiwibGV0IG5hdGl2ZU1vZHVsZXMgPSB7fVxuXG5mdW5jdGlvbiBhc3NpZ25Nb2R1bGVzIChtb2R1bGVzLCBpZlJlcGxhY2UpIHtcbiAgZm9yIChjb25zdCBtb2R1bGVOYW1lIGluIG1vZHVsZXMpIHtcbiAgICAvLyBpbml0IGBtb2R1bGVzW21vZHVsZU5hbWVdW11gXG4gICAgbGV0IG1ldGhvZHMgPSBuYXRpdmVNb2R1bGVzW21vZHVsZU5hbWVdXG4gICAgaWYgKCFtZXRob2RzKSB7XG4gICAgICBtZXRob2RzID0ge31cbiAgICAgIG5hdGl2ZU1vZHVsZXNbbW9kdWxlTmFtZV0gPSBtZXRob2RzXG4gICAgfVxuXG4gICAgLy8gcHVzaCBlYWNoIG5vbi1leGlzdGVkIG5ldyBtZXRob2RcbiAgICBtb2R1bGVzW21vZHVsZU5hbWVdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1ldGhvZCA9IHtcbiAgICAgICAgICBuYW1lOiBtZXRob2RcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGhvZHNbbWV0aG9kLm5hbWVdIHx8IGlmUmVwbGFjZSkge1xuICAgICAgICBtZXRob2RzW21ldGhvZC5uYW1lXSA9IG1ldGhvZFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduQXBpcyAoQ3RvciwgYXBpcykge1xuICBjb25zdCBwID0gQ3Rvci5wcm90b3R5cGVcblxuICBmb3IgKGNvbnN0IGFwaU5hbWUgaW4gYXBpcykge1xuICAgIGlmICghcC5oYXNPd25Qcm9wZXJ0eShhcGlOYW1lKSkge1xuICAgICAgcFthcGlOYW1lXSA9IGFwaXNbYXBpTmFtZV1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTW9kdWxlcyAoKSB7XG4gIG5hdGl2ZU1vZHVsZXMgPSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kdWxlIChtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBuYXRpdmVNb2R1bGVzW21vZHVsZU5hbWVdXG59XG5cbi8qKlxuICogQGNvbnRleHQgYSBpbnN0YW5jZSBvZiBBcHBJbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZU1vZHVsZSAobW9kdWxlTmFtZSkge1xuICBjb25zdCBtZXRob2RzID0gbmF0aXZlTW9kdWxlc1ttb2R1bGVOYW1lXVxuICBjb25zdCB0YXJnZXQgPSB7fVxuXG4gIGZvciAoY29uc3QgbWV0aG9kTmFtZSBpbiBtZXRob2RzKSB7XG4gICAgdGFyZ2V0W21ldGhvZE5hbWVdID0gKC4uLmFyZ3MpID0+IHRoaXMuY2FsbFRhc2tzKHtcbiAgICAgIG1vZHVsZTogbW9kdWxlTmFtZSxcbiAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIEBjb250ZXh0IFZtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZXMgKG1vZHVsZXMsIGlmUmVwbGFjZSkge1xuICBhc3NpZ25Nb2R1bGVzKG1vZHVsZXMsIGlmUmVwbGFjZSlcbn1cblxuLyoqXG4gKiBAY29udGV4dCBWbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNZXRob2RzIChhcGlzKSB7XG4gIGFzc2lnbkFwaXModGhpcywgYXBpcylcbn1cblxuLyoqXG4gKiBAY29udGV4dCBhIGluc3RhbmNlIG9mIEFwcEluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlQ29tcG9uZW50IChuYW1lKSB7XG4gIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50TWFwIH0gPSB0aGlzXG4gIHJldHVybiBjdXN0b21Db21wb25lbnRNYXBbbmFtZV1cbn1cblxuLyoqXG4gKiBAY29udGV4dCBhIGluc3RhbmNlIG9mIEFwcEluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudCAobmFtZSwgZGVmKSB7XG4gIGNvbnN0IHsgY3VzdG9tQ29tcG9uZW50TWFwIH0gPSB0aGlzXG5cbiAgaWYgKGN1c3RvbUNvbXBvbmVudE1hcFtuYW1lXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtKUyBGcmFtZXdvcmtdIGRlZmluZSBhIGNvbXBvbmVudCgke25hbWV9KSB0aGF0IGFscmVhZHkgZXhpc3RzYClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGN1c3RvbUNvbXBvbmVudE1hcFtuYW1lXSA9IGRlZlxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2FwcC9yZWdpc3Rlci5qc1xuICoqLyIsImNvbnN0IFdFRVhfQ09NUE9ORU5UX1JFRyA9IC9eQHdlZXgtY29tcG9uZW50XFwvL1xuY29uc3QgV0VFWF9NT0RVTEVfUkVHID0gL15Ad2VleC1tb2R1bGVcXC8vXG5jb25zdCBOT1JNQUxfTU9EVUxFX1JFRyA9IC9eXFwuezEsMn1cXC8vXG5jb25zdCBKU19TVVJGSVhfUkVHID0gL1xcLmpzJC9cblxuZXhwb3J0IGNvbnN0IGlzV2VleENvbXBvbmVudCA9IG5hbWUgPT4gISFuYW1lLm1hdGNoKFdFRVhfQ09NUE9ORU5UX1JFRylcbmV4cG9ydCBjb25zdCBpc1dlZXhNb2R1bGUgPSBuYW1lID0+ICEhbmFtZS5tYXRjaChXRUVYX01PRFVMRV9SRUcpXG5leHBvcnQgY29uc3QgaXNOb3JtYWxNb2R1bGUgPSBuYW1lID0+ICEhbmFtZS5tYXRjaChOT1JNQUxfTU9EVUxFX1JFRylcbmV4cG9ydCBjb25zdCBpc05wbU1vZHVsZSA9IG5hbWUgPT4gIWlzV2VleENvbXBvbmVudChuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzV2VleE1vZHVsZShuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzTm9ybWFsTW9kdWxlKG5hbWUpXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVXZWV4UHJlZml4IChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFdFRVhfQ09NUE9ORU5UX1JFRywgJycpXG4gICAgICAgICAgLnJlcGxhY2UoV0VFWF9NT0RVTEVfUkVHLCAnJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUpTU3VyZml4IChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEpTX1NVUkZJWF9SRUcsICcnKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2FwcC9idW5kbGUvbWlzYy5qc1xuICoqLyIsImltcG9ydCB7IHR5cG9mIH0gZnJvbSAnLi4vLi4vdXRpbCdcbmltcG9ydCBWbSBmcm9tICcuLi8uLi92bSdcbmltcG9ydCB7XG4gIGlzV2VleENvbXBvbmVudCxcbiAgaXNXZWV4TW9kdWxlLFxuICBpc05vcm1hbE1vZHVsZSxcbiAgaXNOcG1Nb2R1bGUsXG4gIHJlbW92ZVdlZXhQcmVmaXgsXG4gIHJlbW92ZUpTU3VyZml4XG59IGZyb20gJy4vbWlzYydcblxubGV0IGNvbW1vbk1vZHVsZXMgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDb21tb25Nb2R1bGVzICgpIHtcbiAgY29tbW9uTW9kdWxlcyA9IHt9XG59XG5cbi8vIGRlZmluZShuYW1lLCBmYWN0b3J5KSBmb3IgcHJpbWFyeSB1c2FnZVxuLy8gb3Jcbi8vIGRlZmluZShuYW1lLCBkZXBzLCBmYWN0b3J5KSBmb3IgY29tcGF0aWJpbGl0eVxuLy8gTm90aWNlOiBETyBOT1QgdXNlIGZ1bmN0aW9uIGRlZmluZSgpIHt9LFxuLy8gaXQgd2lsbCBjYXVzZSBlcnJvciBhZnRlciBidWlsZGVkIGJ5IHdlYnBhY2tcbmV4cG9ydCBjb25zdCBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgZmFjdG9yeSkge1xuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBkZWZpbmUgYSBjb21wb25lbnQgJHtuYW1lfWApXG5cbiAgaWYgKHR5cG9mKGRlcHMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmFjdG9yeSA9IGRlcHNcbiAgICBkZXBzID0gW11cbiAgfVxuXG4gIGNvbnN0IF9yZXF1aXJlID0gKG5hbWUpID0+IHtcbiAgICBsZXQgY2xlYW5OYW1lXG5cbiAgICBpZiAoaXNXZWV4Q29tcG9uZW50KG5hbWUpKSB7XG4gICAgICBjbGVhbk5hbWUgPSByZW1vdmVXZWV4UHJlZml4KG5hbWUpXG4gICAgICByZXR1cm4gdGhpcy5yZXF1aXJlQ29tcG9uZW50KGNsZWFuTmFtZSlcbiAgICB9XG4gICAgaWYgKGlzV2VleE1vZHVsZShuYW1lKSkge1xuICAgICAgY2xlYW5OYW1lID0gcmVtb3ZlV2VleFByZWZpeChuYW1lKVxuICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZU1vZHVsZShjbGVhbk5hbWUpXG4gICAgfVxuICAgIGlmIChpc05vcm1hbE1vZHVsZShuYW1lKSkge1xuICAgICAgY2xlYW5OYW1lID0gcmVtb3ZlSlNTdXJmaXgobmFtZSlcbiAgICAgIHJldHVybiBjb21tb25Nb2R1bGVzW25hbWVdXG4gICAgfVxuICAgIGlmIChpc05wbU1vZHVsZShuYW1lKSkge1xuICAgICAgY2xlYW5OYW1lID0gcmVtb3ZlSlNTdXJmaXgobmFtZSlcbiAgICAgIHJldHVybiBjb21tb25Nb2R1bGVzW25hbWVdXG4gICAgfVxuICB9XG4gIGNvbnN0IF9tb2R1bGUgPSB7IGV4cG9ydHM6IHt9fVxuXG4gIGxldCBjbGVhbk5hbWVcbiAgaWYgKGlzV2VleENvbXBvbmVudChuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcblxuICAgIGZhY3RvcnkoX3JlcXVpcmUsIF9tb2R1bGUuZXhwb3J0cywgX21vZHVsZSlcblxuICAgIHRoaXMucmVnaXN0ZXJDb21wb25lbnQoY2xlYW5OYW1lLCBfbW9kdWxlLmV4cG9ydHMpXG4gIH1cbiAgZWxzZSBpZiAoaXNXZWV4TW9kdWxlKG5hbWUpKSB7XG4gICAgY2xlYW5OYW1lID0gcmVtb3ZlV2VleFByZWZpeChuYW1lKVxuXG4gICAgZmFjdG9yeShfcmVxdWlyZSwgX21vZHVsZS5leHBvcnRzLCBfbW9kdWxlKVxuXG4gICAgVm0ucmVnaXN0ZXJNb2R1bGVzKHtcbiAgICAgIFtjbGVhbk5hbWVdOiBfbW9kdWxlLmV4cG9ydHNcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYgKGlzTm9ybWFsTW9kdWxlKG5hbWUpKSB7XG4gICAgY2xlYW5OYW1lID0gcmVtb3ZlSlNTdXJmaXgobmFtZSlcblxuICAgIGZhY3RvcnkoX3JlcXVpcmUsIF9tb2R1bGUuZXhwb3J0cywgX21vZHVsZSlcblxuICAgIGNvbW1vbk1vZHVsZXNbY2xlYW5OYW1lXSA9IF9tb2R1bGUuZXhwb3J0c1xuICB9XG4gIGVsc2UgaWYgKGlzTnBtTW9kdWxlKG5hbWUpKSB7XG4gICAgY2xlYW5OYW1lID0gcmVtb3ZlSlNTdXJmaXgobmFtZSlcblxuICAgIGZhY3RvcnkoX3JlcXVpcmUsIF9tb2R1bGUuZXhwb3J0cywgX21vZHVsZSlcblxuICAgIGNvbnN0IGV4cG9ydHMgPSBfbW9kdWxlLmV4cG9ydHNcbiAgICBpZiAoZXhwb3J0cy50ZW1wbGF0ZSB8fFxuICAgICAgICBleHBvcnRzLnN0eWxlIHx8XG4gICAgICAgIGV4cG9ydHMubWV0aG9kcykge1xuICAgICAgLy8gZG93bmdyYWRlIHRvIG9sZCBkZWZpbmUgbWV0aG9kIChkZWZpbmUoJ2NvbXBvbmVudE5hbWUnLCBmYWN0b3J5KSlcbiAgICAgIC8vIHRoZSBleHBvcnRzIGNvbnRhaW4gb25lIGtleSBvZiB0ZW1wbGF0ZSwgc3R5bGUgb3IgbWV0aG9kc1xuICAgICAgLy8gYnV0IGl0IGhhcyByaXNrISEhXG4gICAgICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KGNsZWFuTmFtZSwgZXhwb3J0cylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb21tb25Nb2R1bGVzW2NsZWFuTmFtZV0gPSBfbW9kdWxlLmV4cG9ydHNcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIgKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBSZWdpc3RlciBpcyBkZXByZWNhdGVkLCBwbGVhc2UgaW5zdGFsbCBsYXN0ZXN0IHRyYW5zZm9ybWVyLicpXG4gIHRoaXMucmVnaXN0ZXJDb21wb25lbnQodHlwZSwgb3B0aW9ucylcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL2RlZmluZS5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogaW5zdGFuY2UgY29udHJvbHMgZnJvbSBuYXRpdmVcbiAqXG4gKiAtIGZpcmUgZXZlbnRcbiAqIC0gY2FsbGJhY2tcbiAqIC0gZGVzdHJveVxuICpcbiAqIGNvcnJlc3BvbmRlZCB3aXRoIHRoZSBBUEkgb2YgaW5zdGFuY2UgbWFuYWdlciAoZnJhbWV3b3JrLmpzKVxuICovXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi8uLi91dGlsJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWN0aW9ucyAoKSB7XG4gIHRoaXMuZGlmZmVyLmZsdXNoKClcbiAgY29uc3QgdGFza3MgPSBbXVxuICBpZiAodGhpcy5kb2MgJiYgdGhpcy5kb2MubGlzdGVuZXIgJiYgdGhpcy5kb2MubGlzdGVuZXIudXBkYXRlcy5sZW5ndGgpIHtcbiAgICB0YXNrcy5wdXNoKC4uLnRoaXMuZG9jLmxpc3RlbmVyLnVwZGF0ZXMpXG4gICAgdGhpcy5kb2MubGlzdGVuZXIudXBkYXRlcyA9IFtdXG4gIH1cbiAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxUYXNrcyh0YXNrcylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIERlc3RvcnkgYW4gaW5zdGFuY2UoJHt0aGlzLmlkfSlgKVxuXG4gIHRoaXMuaWQgPSAnJ1xuICB0aGlzLm9wdGlvbnMgPSBudWxsXG4gIHRoaXMuYmxvY2tzID0gbnVsbFxuICB0aGlzLnZtID0gbnVsbFxuICB0aGlzLmRvYyA9IG51bGxcbiAgdGhpcy5jdXN0b21Db21wb25lbnRNYXAgPSBudWxsXG4gIHRoaXMuY2FsbGJhY2tzID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdEVsZW1lbnQgKCkge1xuICBjb25zdCBkb2MgPSB0aGlzLmRvYyB8fCB7fVxuICBjb25zdCBib2R5ID0gZG9jLmJvZHkgfHwge31cbiAgcmV0dXJuIGJvZHkudG9KU09OID8gYm9keS50b0pTT04oKSA6IHt9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJlRXZlbnQgKHJlZiwgdHlwZSwgZSwgZG9tQ2hhbmdlcykge1xuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBGaXJlIGEgXCIke3R5cGV9XCIgZXZlbnQgb24gYW4gZWxlbWVudCgke3JlZn0pIGluIGluc3RhbmNlKCR7dGhpcy5pZH0pYClcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVmKSkge1xuICAgIHJlZi5zb21lKChyZWYpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpcmVFdmVudChyZWYsIHR5cGUsIGUpICE9PSBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBlbCA9IHRoaXMuZG9jLmdldFJlZihyZWYpXG5cbiAgaWYgKGVsKSB7XG4gICAgdGhpcy5kb2MuY2xvc2UoKVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9jLmZpcmVFdmVudChlbCwgdHlwZSwgZSwgZG9tQ2hhbmdlcylcbiAgICB0aGlzLnVwZGF0ZUFjdGlvbnMoKVxuICAgIHRoaXMuZG9jLmxpc3RlbmVyLnVwZGF0ZUZpbmlzaCgpXG4gICAgdGhpcy5kb2Mub3BlbigpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBlbGVtZW50IHJlZmVyZW5jZSBcIiR7cmVmfVwiYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrIChjYWxsYmFja0lkLCBkYXRhLCBpZktlZXBBbGl2ZSkge1xuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBJbnZva2UgYSBjYWxsYmFjaygke2NhbGxiYWNrSWR9KSB3aXRoYCwgZGF0YSxcbiAgICAgICAgICAgIGBpbiBpbnN0YW5jZSgke3RoaXMuaWR9KWApXG5cbiAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmRvYy5jbG9zZSgpXG4gICAgY2FsbGJhY2soZGF0YSkgLy8gZGF0YSBpcyBhbHJlYWR5IGEgb2JqZWN0LCBAc2VlOiBsaWIvcnVudGltZS9pbmRleC5qc1xuXG4gICAgaWYgKHR5cGVvZiBpZktlZXBBbGl2ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgaWZLZWVwQWxpdmUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQWN0aW9ucygpXG4gICAgdGhpcy5kb2MubGlzdGVuZXIudXBkYXRlRmluaXNoKClcbiAgICB0aGlzLmRvYy5vcGVuKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgY2FsbGJhY2sgaWQgXCIke2NhbGxiYWNrSWR9XCJgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaERhdGEgKGRhdGEpIHtcbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gUmVmcmVzaCB3aXRoYCwgZGF0YSxcbiAgICAgICAgICAgIGBpbiBpbnN0YW5jZVske3RoaXMuaWR9XWApXG5cbiAgY29uc3Qgdm0gPSB0aGlzLnZtXG5cbiAgaWYgKHZtICYmIGRhdGEpIHtcbiAgICB0aGlzLmRvYy5jbG9zZSgpXG4gICAgaWYgKHR5cGVvZiB2bS5yZWZyZXNoRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm0ucmVmcmVzaERhdGEoZGF0YSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBleHRlbmQodm0sIGRhdGEpXG4gICAgfVxuICAgIHRoaXMudXBkYXRlQWN0aW9ucygpXG4gICAgdGhpcy5kb2MubGlzdGVuZXIucmVmcmVzaEZpbmlzaCgpXG4gICAgdGhpcy5kb2Mub3BlbigpXG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgXCIke2RhdGF9XCJgKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2FwcC9jdHJsL21pc2MuanNcbiAqKi8iLCJpbXBvcnQgeyBleHRlbmQsIHR5cG9mIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCBEaWZmZXIgZnJvbSAnLi9kaWZmZXInXG5pbXBvcnQgcmVuZGVyZXIgZnJvbSAnLi4vY29uZmlnJ1xuaW1wb3J0IHsgcmVnaXN0ZXJDb21wb25lbnQsIHJlcXVpcmVDb21wb25lbnQsIHJlcXVpcmVNb2R1bGUgfSBmcm9tICcuL3JlZ2lzdGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHBJbnN0YW5jZSAoaW5zdGFuY2VJZCwgb3B0aW9ucykge1xuICB0aGlzLmlkID0gaW5zdGFuY2VJZFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHRoaXMudm0gPSBudWxsXG4gIHRoaXMuY3VzdG9tQ29tcG9uZW50TWFwID0ge31cbiAgdGhpcy5jYWxsYmFja3MgPSB7fVxuICB0aGlzLmRvYyA9IG5ldyByZW5kZXJlci5Eb2N1bWVudChcbiAgICBpbnN0YW5jZUlkLFxuICAgIHRoaXMub3B0aW9ucy5idW5kbGVVcmwsXG4gICAgbnVsbCxcbiAgICByZW5kZXJlci5MaXN0ZW5lclxuICApXG4gIHRoaXMuZGlmZmVyID0gbmV3IERpZmZlcihpbnN0YW5jZUlkKVxuICB0aGlzLnVpZCA9IDBcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplIChhcHAsIHYpIHtcbiAgY29uc3QgdHlwZSA9IHR5cG9mKHYpXG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdudWxsJzpcbiAgICAgIHJldHVybiAnJ1xuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gdi50b1N0cmluZygpXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gdi50b0lTT1N0cmluZygpXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHYgaW5zdGFuY2VvZiByZW5kZXJlci5FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB2LnJlZlxuICAgICAgfVxuICAgICAgcmV0dXJuIHZcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBhcHAuY2FsbGJhY2tzWysrYXBwLnVpZF0gPSB2XG4gICAgICByZXR1cm4gYXBwLnVpZC50b1N0cmluZygpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KVxuICB9XG59XG5cbkFwcEluc3RhbmNlLnByb3RvdHlwZS5jYWxsVGFza3MgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgaWYgKHR5cG9mKHRhc2tzKSAhPT0gJ2FycmF5Jykge1xuICAgIHRhc2tzID0gW3Rhc2tzXVxuICB9XG5cbiAgdGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuICAgIHRhc2suYXJncyA9IHRhc2suYXJncy5tYXAoYXJnID0+IG5vcm1hbGl6ZSh0aGlzLCBhcmcpKVxuICB9KVxuXG4gIHJldHVybiByZW5kZXJlci5zZW5kVGFza3ModGhpcy5pZCwgdGFza3MsICctMScpXG59XG5cbmV4dGVuZChBcHBJbnN0YW5jZS5wcm90b3R5cGUsIHtcbiAgcmVnaXN0ZXJDb21wb25lbnQsXG4gIHJlcXVpcmVDb21wb25lbnQsXG4gIHJlcXVpcmVNb2R1bGVcbn0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvYXBwL2luc3RhbmNlLmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlmZmVyIHtcbiAgY29uc3RydWN0b3IgKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5tYXAgPSBbXVxuICAgIHRoaXMuaG9va3MgPSBbXVxuICB9XG4gIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLm1hcC5sZW5ndGggPT09IDBcbiAgfVxuICBhcHBlbmQgKHR5cGUsIGRlcHRoLCByZWYsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuaGFzVGltZXIpIHtcbiAgICAgIHRoaXMuaGFzVGltZXIgPSB0cnVlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNUaW1lciA9IGZhbHNlXG4gICAgICAgIHRoaXMuZmx1c2godHJ1ZSlcbiAgICAgIH0sIDApXG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwXG4gICAgaWYgKCFtYXBbZGVwdGhdKSB7XG4gICAgICBtYXBbZGVwdGhdID0ge31cbiAgICB9XG4gICAgY29uc3QgZ3JvdXAgPSBtYXBbZGVwdGhdXG4gICAgaWYgKCFncm91cFt0eXBlXSkge1xuICAgICAgZ3JvdXBbdHlwZV0gPSB7fVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBpZiAoIWdyb3VwW3R5cGVdW3JlZl0pIHtcbiAgICAgICAgZ3JvdXBbdHlwZV1bcmVmXSA9IFtdXG4gICAgICB9XG4gICAgICBncm91cFt0eXBlXVtyZWZdLnB1c2goaGFuZGxlcilcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBncm91cFt0eXBlXVtyZWZdID0gaGFuZGxlclxuICAgIH1cbiAgfVxuICBmbHVzaCAoaXNUaW1lb3V0KSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAuc2xpY2UoKVxuICAgIHRoaXMubWFwLmxlbmd0aCA9IDBcbiAgICBtYXAuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgIGNhbGxUeXBlTWFwKGdyb3VwLCAncmVwZWF0JylcbiAgICAgIGNhbGxUeXBlTWFwKGdyb3VwLCAnc2hvd24nKVxuICAgICAgY2FsbFR5cGVMaXN0KGdyb3VwLCAnZWxlbWVudCcpXG4gICAgfSlcblxuICAgIGNvbnN0IGhvb2tzID0gdGhpcy5ob29rcy5zbGljZSgpXG4gICAgdGhpcy5ob29rcy5sZW5ndGggPSAwXG4gICAgaG9va3MuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgIGZuKClcbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5mbHVzaCgpXG4gICAgfVxuICB9XG4gIHRoZW4gKGZuKSB7XG4gICAgdGhpcy5ob29rcy5wdXNoKGZuKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxUeXBlTWFwIChncm91cCwgdHlwZSkge1xuICBjb25zdCBtYXAgPSBncm91cFt0eXBlXVxuICBmb3IgKGNvbnN0IHJlZiBpbiBtYXApIHtcbiAgICBtYXBbcmVmXSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFR5cGVMaXN0IChncm91cCwgdHlwZSkge1xuICBjb25zdCBtYXAgPSBncm91cFt0eXBlXVxuICBmb3IgKGNvbnN0IHJlZiBpbiBtYXApIHtcbiAgICBjb25zdCBsaXN0ID0gbWFwW3JlZl1cbiAgICBsaXN0LmZvckVhY2goKGhhbmRsZXIpID0+IHsgaGFuZGxlcigpIH0pXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcHAvZGlmZmVyLmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IGluc3RhbmNlTWFwID0ge31cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9zdGF0aWMvbWFwLmpzXG4gKiovIiwiaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5pbXBvcnQgeyBpbnN0YW5jZU1hcCB9IGZyb20gJy4vbWFwJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCAoY2ZnKSB7XG4gIGNvbmZpZy5Eb2N1bWVudCA9IGNmZy5Eb2N1bWVudFxuICBjb25maWcuRWxlbWVudCA9IGNmZy5FbGVtZW50XG4gIGNvbmZpZy5Db21tZW50ID0gY2ZnLkNvbW1lbnRcbiAgY29uZmlnLnNlbmRUYXNrcyA9IGNmZy5zZW5kVGFza3NcbiAgY29uZmlnLkxpc3RlbmVyID0gY2ZnLkxpc3RlbmVyXG59XG5cbi8qKlxuICogcmVmcmVzaCBhIFdlZXggaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaEluc3RhbmNlIChpbnN0YW5jZUlkLCBkYXRhKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgbGV0IHJlc3VsdFxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXN1bHQgPSBpbnN0YW5jZS5yZWZyZXNoRGF0YShkYXRhKVxuICB9XG4gIGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIGRlc3Ryb3kgYSBXZWV4IGluc3RhbmNlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lJbnN0YW5jZSAoaW5zdGFuY2VJZCkge1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGluc3RhbmNlIGlkIFwiJHtpbnN0YW5jZUlkfVwiYClcbiAgfVxuXG4gIGluc3RhbmNlLmRlc3Ryb3koKVxuICBkZWxldGUgaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgcmV0dXJuIGluc3RhbmNlTWFwXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvc3RhdGljL2xpZmUuanNcbiAqKi8iLCJpbXBvcnQgVm0gZnJvbSAnLi4vdm0nXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZydcblxuY29uc3Qge1xuICBuYXRpdmVDb21wb25lbnRNYXBcbn0gPSBjb25maWdcblxuLyoqXG4gKiByZWdpc3RlciB0aGUgbmFtZSBvZiBlYWNoIG5hdGl2ZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge2FycmF5fSBjb21wb25lbnRzIGFycmF5IG9mIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyAoY29tcG9uZW50cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnRzKSkge1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiByZWdpc3RlciAobmFtZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hdGl2ZUNvbXBvbmVudE1hcFtuYW1lXSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmFtZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYXRpdmVDb21wb25lbnRNYXBbbmFtZS50eXBlXSA9IG5hbWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogcmVnaXN0ZXIgdGhlIG5hbWUgYW5kIG1ldGhvZHMgb2YgZWFjaCBtb2R1bGVcbiAqIEBwYXJhbSAge29iamVjdH0gbW9kdWxlcyBhIG9iamVjdCBvZiBtb2R1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZXMgKG1vZHVsZXMpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnb2JqZWN0Jykge1xuICAgIFZtLnJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzKVxuICB9XG59XG5cbi8qKlxuICogcmVnaXN0ZXIgdGhlIG5hbWUgYW5kIG1ldGhvZHMgb2YgZWFjaCBhcGlcbiAqIEBwYXJhbSAge29iamVjdH0gYXBpcyBhIG9iamVjdCBvZiBhcGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1ldGhvZHMgKGFwaXMpIHtcbiAgaWYgKHR5cGVvZiBhcGlzID09PSAnb2JqZWN0Jykge1xuICAgIFZtLnJlZ2lzdGVyTWV0aG9kcyhhcGlzKVxuICB9XG59XG5nbG9iYWwucmVnaXN0ZXJNZXRob2RzID0gcmVnaXN0ZXJNZXRob2RzXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvc3RhdGljL3JlZ2lzdGVyLmpzXG4gKiovIiwiaW1wb3J0IHsgaW5zdGFuY2VNYXAgfSBmcm9tICcuL21hcCdcblxuY29uc3QganNIYW5kbGVycyA9IHtcbiAgZmlyZUV2ZW50OiBmdW5jdGlvbiBmaXJlRXZlbnQgKGluc3RhbmNlSWQsIHJlZiwgdHlwZSwgZGF0YSwgZG9tQ2hhbmdlcykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgICByZXR1cm4gaW5zdGFuY2UuZmlyZUV2ZW50KHJlZiwgdHlwZSwgZGF0YSwgZG9tQ2hhbmdlcylcbiAgfSxcblxuICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sgKGluc3RhbmNlSWQsIGZ1bmNJZCwgZGF0YSwgaWZMYXN0KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICAgIHJldHVybiBpbnN0YW5jZS5jYWxsYmFjayhmdW5jSWQsIGRhdGEsIGlmTGFzdClcbiAgfVxufVxuXG4vKipcbiAqIGFjY2VwdCBjYWxscyBmcm9tIG5hdGl2ZSAoZXZlbnQgb3IgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKiBAcGFyYW0gIHthcnJheX0gdGFza3MgbGlzdCB3aXRoIGBtZXRob2RgIGFuZCBgYXJnc2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVUYXNrcyAoaW5zdGFuY2VJZCwgdGFza3MpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICBpZiAoaW5zdGFuY2UgJiYgQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW11cbiAgICB0YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0ganNIYW5kbGVyc1t0YXNrLm1ldGhvZF1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbLi4udGFzay5hcmdzXVxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdChpbnN0YW5jZUlkKVxuICAgICAgICByZXN1bHRzLnB1c2goaGFuZGxlciguLi5hcmdzKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cIiBvciB0YXNrc2ApXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvc3RhdGljL2JyaWRnZS5qc1xuICoqLyIsImltcG9ydCB7IGluc3RhbmNlTWFwIH0gZnJvbSAnLi9tYXAnXG5cbi8qKlxuICogZ2V0IGEgd2hvbGUgZWxlbWVudCB0cmVlIG9mIGFuIGluc3RhbmNlXG4gKiBmb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqIEByZXR1cm4ge29iamVjdH0gYSB2aXJ0dWFsIGRvbSB0cmVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290IChpbnN0YW5jZUlkKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgbGV0IHJlc3VsdFxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXN1bHQgPSBpbnN0YW5jZS5nZXRSb290RWxlbWVudCgpXG4gIH1cbiAgZWxzZSB7XG4gICAgcmVzdWx0ID0gbmV3IEVycm9yKGBpbnZhbGlkIGluc3RhbmNlIGlkIFwiJHtpbnN0YW5jZUlkfVwiYClcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvc3RhdGljL21pc2MuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIEEgc2ltcGxlIHZpcnR1YWwgZG9tIGltcGxlbWVudGF0aW9uXG4gKi9cbi8vIGltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3NoYXJlZCdcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3NoYXJlZC91dGlscydcblxuY29uc3QgREVGQVVMVF9UQUdfTkFNRSA9ICdkaXYnXG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZU1hcCA9IHt9XG5sZXQgbmV4dE5vZGVSZWYgPSAxXG5cbmV4cG9ydCBmdW5jdGlvbiBEb2N1bWVudCAoaWQsIHVybCwgaGFuZGxlciwgTGlzdGVuZXIpIHtcbiAgaWQgPSBpZCA/IGlkLnRvU3RyaW5nKCkgOiAnJ1xuICB0aGlzLmlkID0gaWRcbiAgdGhpcy5VUkwgPSB1cmxcblxuICBpbnN0YW5jZU1hcFtpZF0gPSB0aGlzXG4gIHRoaXMubm9kZU1hcCA9IHt9XG4gIExpc3RlbmVyICYmICh0aGlzLmxpc3RlbmVyID0gbmV3IExpc3RlbmVyKGlkLCBoYW5kbGVyIHx8IGdlbkNhbGxUYXNrcyhpZCkpKVxuICB0aGlzLmNyZWF0ZURvY3VtZW50RWxlbWVudCgpXG59XG5cbmZ1bmN0aW9uIGdlbkNhbGxUYXNrcyAoaWQpIHtcbiAgcmV0dXJuICh0YXNrcykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICAgIHRhc2tzID0gW3Rhc2tzXVxuICAgIH1cbiAgICByZXR1cm4gY2FsbE5hdGl2ZShpZCwgdGFza3MsICctMScpXG4gIH1cbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGRlbGV0ZSB0aGlzLmxpc3RlbmVyXG4gIGRlbGV0ZSB0aGlzLm5vZGVNYXBcbiAgZGVsZXRlIGluc3RhbmNlTWFwW3RoaXMuaWRdXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxpc3RlbmVyLmJhdGNoZWQgPSBmYWxzZVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGlzdGVuZXIuYmF0Y2hlZCA9IHRydWVcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZURvY3VtZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRvY3VtZW50RWxlbWVudCkge1xuICAgIGNvbnN0IGVsID0gbmV3IEVsZW1lbnQoJ2RvY3VtZW50JylcbiAgICBlbC5kb2NJZCA9IHRoaXMuaWRcbiAgICBlbC5vd25lckRvY3VtZW50ID0gdGhpc1xuICAgIGVsLnJvbGUgPSAnZG9jdW1lbnRFbGVtZW50J1xuICAgIGVsLmRlcHRoID0gMFxuICAgIGVsLnJlZiA9ICdfZG9jdW1lbnRFbGVtZW50J1xuICAgIHRoaXMubm9kZU1hcC5fZG9jdW1lbnRFbGVtZW50ID0gZWxcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGVsXG4gICAgZWwuYXBwZW5kQ2hpbGQgPSAobm9kZSkgPT4ge1xuICAgICAgYXBwZW5kQm9keSh0aGlzLCBub2RlKVxuICAgIH1cbiAgICBlbC5pbnNlcnRCZWZvcmUgPSAobm9kZSwgYmVmb3JlKSA9PiB7XG4gICAgICBhcHBlbmRCb2R5KHRoaXMsIG5vZGUsIGJlZm9yZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYXBwZW5kQm9keSAoZG9jLCBub2RlLCBiZWZvcmUpIHtcbiAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgfSA9IGRvY1xuXG4gIGlmIChkb2N1bWVudEVsZW1lbnQucHVyZUNoaWxkcmVuLmxlbmd0aCA+IDAgfHwgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBkb2N1bWVudEVsZW1lbnQuY2hpbGRyZW5cbiAgY29uc3QgYmVmb3JlSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGJlZm9yZSlcbiAgaWYgKGJlZm9yZUluZGV4IDwgMCkge1xuICAgIGNoaWxkcmVuLnB1c2gobm9kZSlcbiAgfVxuICBlbHNlIHtcbiAgICBjaGlsZHJlbi5zcGxpY2UoYmVmb3JlSW5kZXgsIDAsIG5vZGUpXG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnJvbGUgPT09ICdib2R5Jykge1xuICAgICAgbm9kZS5kb2NJZCA9IGRvYy5pZFxuICAgICAgbm9kZS5vd25lckRvY3VtZW50ID0gZG9jXG4gICAgICBub2RlLnBhcmVudE5vZGUgPSBkb2N1bWVudEVsZW1lbnRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBjaGlsZC5wYXJlbnROb2RlID0gbm9kZVxuICAgICAgfSlcbiAgICAgIHNldEJvZHkoZG9jLCBub2RlKVxuICAgICAgbm9kZS5kb2NJZCA9IGRvYy5pZFxuICAgICAgbm9kZS5vd25lckRvY3VtZW50ID0gZG9jXG4gICAgICBsaW5rUGFyZW50KG5vZGUsIGRvY3VtZW50RWxlbWVudClcbiAgICAgIGRlbGV0ZSBkb2Mubm9kZU1hcFtub2RlLm5vZGVJZF1cbiAgICB9XG4gICAgZG9jdW1lbnRFbGVtZW50LnB1cmVDaGlsZHJlbi5wdXNoKG5vZGUpXG4gICAgZG9jLmxpc3RlbmVyLmNyZWF0ZUJvZHkobm9kZSlcbiAgfVxuICBlbHNlIHtcbiAgICBub2RlLnBhcmVudE5vZGUgPSBkb2N1bWVudEVsZW1lbnRcbiAgICBkb2Mubm9kZU1hcFtub2RlLnJlZl0gPSBub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Qm9keSAoZG9jLCBlbCkge1xuICBlbC5yb2xlID0gJ2JvZHknXG4gIGVsLmRlcHRoID0gMVxuICBkZWxldGUgZG9jLm5vZGVNYXBbZWwubm9kZUlkXVxuICBlbC5yZWYgPSAnX3Jvb3QnXG4gIGRvYy5ub2RlTWFwLl9yb290ID0gZWxcbiAgZG9jLmJvZHkgPSBlbFxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlQm9keSA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICBpZiAoIXRoaXMuYm9keSkge1xuICAgIGNvbnN0IGVsID0gbmV3IEVsZW1lbnQodHlwZSwgcHJvcHMpXG4gICAgc2V0Qm9keSh0aGlzLCBlbClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmJvZHlcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIG5ldyBFbGVtZW50KHRhZ05hbWUsIHByb3BzKVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiBuZXcgQ29tbWVudCh0ZXh0KVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBlLCBkb21DaGFuZ2VzKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm5cbiAgfVxuICBlID0gZSB8fCB7fVxuICBlLnR5cGUgPSB0eXBlXG4gIGUudGFyZ2V0ID0gZWxcbiAgZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gIGlmIChkb21DaGFuZ2VzKSB7XG4gICAgdXBkYXRlRWxlbWVudChlbCwgZG9tQ2hhbmdlcylcbiAgfVxuICByZXR1cm4gZWwuZmlyZUV2ZW50KHR5cGUsIGUpXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5nZXRSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXBbcmVmXVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50IChlbCwgY2hhbmdlcykge1xuICBjb25zdCBhdHRycyA9IGNoYW5nZXMuYXR0cnMgfHwge31cbiAgZm9yIChjb25zdCBuYW1lIGluIGF0dHJzKSB7XG4gICAgZWwuc2V0QXR0cihuYW1lLCBhdHRyc1tuYW1lXSwgdHJ1ZSlcbiAgfVxuICBjb25zdCBzdHlsZSA9IGNoYW5nZXMuc3R5bGUgfHwge31cbiAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlKSB7XG4gICAgZWwuc2V0U3R5bGUobmFtZSwgc3R5bGVbbmFtZV0sIHRydWUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE5vZGUgKCkge1xuICB0aGlzLm5vZGVJZCA9IChuZXh0Tm9kZVJlZisrKS50b1N0cmluZygpXG4gIHRoaXMucmVmID0gdGhpcy5ub2RlSWRcbiAgdGhpcy5jaGlsZHJlbiA9IFtdXG4gIHRoaXMucHVyZUNoaWxkcmVuID0gW11cbiAgdGhpcy5wYXJlbnROb2RlID0gbnVsbFxuICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbFxuICB0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGxcbn1cblxuTm9kZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgZG9jID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF1cbiAgaWYgKGRvYykge1xuICAgIGRlbGV0ZSB0aGlzLmRvY0lkXG4gICAgZGVsZXRlIGRvYy5ub2RlTWFwW3RoaXMubm9kZUlkXVxuICB9XG4gIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgY2hpbGQuZGVzdHJveSgpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbGVtZW50ICh0eXBlID0gREVGQVVMVF9UQUdfTkFNRSwgcHJvcHMpIHtcbiAgcHJvcHMgPSBwcm9wcyB8fCB7fVxuICB0aGlzLm5vZGVUeXBlID0gMVxuICB0aGlzLm5vZGVJZCA9IChuZXh0Tm9kZVJlZisrKS50b1N0cmluZygpXG4gIHRoaXMucmVmID0gdGhpcy5ub2RlSWRcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLmF0dHIgPSBwcm9wcy5hdHRyIHx8IHt9XG4gIHRoaXMuY2xhc3NTdHlsZSA9IHByb3BzLmNsYXNzU3R5bGUgfHwge31cbiAgdGhpcy5zdHlsZSA9IHByb3BzLnN0eWxlIHx8IHt9XG4gIHRoaXMuZXZlbnQgPSB7fVxuICB0aGlzLmNoaWxkcmVuID0gW11cbiAgdGhpcy5wdXJlQ2hpbGRyZW4gPSBbXVxufVxuXG5FbGVtZW50LnByb3RvdHlwZSA9IG5ldyBOb2RlKClcblxuRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gdGhpcykge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgbGlua1BhcmVudChub2RlLCB0aGlzKVxuICAgIGluc2VydEluZGV4KG5vZGUsIHRoaXMuY2hpbGRyZW4sIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCB0cnVlKVxuICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICByZWdpc3Rlck5vZGUodGhpcy5kb2NJZCwgbm9kZSlcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGluc2VydEluZGV4KG5vZGUsIHRoaXMucHVyZUNoaWxkcmVuLCB0aGlzLnB1cmVDaGlsZHJlbi5sZW5ndGgpXG4gICAgICBpZiAodGhpcy5kb2NJZCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5hZGRFbGVtZW50KG5vZGUsIHRoaXMucmVmLCAtMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgbW92ZUluZGV4KG5vZGUsIHRoaXMuY2hpbGRyZW4sIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCB0cnVlKVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb25zdCBpbmRleCA9IG1vdmVJbmRleChub2RlLCB0aGlzLnB1cmVDaGlsZHJlbiwgdGhpcy5wdXJlQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgaWYgKHRoaXMuZG9jSWQgJiYgaW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5tb3ZlRWxlbWVudChub2RlLnJlZiwgdGhpcy5yZWYsIGluZGV4KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAobm9kZSwgYmVmb3JlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICE9PSB0aGlzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKG5vZGUgPT09IGJlZm9yZSB8fCBub2RlLm5leHRTaWJsaW5nID09PSBiZWZvcmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIGxpbmtQYXJlbnQobm9kZSwgdGhpcylcbiAgICBpbnNlcnRJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlKSwgdHJ1ZSlcbiAgICBpZiAodGhpcy5kb2NJZCkge1xuICAgICAgcmVnaXN0ZXJOb2RlKHRoaXMuZG9jSWQsIG5vZGUpXG4gICAgfVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb25zdCBwdXJlQmVmb3JlID0gbmV4dEVsZW1lbnQoYmVmb3JlKVxuICAgICAgY29uc3QgaW5kZXggPSBpbnNlcnRJbmRleChcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdGhpcy5wdXJlQ2hpbGRyZW4sXG4gICAgICAgIHB1cmVCZWZvcmVcbiAgICAgICAgICA/IHRoaXMucHVyZUNoaWxkcmVuLmluZGV4T2YocHVyZUJlZm9yZSlcbiAgICAgICAgICA6IHRoaXMucHVyZUNoaWxkcmVuLmxlbmd0aFxuICAgICAgKVxuICAgICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuYWRkRWxlbWVudChub2RlLCB0aGlzLnJlZiwgaW5kZXgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIG1vdmVJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlKSwgdHJ1ZSlcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgcHVyZUJlZm9yZSA9IG5leHRFbGVtZW50KGJlZm9yZSlcbiAgICAgIGNvbnN0IGluZGV4ID0gbW92ZUluZGV4KFxuICAgICAgICBub2RlLFxuICAgICAgICB0aGlzLnB1cmVDaGlsZHJlbixcbiAgICAgICAgcHVyZUJlZm9yZVxuICAgICAgICAgID8gdGhpcy5wdXJlQ2hpbGRyZW4uaW5kZXhPZihwdXJlQmVmb3JlKVxuICAgICAgICAgIDogdGhpcy5wdXJlQ2hpbGRyZW4ubGVuZ3RoXG4gICAgICApXG4gICAgICBpZiAodGhpcy5kb2NJZCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLm1vdmVFbGVtZW50KG5vZGUucmVmLCB0aGlzLnJlZiwgaW5kZXgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKG5vZGUsIGFmdGVyKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICE9PSB0aGlzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKG5vZGUgPT09IGFmdGVyIHx8IG5vZGUucHJldmlvdXNTaWJsaW5nID09PSBhZnRlcikge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgbGlua1BhcmVudChub2RlLCB0aGlzKVxuICAgIGluc2VydEluZGV4KG5vZGUsIHRoaXMuY2hpbGRyZW4sIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihhZnRlcikgKyAxLCB0cnVlKVxuICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICByZWdpc3Rlck5vZGUodGhpcy5kb2NJZCwgbm9kZSlcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5zZXJ0SW5kZXgoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHRoaXMucHVyZUNoaWxkcmVuLFxuICAgICAgICB0aGlzLnB1cmVDaGlsZHJlbi5pbmRleE9mKHByZXZpb3VzRWxlbWVudChhZnRlcikpICsgMVxuICAgICAgKVxuICAgICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuYWRkRWxlbWVudChub2RlLCB0aGlzLnJlZiwgaW5kZXgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIG1vdmVJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYWZ0ZXIpICsgMSwgdHJ1ZSlcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBtb3ZlSW5kZXgoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHRoaXMucHVyZUNoaWxkcmVuLFxuICAgICAgICB0aGlzLnB1cmVDaGlsZHJlbi5pbmRleE9mKHByZXZpb3VzRWxlbWVudChhZnRlcikpICsgMVxuICAgICAgKVxuICAgICAgaWYgKHRoaXMuZG9jSWQgJiYgaW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5tb3ZlRWxlbWVudChub2RlLnJlZiwgdGhpcy5yZWYsIGluZGV4KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChub2RlLCBwcmVzZXJ2ZWQpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJlbW92ZUluZGV4KG5vZGUsIHRoaXMuY2hpbGRyZW4sIHRydWUpXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJlbW92ZUluZGV4KG5vZGUsIHRoaXMucHVyZUNoaWxkcmVuKVxuICAgICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICBsaXN0ZW5lci5yZW1vdmVFbGVtZW50KG5vZGUucmVmKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXByZXNlcnZlZCkge1xuICAgIG5vZGUuZGVzdHJveSgpXG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgIHRoaXMucHVyZUNoaWxkcmVuLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBsaXN0ZW5lci5yZW1vdmVFbGVtZW50KG5vZGUucmVmKVxuICAgIH0pXG4gIH1cbiAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIG5vZGUuZGVzdHJveSgpXG4gIH0pXG4gIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gMFxuICB0aGlzLnB1cmVDaGlsZHJlbi5sZW5ndGggPSAwXG59XG5cbmZ1bmN0aW9uIG5leHRFbGVtZW50IChub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBub2RlXG4gICAgfVxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJldmlvdXNFbGVtZW50IChub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBub2RlXG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmtQYXJlbnQgKG5vZGUsIHBhcmVudCkge1xuICBub2RlLnBhcmVudE5vZGUgPSBwYXJlbnRcbiAgaWYgKHBhcmVudC5kb2NJZCkge1xuICAgIG5vZGUuZG9jSWQgPSBwYXJlbnQuZG9jSWRcbiAgICBub2RlLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5ub2RlTWFwW25vZGUubm9kZUlkXSA9IG5vZGVcbiAgICBub2RlLmRlcHRoID0gcGFyZW50LmRlcHRoICsgMVxuICB9XG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgbGlua1BhcmVudChjaGlsZCwgbm9kZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlIChkb2NJZCwgbm9kZSkge1xuICBjb25zdCBkb2MgPSBpbnN0YW5jZU1hcFtkb2NJZF1cbiAgZG9jLm5vZGVNYXBbbm9kZS5ub2RlSWRdID0gbm9kZVxufVxuXG5mdW5jdGlvbiBpbnNlcnRJbmRleCAodGFyZ2V0LCBsaXN0LCBuZXdJbmRleCwgY2hhbmdlU2libGluZykge1xuICBpZiAobmV3SW5kZXggPCAwKSB7XG4gICAgbmV3SW5kZXggPSAwXG4gIH1cbiAgY29uc3QgYmVmb3JlID0gbGlzdFtuZXdJbmRleCAtIDFdXG4gIGNvbnN0IGFmdGVyID0gbGlzdFtuZXdJbmRleF1cbiAgbGlzdC5zcGxpY2UobmV3SW5kZXgsIDAsIHRhcmdldClcbiAgaWYgKGNoYW5nZVNpYmxpbmcpIHtcbiAgICBiZWZvcmUgJiYgKGJlZm9yZS5uZXh0U2libGluZyA9IHRhcmdldClcbiAgICB0YXJnZXQucHJldmlvdXNTaWJsaW5nID0gYmVmb3JlXG4gICAgdGFyZ2V0Lm5leHRTaWJsaW5nID0gYWZ0ZXJcbiAgICBhZnRlciAmJiAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nID0gdGFyZ2V0KVxuICB9XG4gIHJldHVybiBuZXdJbmRleFxufVxuXG5mdW5jdGlvbiBtb3ZlSW5kZXggKHRhcmdldCwgbGlzdCwgbmV3SW5kZXgsIGNoYW5nZVNpYmxpbmcpIHtcbiAgY29uc3QgaW5kZXggPSBsaXN0LmluZGV4T2YodGFyZ2V0KVxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGNoYW5nZVNpYmxpbmcpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBsaXN0W2luZGV4IC0gMV1cbiAgICBjb25zdCBhZnRlciA9IGxpc3RbaW5kZXggKyAxXVxuICAgIGJlZm9yZSAmJiAoYmVmb3JlLm5leHRTaWJsaW5nID0gYWZ0ZXIpXG4gICAgYWZ0ZXIgJiYgKGFmdGVyLnByZXZpb3VzU2libGluZyA9IGJlZm9yZSlcbiAgfVxuICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgbGV0IG5ld0luZGV4QWZ0ZXIgPSBuZXdJbmRleFxuICBpZiAoaW5kZXggPD0gbmV3SW5kZXgpIHtcbiAgICBuZXdJbmRleEFmdGVyID0gbmV3SW5kZXggLSAxXG4gIH1cbiAgY29uc3QgYmVmb3JlTmV3ID0gbGlzdFtuZXdJbmRleEFmdGVyIC0gMV1cbiAgY29uc3QgYWZ0ZXJOZXcgPSBsaXN0W25ld0luZGV4QWZ0ZXJdXG4gIGxpc3Quc3BsaWNlKG5ld0luZGV4QWZ0ZXIsIDAsIHRhcmdldClcbiAgaWYgKGNoYW5nZVNpYmxpbmcpIHtcbiAgICBiZWZvcmVOZXcgJiYgKGJlZm9yZU5ldy5uZXh0U2libGluZyA9IHRhcmdldClcbiAgICB0YXJnZXQucHJldmlvdXNTaWJsaW5nID0gYmVmb3JlTmV3XG4gICAgdGFyZ2V0Lm5leHRTaWJsaW5nID0gYWZ0ZXJOZXdcbiAgICBhZnRlck5ldyAmJiAoYWZ0ZXJOZXcucHJldmlvdXNTaWJsaW5nID0gdGFyZ2V0KVxuICB9XG4gIGlmIChpbmRleCA9PT0gbmV3SW5kZXhBZnRlcikge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHJldHVybiBuZXdJbmRleFxufVxuXG5mdW5jdGlvbiByZW1vdmVJbmRleCAodGFyZ2V0LCBsaXN0LCBjaGFuZ2VTaWJsaW5nKSB7XG4gIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKHRhcmdldClcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChjaGFuZ2VTaWJsaW5nKSB7XG4gICAgY29uc3QgYmVmb3JlID0gbGlzdFtpbmRleCAtIDFdXG4gICAgY29uc3QgYWZ0ZXIgPSBsaXN0W2luZGV4ICsgMV1cbiAgICBiZWZvcmUgJiYgKGJlZm9yZS5uZXh0U2libGluZyA9IGFmdGVyKVxuICAgIGFmdGVyICYmIChhZnRlci5wcmV2aW91c1NpYmxpbmcgPSBiZWZvcmUpXG4gIH1cbiAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gIGlmICh0aGlzLmF0dHJba2V5XSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLmF0dHJba2V5XSA9IHZhbHVlXG4gIGlmICghc2lsZW50ICYmIHRoaXMuZG9jSWQpIHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgbGlzdGVuZXIuc2V0QXR0cih0aGlzLnJlZiwga2V5LCB2YWx1ZSlcbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBzaWxlbnQpIHtcbiAgaWYgKHRoaXMuc3R5bGVba2V5XSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLnN0eWxlW2tleV0gPSB2YWx1ZVxuICBpZiAoIXNpbGVudCAmJiB0aGlzLmRvY0lkKSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgIGxpc3RlbmVyLnNldFN0eWxlKHRoaXMucmVmLCBrZXksIHZhbHVlKVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnNldENsYXNzU3R5bGUgPSBmdW5jdGlvbiAoY2xhc3NTdHlsZSkge1xuICB0aGlzLmNsYXNzU3R5bGUgPSBjbGFzc1N0eWxlXG4gIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgIGxpc3RlbmVyLnNldFN0eWxlcyh0aGlzLnJlZiwgdGhpcy50b1N0eWxlKCkpXG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICBpZiAoIXRoaXMuZXZlbnRbdHlwZV0pIHtcbiAgICB0aGlzLmV2ZW50W3R5cGVdID0gaGFuZGxlclxuICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICBsaXN0ZW5lci5hZGRFdmVudCh0aGlzLnJlZiwgdHlwZSlcbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodGhpcy5ldmVudFt0eXBlXSkge1xuICAgIGRlbGV0ZSB0aGlzLmV2ZW50W3R5cGVdXG4gICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICAgIGxpc3RlbmVyLnJlbW92ZUV2ZW50KHRoaXMucmVmLCB0eXBlKVxuICAgIH1cbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5maXJlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgZSkge1xuICBjb25zdCBoYW5kbGVyID0gdGhpcy5ldmVudFt0eXBlXVxuICBpZiAoaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS50b1N0eWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLmNsYXNzU3R5bGUsIHRoaXMuc3R5bGUpXG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJlZjogdGhpcy5yZWYudG9TdHJpbmcoKSxcbiAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgYXR0cjogdGhpcy5hdHRyLFxuICAgIHN0eWxlOiB0aGlzLnRvU3R5bGUoKVxuICB9XG4gIGNvbnN0IGV2ZW50ID0gT2JqZWN0LmtleXModGhpcy5ldmVudClcbiAgaWYgKGV2ZW50Lmxlbmd0aCkge1xuICAgIHJlc3VsdC5ldmVudCA9IGV2ZW50XG4gIH1cbiAgaWYgKHRoaXMucHVyZUNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJlc3VsdC5jaGlsZHJlbiA9IHRoaXMucHVyZUNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRvSlNPTigpKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnPCcgKyB0aGlzLnR5cGUgK1xuICAgICcgYXR0cj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5hdHRyKSArXG4gICAgJyBzdHlsZT0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy50b1N0eWxlKCkpICsgJz4nICtcbiAgICB0aGlzLnB1cmVDaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50b1N0cmluZygpKS5qb2luKCcnKSArXG4gICAgJzwvJyArIHRoaXMudHlwZSArICc+J1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29tbWVudCAodmFsdWUpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IDhcbiAgdGhpcy5ub2RlSWQgPSAobmV4dE5vZGVSZWYrKykudG9TdHJpbmcoKVxuICB0aGlzLnJlZiA9IHRoaXMubm9kZUlkXG4gIHRoaXMudHlwZSA9ICdjb21tZW50J1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5jaGlsZHJlbiA9IFtdXG4gIHRoaXMucHVyZUNoaWxkcmVuID0gW11cbn1cblxuQ29tbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpXG5cbkNvbW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJzwhLS0gJyArIHRoaXMudmFsdWUgKyAnIC0tPidcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvdmRvbS9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlldyBUaGUgYXBpIGZvciBpbnZva2luZyB3aXRoIFwiJFwiIHByZWZpeFxuICovXG5pbXBvcnQgeyBleHRlbmQsIHR5cG9mIH0gZnJvbSAnLi4vdXRpbCdcblxuLyoqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBjb21tb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSAkdm0gaW5zdGVhZFxuICogZmluZCB0aGUgdm0gYnkgaWRcbiAqIE5vdGU6IHRoZXJlIGlzIG9ubHkgb25lIGlkIGluIHdob2xlIGNvbXBvbmVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7Vm19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkIChpZCkge1xuICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIFZtIyQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBWbSMkdm0gaW5zdGVhZCcpXG4gIGNvbnN0IGluZm8gPSB0aGlzLl9pZHNbaWRdXG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8udm1cbiAgfVxufVxuXG4vKipcbiAqIGZpbmQgdGhlIGVsZW1lbnQgYnkgaWRcbiAqIE5vdGU6IHRoZXJlIGlzIG9ubHkgb25lIGlkIGluIHdob2xlIGNvbXBvbmVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICRlbCAoaWQpIHtcbiAgY29uc3QgaW5mbyA9IHRoaXMuX2lkc1tpZF1cbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5lbFxuICB9XG59XG5cbi8qKlxuICogZmluZCB0aGUgdm0gb2YgdGhlIGN1c3RvbSBjb21wb25lbnQgYnkgaWRcbiAqIE5vdGU6IHRoZXJlIGlzIG9ubHkgb25lIGlkIGluIHdob2xlIGNvbXBvbmVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7Vm19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkdm0gKGlkKSB7XG4gIGNvbnN0IGluZm8gPSB0aGlzLl9pZHNbaWRdXG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8udm1cbiAgfVxufVxuXG4vKipcbiAqIEZpcmUgd2hlbiBkaWZmZXIgcmVuZGVyaW5nIGZpbmlzaGVkXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkcmVuZGVyVGhlbiAoZm4pIHtcbiAgY29uc3QgYXBwID0gdGhpcy5fYXBwXG4gIGNvbnN0IGRpZmZlciA9IGFwcC5kaWZmZXJcbiAgcmV0dXJuIGRpZmZlci50aGVuKCgpID0+IHtcbiAgICBmbigpXG4gIH0pXG59XG5cbi8qKlxuICogc2Nyb2xsIGFuIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IGlkIGludG8gdmlldyxcbiAqIG1vcmVvdmVyIHNwZWNpZnkgYSBudW1iZXIgb2Ygb2Zmc2V0IG9wdGlvbmFsbHlcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEBwYXJhbSAge251bWJlcn0gb2Zmc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkc2Nyb2xsVG8gKGlkLCBvZmZzZXQpIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBWbSMkc2Nyb2xsVG8gaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAgICAgJ3BsZWFzZSB1c2UgXCJyZXF1aXJlKFxcJ0B3ZWV4LW1vZHVsZS9kb21cXCcpJyArXG4gICAgICAgICAgJy5zY3JvbGxUbyhlbCwgb3B0aW9ucylcIiBpbnN0ZWFkJylcbiAgY29uc3QgZWwgPSB0aGlzLiRlbChpZClcbiAgaWYgKGVsKSB7XG4gICAgY29uc3QgZG9tID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ2RvbScpXG4gICAgZG9tLnNjcm9sbFRvRWxlbWVudChlbC5yZWYsIHsgb2Zmc2V0OiBvZmZzZXQgfSlcbiAgfVxufVxuXG4vKipcbiAqIHBlcmZvcm0gdHJhbnNpdGlvbiBhbmltYXRpb24gb24gYW4gZWxlbWVudCBzcGVjaWZpZWQgYnkgaWRcbiAqIEBwYXJhbSAge3N0cmluZ30gICBpZFxuICogQHBhcmFtICB7b2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHRpb25zLnN0eWxlc1xuICogQHBhcmFtICB7b2JqZWN0fSAgIG9wdGlvbnMuZHVyYXRpb24obXMpXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnMudGltaW5nRnVuY3Rpb25dXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnMuZGVsYXk9MChtcyldXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICR0cmFuc2l0aW9uIChpZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgZWwgPSB0aGlzLiRlbChpZClcbiAgaWYgKGVsICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5zdHlsZXMpIHtcbiAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLl9hcHAucmVxdWlyZU1vZHVsZSgnYW5pbWF0aW9uJylcbiAgICBhbmltYXRpb24udHJhbnNpdGlvbihlbC5yZWYsIG9wdGlvbnMsICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbCwgb3B0aW9ucy5zdHlsZXMpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayguLi5hcmdzKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBnZXQgc29tZSBjb25maWdcbiAqIEByZXR1cm4ge29iamVjdH0gc29tZSBjb25maWcgZm9yIGFwcCBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJ1bmRsZVVybFxuICogQHByb3BlcnR5IHtib29sZWFufSBkZWJ1Z1xuICogQHByb3BlcnR5IHtvYmplY3R9IGVudlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi53ZWV4VmVyc2lvbihleC4gMS4wLjApXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52LmFwcE5hbWUoZXguIFRCL1RNKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi5hcHBWZXJzaW9uKGV4LiA1LjAuMClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYucGxhdGZvcm0oZXguIGlPUy9BbmRyb2lkKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi5vc1ZlcnNpb24oZXguIDcuMC4wKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi5kZXZpY2VNb2RlbCAqKm5hdGl2ZSBvbmx5KipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbnYuW2RldmljZVdpZHRoPTc1MF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbnYuZGV2aWNlSGVpZ2h0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkZ2V0Q29uZmlnIChjYWxsYmFjaykge1xuICBjb25zdCBjb25maWcgPSBleHRlbmQoe1xuICAgIGVudjogZ2xvYmFsLldYRW52aXJvbm1lbnQgfHwge31cbiAgfSwgdGhpcy5fYXBwLm9wdGlvbnMpXG4gIGlmICh0eXBvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIHRoZSBjYWxsYmFjayBvZiBWbSMkZ2V0Q29uZmlnKGNhbGxiYWNrKSBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAgICd0aGlzIGFwaSBub3cgY2FuIGRpcmVjdGx5IFJFVFVSTiBjb25maWcgaW5mby4nKVxuICAgIGNhbGxiYWNrKGNvbmZpZylcbiAgfVxuICByZXR1cm4gY29uZmlnXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIHJlcXVlc3QgbmV0d29yayB2aWEgaHR0cCBwcm90b2NvbFxuICogQHBhcmFtICB7b2JqZWN0fSAgIHBhcmFtc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkc2VuZEh0dHAgKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBWbSMkc2VuZEh0dHAgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAgICAgJ3BsZWFzZSB1c2UgXCJyZXF1aXJlKFxcJ0B3ZWV4LW1vZHVsZS9zdHJlYW1cXCcpJyArXG4gICAgICAgICAgJy5zZW5kSHR0cChwYXJhbXMsIGNhbGxiYWNrKVwiIGluc3RlYWQnKVxuICBjb25zdCBzdHJlYW0gPSB0aGlzLl9hcHAucmVxdWlyZU1vZHVsZSgnc3RyZWFtJylcbiAgc3RyZWFtLnNlbmRIdHRwKHBhcmFtcywgY2FsbGJhY2spXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIG9wZW4gYSB1cmxcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkb3BlblVSTCAodXJsKSB7XG4gIGNvbnNvbGUud2FybignW0pTIEZyYW1ld29ya10gVm0jJG9wZW5VUkwgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAgICAgJ3BsZWFzZSB1c2UgXCJyZXF1aXJlKFxcJ0B3ZWV4LW1vZHVsZS9ldmVudFxcJyknICtcbiAgICAgICAgICAnLm9wZW5VUkwodXJsKVwiIGluc3RlYWQnKVxuICBjb25zdCBldmVudCA9IHRoaXMuX2FwcC5yZXF1aXJlTW9kdWxlKCdldmVudCcpXG4gIGV2ZW50Lm9wZW5VUkwodXJsKVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBzZXQgYSB0aXRsZSBmb3IgcGFnZVxuICogQHBhcmFtICB7c3RyaW5nfSB0aXRsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gJHNldFRpdGxlICh0aXRsZSkge1xuICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIFZtIyRzZXRUaXRsZSBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAgICAgICAncGxlYXNlIHVzZSBcInJlcXVpcmUoXFwnQHdlZXgtbW9kdWxlL3BhZ2VJbmZvXFwnKScgK1xuICAgICAgICAgICcuc2V0VGl0bGUodGl0bGUpXCIgaW5zdGVhZCcpXG4gIGNvbnN0IHBhZ2VJbmZvID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ3BhZ2VJbmZvJylcbiAgcGFnZUluZm8uc2V0VGl0bGUodGl0bGUpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIFwicmVxdWlyZSgnQHdlZXgtbW9kdWxlL21vZHVsZU5hbWUnKSBpbnN0ZWFkXCJcbiAqIGludm9rZSBhIG5hdGl2ZSBtZXRob2QgYnkgc3BlY2lmaW5nIHRoZSBuYW1lIG9mIG1vZHVsZSBhbmQgbWV0aG9kXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtICB7Li4uKn0gdGhlIHJlc3QgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkY2FsbCAobW9kdWxlTmFtZSwgbWV0aG9kTmFtZSwgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIFZtIyRjYWxsIGlzIGRlcHJlY2F0ZWQsICcgK1xuICAgICdwbGVhc2UgdXNlIFwicmVxdWlyZShcXCdAd2VleC1tb2R1bGUvbW9kdWxlTmFtZVxcJylcIiBpbnN0ZWFkJylcbiAgY29uc3QgbW9kdWxlID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUobW9kdWxlTmFtZSlcbiAgaWYgKG1vZHVsZSAmJiBtb2R1bGVbbWV0aG9kTmFtZV0pIHtcbiAgICBtb2R1bGVbbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2FwaS9tZXRob2RzLmpzXG4gKiovIiwiLyogZ2xvYmFsIEV2ZW50ICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyBjb25zdCBGcmFtZVVwZGF0ZXIgPSByZXF1aXJlKCcuL2ZyYW1lVXBkYXRlcicpXG5pbXBvcnQgeyB3YXRjaElmTmVlZGVkIH0gZnJvbSAnLi9hcHBlYXJXYXRjaGVyJ1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJ1xuLy8gY29uc3QgbGF6eWxvYWQgPSByZXF1aXJlKCcuL2xhenlsb2FkJylcbi8vIGNvbnN0IGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJylcblxuY29uc3QgUkVOREVSSU5HX0lOREVOVCA9IDgwMFxuXG5jb25zdCBfaW5zdGFuY2VNYXAgPSB7fVxuY29uc3QgdHlwZU1hcCA9IHt9XG5jb25zdCBzY3JvbGxhYmxlVHlwZXMgPSBbXG4gICdzY3JvbGxlcicsXG4gICdoc2Nyb2xsZXInLFxuICAndnNjcm9sbGVyJyxcbiAgJ2xpc3QnLFxuICAnaGxpc3QnLFxuICAndmxpc3QnXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbXBvbmVudE1hbmFnZXIgKGlkKSB7XG4gIHRoaXMuaWQgPSBpZFxuICB0aGlzLmJhdGNoZWQgPSBmYWxzZVxuICB0aGlzLnVwZGF0ZXMgPSBbXVxuICB0aGlzLmNvbXBvbmVudE1hcCA9IHt9XG4gIF9pbnN0YW5jZU1hcFt0aGlzLmlkXSA9IHRoaXNcbn1cblxuQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZSA9IGluc3RhbmNlSWQgPT4gX2luc3RhbmNlTWFwW2luc3RhbmNlSWRdXG5cbkNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXJDb21wb25lbnQgPSAodHlwZSwgZGVmaW5pdGlvbikgPT4ge1xuICB0eXBlTWFwW3R5cGVdID0gZGVmaW5pdGlvblxufVxuXG5Db21wb25lbnRNYW5hZ2VyLmdldFNjcm9sbGFibGVUeXBlcyA9ICgpID0+IHNjcm9sbGFibGVUeXBlc1xuXG5Db21wb25lbnRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICBnZXRXZWV4SW5zdGFuY2UgKCkge1xuICAgIGlmICghdGhpcy5fd2VleEluc3RhbmNlKSB7XG4gICAgICB0aGlzLl93ZWV4SW5zdGFuY2UgPSBnbG9iYWwud2VleFxuICAgICAgICA/IGdsb2JhbC53ZWV4LmdldEluc3RhbmNlKHRoaXMuaWQpXG4gICAgICAgIDogbnVsbFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2VleEluc3RhbmNlXG4gIH0sXG5cbiAgLy8gRmlyZSBhIGV2ZW50ICdyZW5kZXJiZWdpbicvJ3JlbmRlcmVuZCcgb24gYm9keSBlbGVtZW50LlxuICByZW5kZXJpbmcgKCkge1xuICAgIGZ1bmN0aW9uIF9yZW5kZXJpbmdFbmQgKCkge1xuICAgICAgLy8gZ2V0IHdlZXggaW5zdGFuY2Ugcm9vdFxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZW5kZXJlbmQnKSlcbiAgICAgIHRoaXMuX3JlbmRlcmluZ1RpbWVyID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5fcmVuZGVyaW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZW5kZXJpbmdUaW1lcilcbiAgICAgIHRoaXMuX3JlbmRlcmluZ1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgX3JlbmRlcmluZ0VuZC5iaW5kKHRoaXMpLFxuICAgICAgICBSRU5ERVJJTkdfSU5ERU5UXG4gICAgICApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZW5kZXJiZWdpbicpKVxuICAgICAgdGhpcy5fcmVuZGVyaW5nVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICBfcmVuZGVyaW5nRW5kLmJpbmQodGhpcyksXG4gICAgICAgIFJFTkRFUklOR19JTkRFTlRcbiAgICAgIClcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q29tcG9uZW50IChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICB9LFxuXG4gIHJlbW92ZUNvbXBvbmVudCAocmVmKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBpZiAoIXJlZiB8fCAhdGhpcy5jb21wb25lbnRNYXBbcmVmXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlbW92ZSBmcm9tIHRoaXMuY29tcG9uZW50TWFwIGN1cnNpdmVseVxuICAgIChmdW5jdGlvbiBfcmVtb3ZlQ3Vyc2l2ZWx5IChfcmVmKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHNlbGYuY29tcG9uZW50TWFwW19yZWZdXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBjaGlsZC5fbGlzdGVuZXJzXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkLmRhdGEuY2hpbGRyZW5cbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBfcmVtb3ZlQ3Vyc2l2ZWx5KGNoaWxkcmVuW2ldLnJlZilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGV2ZW50cyBmcm9tIF9yZWYgY29tcG9uZW50XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBjaGlsZC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW3R5cGVdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgY2hpbGQuX2xpc3RlbmVyc1xuICAgICAgZGVsZXRlIGNoaWxkLm5vZGUuX2xpc3RlbmVyc1xuICAgICAgLy8gcmVtb3ZlIF9yZWYgY29tcG9uZW50XG4gICAgICBkZWxldGUgc2VsZi5jb21wb25lbnRNYXBbX3JlZl1cbiAgICB9KShyZWYpXG4gIH0sXG5cbiAgY3JlYXRlRWxlbWVudCAoZGF0YSwgbm9kZVR5cGUpIHtcbiAgICBsZXQgQ29tcG9uZW50VHlwZSA9IHR5cGVNYXBbZGF0YS50eXBlXVxuICAgIGlmICghQ29tcG9uZW50VHlwZSkge1xuICAgICAgQ29tcG9uZW50VHlwZSA9IHR5cGVNYXBbJ2RpdiddXG4gICAgfVxuXG4gICAgZGF0YS5pbnN0YW5jZUlkID0gdGhpcy5pZFxuICAgIGRhdGEuc2NhbGUgPSB0aGlzLmdldFdlZXhJbnN0YW5jZSgpLnNjYWxlXG4gICAgY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudFR5cGUoZGF0YSwgbm9kZVR5cGUpXG4gICAgY29uc3QgcmVmID0gZGF0YS5yZWZcbiAgICB0aGlzLmNvbXBvbmVudE1hcFtyZWZdID0gY29tcG9uZW50XG4gICAgY29tcG9uZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXJlZicsIHJlZilcblxuICAgIHJldHVybiBjb21wb25lbnRcbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlQm9keTogZ2VuZXJhdGUgcm9vdCBjb21wb25lbnRcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50XG4gICAqL1xuICBjcmVhdGVCb2R5IChlbGVtZW50KSB7XG4gICAgY29uc29sZS5sb2coJ1toNS1yZW5kZXJdIGNyZWF0ZUJvZHknLCBlbGVtZW50KVxuICAgIGlmICh0aGlzLmNvbXBvbmVudE1hcFsnX3Jvb3QnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnRvSlNPTigpXG5cbiAgICBjb25zdCBub2RlVHlwZSA9IGVsZW1lbnQudHlwZVxuICAgIGVsZW1lbnQudHlwZSA9ICdyb290J1xuICAgIGVsZW1lbnQucm9vdElkID0gdGhpcy5nZXRXZWV4SW5zdGFuY2UoKS5yb290SWRcbiAgICBlbGVtZW50LnJlZiA9ICdfcm9vdCdcblxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZWxlbWVudCwgbm9kZVR5cGUpXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRXZWV4SW5zdGFuY2UoKS5yb290SWQpXG4gICAgICAgICAgfHwgZG9jdW1lbnQuYm9keVxuICAgIGJvZHkuYXBwZW5kQ2hpbGQocm9vdC5ub2RlKVxuICAgIHJvb3QuX2FwcGVuZGVkID0gdHJ1ZVxuXG4gICAgdGhpcy5oYW5kbGVBcHBlbmQocm9vdClcbiAgfSxcblxuICBhcHBlbmRDaGlsZCAocGFyZW50UmVmLCBkYXRhKSB7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3BhcmVudFJlZl1cblxuICAgIGlmICh0aGlzLmNvbXBvbmVudE1hcFtkYXRhLnJlZl0gfHwgIXBhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudFJlZiA9PT0gJ19yb290JyAmJiAhcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiAncm9vdCcsXG4gICAgICAgIHJvb3RJZDogdGhpcy5nZXRXZWV4SW5zdGFuY2UoKS5yb290SWQsXG4gICAgICAgIHJlZjogJ19yb290J1xuICAgICAgfSlcbiAgICAgIHBhcmVudC5fYXBwZW5kZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZGF0YSlcblxuICAgIC8vIEluIHNvbWUgcGFyZW50IGNvbXBvbmVudCB0aGUgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kXG4gICAgLy8gYXBwZW5kQ2hpbGQgZGlkbid0IHJldHVybiB0aGUgY29tcG9uZW50IGF0IGFsbCwgdGhlcmVmb3JcbiAgICAvLyBjaGlsZCBtYXliZSBhIHVuZGVmaW5lZCBvYmplY3QuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5wYXJlbnRSZWYgPSBwYXJlbnRSZWZcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50Ll9hcHBlbmRlZCkge1xuICAgICAgdGhpcy5oYW5kbGVBcHBlbmQoY2hpbGQpXG4gICAgfVxuICB9LFxuXG4gIC8vIGFwcGVuZENoaWxkcmVuIChyZWYsIGVsZW1lbnRzKSB7XG4gIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAvLyAgICAgdGhpcy5hcHBlbmRDaGlsZChyZWYsIGVsZW1lbnRzW2ldKVxuICAvLyAgIH1cbiAgLy8gfSxcblxuICByZW1vdmVFbGVtZW50IChyZWYpIHtcbiAgICBpZiAoaXNBcnJheShyZWYpKSB7XG4gICAgICByZXR1cm4gcmVmLm1hcChyID0+IHRoaXMucmVtb3ZlRWxlbWVudChyKSlcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIC8vIGZpcmUgZXZlbnQgZm9yIHJlbmRlcmluZyBkb20gb24gYm9keSBlbG1lbnQuXG4gICAgdGhpcy5yZW5kZXJpbmcoKVxuXG4gICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQucGFyZW50UmVmKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtjb21wb25lbnQucGFyZW50UmVmXVxuICAgICAgY29tcG9uZW50Lm9uUmVtb3ZlICYmIGNvbXBvbmVudC5vblJlbW92ZSgpXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29tcG9uZW50KVxuICAgIH1cbiAgICBlbHNlIGlmICghY29tcG9uZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbaDUtcmVuZGVyXSBjb21wb25lbnQgb2YgcmVmICcke3JlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gcGFyZW50IGNvbXBvbmVudCAnJHtjb21wb25lbnQucGFyZW50UmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG4gIH0sXG5cbiAgbW92ZUVsZW1lbnQgKHJlZiwgcGFyZW50UmVmLCBpbmRleCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBjb25zdCBuZXdQYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtwYXJlbnRSZWZdXG4gICAgY29uc3Qgb2xkUGFyZW50UmVmID0gY29tcG9uZW50LnBhcmVudFJlZlxuICAgIGxldCBjaGlsZHJlbiwgYmVmb3JlLCBpLCBsXG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBbaDUtcmVuZGVyXSBjb21wb25lbnQgb2YgcmVmICcke3JlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuICAgIGlmICghbmV3UGFyZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICAgYFtoNS1yZW5kZXJdIHBhcmVudCBjb21wb25lbnQgJyR7cGFyZW50UmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAtMSkge1xuICAgICAgaW5kZXggPSAtMVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIGluZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gLTEuJylcbiAgICB9XG5cbiAgICAvLyBmaXJlIGV2ZW50IGZvciByZW5kZXJpbmcuXG4gICAgdGhpcy5yZW5kZXJpbmcoKVxuXG4gICAgY2hpbGRyZW4gPSBuZXdQYXJlbnQuZGF0YS5jaGlsZHJlblxuICAgIGlmIChjaGlsZHJlblxuICAgICAgICAmJiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgJiYgaW5kZXggIT09IC0xXG4gICAgICAgICYmIGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBiZWZvcmUgPSB0aGlzLmNvbXBvbmVudE1hcFtuZXdQYXJlbnQuZGF0YS5jaGlsZHJlbltpbmRleF0ucmVmXVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBmcm9tIG9sZFBhcmVudC5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKG9sZFBhcmVudFJlZiAmJiB0aGlzLmNvbXBvbmVudE1hcFtvbGRQYXJlbnRSZWZdKSB7XG4gICAgICBjaGlsZHJlbiA9IHRoaXMuY29tcG9uZW50TWFwW29sZFBhcmVudFJlZl0uZGF0YS5jaGlsZHJlblxuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gcmVmKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobCA+IGkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1BhcmVudC5pbnNlcnRCZWZvcmUoY29tcG9uZW50LCBiZWZvcmUpXG5cbiAgICBjb21wb25lbnQub25Nb3ZlICYmIGNvbXBvbmVudC5vbk1vdmUocGFyZW50UmVmLCBpbmRleClcbiAgfSxcblxuICBpbnNlcnRCZWZvcmUgKHJlZiwgZGF0YSkge1xuICAgIGxldCBjaGlsZCwgcGFyZW50XG4gICAgY29uc3QgYmVmb3JlID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGNoaWxkID0gdGhpcy5jb21wb25lbnRNYXBbZGF0YS5yZWZdXG4gICAgYmVmb3JlICYmIChwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtiZWZvcmUucGFyZW50UmVmXSlcbiAgICBpZiAoY2hpbGQgfHwgIXBhcmVudCB8fCAhYmVmb3JlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjaGlsZCA9IHRoaXMuY3JlYXRlRWxlbWVudChkYXRhKVxuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGQucGFyZW50UmVmID0gYmVmb3JlLnBhcmVudFJlZlxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbXBvbmVudE1hcFtiZWZvcmUucGFyZW50UmVmXS5fYXBwZW5kZWQpIHtcbiAgICAgIHRoaXMuaGFuZGxlQXBwZW5kKGNoaWxkKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogYWRkRWxlbWVudFxuICAgKiBJZiBpbmRleCBpcyBsYXJnZXQgdGhhbiBhbnkgY2hpbGQncyBpbmRleCwgdGhlXG4gICAqIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCBiZWhpbmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRSZWZcbiAgICogQHBhcmFtIHtvYmp9IGVsZW1lbnQgKGRhdGEgb2YgdGhlIGNvbXBvbmVudClcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBhZGRFbGVtZW50IChlbGVtZW50LCBwYXJlbnRSZWYsIGluZGV4KSB7XG4gICAgLy8gZmlyZSBldmVudCBmb3IgcmVuZGVyaW5nIGRvbSBvbiBib2R5IGVsbWVudC5cbiAgICBlbGVtZW50ID0gZWxlbWVudC50b0pTT04oKVxuICAgIHRoaXMucmVuZGVyaW5nKClcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3BhcmVudFJlZl1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmRhdGEuY2hpbGRyZW5cbiAgICAvLyAtMSBtZWFucyBhcHBlbmQgYXMgdGhlIGxhc3QuXG4gICAgaWYgKGluZGV4IDwgLTEpIHtcbiAgICAgIGluZGV4ID0gLTFcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBpbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xLicpXG4gICAgfVxuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gaW5kZXhcbiAgICAgICAgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShjaGlsZHJlbltpbmRleF0ucmVmLCBlbGVtZW50KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocGFyZW50UmVmLCBlbGVtZW50KVxuICAgIH1cbiAgfSxcblxuICBhZGRFdmVudCAocmVmLCB0eXBlKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBjb21wb25lbnQuYmluZEV2ZW50cyhbdHlwZV0pXG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnQgKHJlZiwgdHlwZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIGNvbXBvbmVudCBvZiByZWYgJyR7cmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgY29tcG9uZW50LnVuYmluZEV2ZW50cyhbdHlwZV0pXG4gIH0sXG5cbiAgc2V0QXR0ciAocmVmLCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBjb21wb25lbnQudXBkYXRlQXR0cnMoeyBba2V5XTogdmFsdWUgfSlcbiAgICAvLyBpZiAoY29tcG9uZW50LmRhdGEudHlwZSA9PT0gJ2ltYWdlJyAmJiBrZXkgPT09ICdzcmMnKSB7XG4gICAgLy8gIGNvbXBvbmVudC5maXJlXG4gICAgLy8gIGxhenlsb2FkLnN0YXJ0SWZOZWVkZWQoY29tcG9uZW50KVxuICAgIC8vIH1cbiAgfSxcblxuICBzZXRTdHlsZSAocmVmLCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBjb21wb25lbnQudXBkYXRlU3R5bGUoeyBba2V5XTogdmFsdWUgfSlcbiAgfSxcblxuICBzZXRTdHlsZXMgKHJlZiwgc3R5bGUpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBbaDUtcmVuZGVyXSBjb21wb25lbnQgb2YgcmVmICcke3JlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuICAgIGNvbXBvbmVudC51cGRhdGVTdHlsZShzdHlsZSlcbiAgfSxcblxuICBoYW5kbGVBcHBlbmQgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5fYXBwZW5kZWQgPSB0cnVlXG4gICAgY29tcG9uZW50Lm9uQXBwZW5kICYmIGNvbXBvbmVudC5vbkFwcGVuZCgpXG5cbiAgICAvLyBpbnZva2Ugb25BcHBlbmQgb24gY2hpbGRyZW4gcmVjdXJzaXZlbHlcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbXBvbmVudC5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jb21wb25lbnRNYXBbY2hpbGRyZW5baV0ucmVmXVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUFwcGVuZChjaGlsZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdhdGNoIGFwcGVhci9kaXNhcHBlYXIgb2YgdGhlIGNvbXBvbmVudCBpZiBuZWVkZWRcbiAgICB3YXRjaElmTmVlZGVkKGNvbXBvbmVudClcblxuICAgIC8vIGRvIGxhenlsb2FkIGlmIG5lZWRlZFxuICAgIGNvbXBvbmVudC5maXJlTGF6eWxvYWQoKVxuICAgIC8vIGxhenlsb2FkLnN0YXJ0SWZOZWVkZWQoY29tcG9uZW50KTtcbiAgfSxcblxuICBjcmVhdGVGaW5pc2ggKGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xuICB9LFxuXG4gIHVwZGF0ZUZpbmlzaCAoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPXG4gIH0sXG5cbiAgcmVmcmVzaEZpbmlzaCAoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPXG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2RvbS9jb21wb25lbnRNYW5hZ2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5jb25zdCBjb21wb25lbnRzSW5TY3JvbGxlciA9IFtdXG5jb25zdCBjb21wb25lbnRzT3V0T2ZTY3JvbGxlciA9IFtdXG5sZXQgbGlzdGVuZWQgPSBmYWxzZVxubGV0IGRpcmVjdGlvbiA9ICd1cCdcbmxldCBzY3JvbGxZID0gMFxuXG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hJZk5lZWRlZCAoY29tcG9uZW50KSB7XG4gIGlmIChuZWVkV2F0Y2goY29tcG9uZW50KSkge1xuICAgIGlmIChjb21wb25lbnQuaXNJblNjcm9sbGFibGUoKSkge1xuICAgICAgY29tcG9uZW50c0luU2Nyb2xsZXIucHVzaChjb21wb25lbnQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29tcG9uZW50c091dE9mU2Nyb2xsZXIucHVzaChjb21wb25lbnQpXG4gICAgfVxuICAgIGlmICghbGlzdGVuZWQpIHtcbiAgICAgIGxpc3RlbmVkID0gdHJ1ZVxuICAgICAgLy8gY29uc3QgaGFuZGxlciA9IHRocm90dGxlKG9uU2Nyb2xsLCAyNSlcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aHJvdHRsZShvblNjcm9sbCwgMTAwKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkV2F0Y2ggKGNvbXBvbmVudCkge1xuICBjb25zdCBldmVudHMgPSBjb21wb25lbnQuZGF0YS5ldmVudFxuICBpZiAoZXZlbnRzXG4gICAgICAmJiAoZXZlbnRzLmluZGV4T2YoJ2FwcGVhcicpICE9PSAtMVxuICAgICAgICB8fCBldmVudHMuaW5kZXhPZignZGlzYXBwZWFyJykgIT09IC0xKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG9uU2Nyb2xsIChlKSB7XG4gIC8vIElmIHRoZSBzY3JvbGwgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIGEgc2Nyb2xsYWJsZSBjb21wb25lbnRcbiAgLy8gaW1wbGVtZW50ZWQgdGhyb3VnaCBzY3JvbGxlcmpzLCB0aGVuIHRoZSBhcHBlYXIvZGlzYXBwZWFyIGV2ZW50c1xuICAvLyBzaG91bGQgYmUgdHJlYXRlZCBzcGVjaWFsbHkgYnkgaGFuZGxlU2Nyb2xsZXJTY3JvbGwuXG4gIGlmIChlLm9yaWdpbmFsVHlwZSA9PT0gJ3Njcm9sbGluZycpIHtcbiAgICBoYW5kbGVTY3JvbGxlclNjcm9sbChlKVxuICB9XG4gIGVsc2Uge1xuICAgIGhhbmRsZVdpbmRvd1Njcm9sbCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsZXJTY3JvbGwgKGUpIHtcbiAgY29uc3QgY21wcyA9IGNvbXBvbmVudHNJblNjcm9sbGVyXG4gIGNvbnN0IGxlbiA9IGNtcHMubGVuZ3RoXG4gIGRpcmVjdGlvbiA9IGUuZGlyZWN0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjbXBzW2ldXG4gICAgY29uc3QgYXBwZWFyID0gaXNDb21wb25lbnRJblNjcm9sbGVyQXBwZWFyKGNvbXBvbmVudClcbiAgICBpZiAoYXBwZWFyICYmICFjb21wb25lbnQuX2FwcGVhcikge1xuICAgICAgY29tcG9uZW50Ll9hcHBlYXIgPSB0cnVlXG4gICAgICBmaXJlRXZlbnQoY29tcG9uZW50LCAnYXBwZWFyJylcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFwcGVhciAmJiBjb21wb25lbnQuX2FwcGVhcikge1xuICAgICAgY29tcG9uZW50Ll9hcHBlYXIgPSBmYWxzZVxuICAgICAgZmlyZUV2ZW50KGNvbXBvbmVudCwgJ2Rpc2FwcGVhcicpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVdpbmRvd1Njcm9sbCAoKSB7XG4gIGNvbnN0IHkgPSB3aW5kb3cuc2Nyb2xsWVxuICBkaXJlY3Rpb24gPSB5ID49IHNjcm9sbFkgPyAndXAnIDogJ2Rvd24nXG4gIHNjcm9sbFkgPSB5XG5cbiAgY29uc3QgbGVuID0gY29tcG9uZW50c091dE9mU2Nyb2xsZXIubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c091dE9mU2Nyb2xsZXJbaV1cbiAgICBjb25zdCBhcHBlYXIgPSBpc0NvbXBvbmVudEluV2luZG93KGNvbXBvbmVudClcbiAgICBpZiAoYXBwZWFyICYmICFjb21wb25lbnQuX2FwcGVhcikge1xuICAgICAgY29tcG9uZW50Ll9hcHBlYXIgPSB0cnVlXG4gICAgICBmaXJlRXZlbnQoY29tcG9uZW50LCAnYXBwZWFyJylcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFwcGVhciAmJiBjb21wb25lbnQuX2FwcGVhcikge1xuICAgICAgY29tcG9uZW50Ll9hcHBlYXIgPSBmYWxzZVxuICAgICAgZmlyZUV2ZW50KGNvbXBvbmVudCwgJ2Rpc2FwcGVhcicpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29tcG9uZW50SW5TY3JvbGxlckFwcGVhciAoY29tcG9uZW50KSB7XG4gIGxldCBwYXJlbnRTY3JvbGxlciA9IGNvbXBvbmVudC5fcGFyZW50U2Nyb2xsZXJcbiAgY29uc3QgY21wUmVjdCA9IGNvbXBvbmVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGlmICghaXNDb21wb25lbnRJbldpbmRvdyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgd2hpbGUgKHBhcmVudFNjcm9sbGVyKSB7XG4gICAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudFNjcm9sbGVyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoIShjbXBSZWN0LnJpZ2h0ID4gcGFyZW50UmVjdC5sZWZ0XG4gICAgICAgICYmIGNtcFJlY3QubGVmdCA8IHBhcmVudFJlY3QucmlnaHRcbiAgICAgICAgJiYgY21wUmVjdC5ib3R0b20gPiBwYXJlbnRSZWN0LnRvcFxuICAgICAgICAmJiBjbXBSZWN0LnRvcCA8IHBhcmVudFJlY3QuYm90dG9tKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHBhcmVudFNjcm9sbGVyID0gcGFyZW50U2Nyb2xsZXIuX3BhcmVudFNjcm9sbGVyXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaXNDb21wb25lbnRJbldpbmRvdyAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHJlY3QgPSBjb21wb25lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdC5yaWdodCA+IDAgJiYgcmVjdC5sZWZ0IDwgd2luZG93LmlubmVyV2lkdGggJiZcbiAgICAgICAgIHJlY3QuYm90dG9tID4gMCAmJiByZWN0LnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodFxufVxuXG5mdW5jdGlvbiBmaXJlRXZlbnQgKGNvbXBvbmVudCwgdHlwZSkge1xuICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gIGNvbnN0IGRhdGEgPSB7IGRpcmVjdGlvbjogZGlyZWN0aW9uIH1cbiAgZXZ0LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpXG4gIGV2dC5kYXRhID0gZGF0YVxuICBleHRlbmQoZXZ0LCBkYXRhKVxuICBjb21wb25lbnQubm9kZS5kaXNwYXRjaEV2ZW50KGV2dClcbn1cblxuZnVuY3Rpb24gdGhyb3R0bGUgKGZ1bmMsIHdhaXQpIHtcbiAgbGV0IGNvbnRleHQsIGFyZ3MsIHJlc3VsdFxuICBsZXQgdGltZW91dCA9IG51bGxcbiAgbGV0IHByZXZpb3VzID0gMFxuICBjb25zdCBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcmV2aW91cyA9IERhdGUubm93KClcbiAgICB0aW1lb3V0ID0gbnVsbFxuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKVxuICAgIGNvbnRleHQgPSB0aGlzXG4gICAgYXJncyA9IGFyZ3VtZW50c1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgcHJldmlvdXMgPSBub3dcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICB9XG4gICAgZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2RvbS9hcHBlYXJXYXRjaGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgd2VleFZlcnNpb246ICcwLjUuMCcsXG4gIGRlYnVnOiBmYWxzZSxcbiAgdmFsaWRSb290czogWydkaXYnLCAnbGlzdCcsICd2bGlzdCcsICdzY3JvbGxlciddXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3JlbmRlci9jb25maWcuanNcbiAqKi8iLCIvKiBnbG9iYWwgWE1MSHR0cFJlcXVlc3QgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGxvYWRCeVhIUiAoY29uZmlnLCBjYWxsYmFjaykge1xuICBpZiAoIWNvbmZpZy5zb3VyY2UpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ3hociBsb2FkZXI6IG1pc3NpbmcgY29uZmlnLnNvdXJjZS4nKSlcbiAgfVxuICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbignR0VUJywgY29uZmlnLnNvdXJjZSlcbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCB0aGlzLnJlc3BvbnNlVGV4dClcbiAgfVxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9yKVxuICB9XG4gIHhoci5zZW5kKClcbn1cblxuZnVuY3Rpb24gbG9hZEJ5SnNvbnAgKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgaWYgKCFjb25maWcuc291cmNlKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdqc29ucCBsb2FkZXI6IG1pc3NpbmcgY29uZmlnLnNvdXJjZS4nKSlcbiAgfVxuICBjb25zdCBjYWxsYmFja05hbWUgPSBjb25maWcuanNvbnBDYWxsYmFjayB8fCAnd2VleEpzb25wQ2FsbGJhY2snXG4gIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBpZiAoY29kZSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgY29kZSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2xvYWQgYnkganNvbnAgZXJyb3InKSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgc2NyaXB0LnNyYyA9IGRlY29kZVVSSUNvbXBvbmVudChjb25maWcuc291cmNlKVxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxufVxuXG5mdW5jdGlvbiBsb2FkQnlTb3VyY2VDb2RlIChjb25maWcsIGNhbGxiYWNrKSB7XG4gIC8vIHNyYyBpcyB0aGUganNidW5kbGUuXG4gIC8vIG5vIG5lZWQgdG8gZmV0Y2ggZnJvbSBhbnl3aGVyZS5cbiAgaWYgKGNvbmZpZy5zb3VyY2UpIHtcbiAgICBjYWxsYmFjayhudWxsLCBjb25maWcuc291cmNlKVxuICB9XG4gIGVsc2Uge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignc291cmNlIGNvZGUgbGFvZGVyOiBtaXNzaW5nIGNvbmZpZy5zb3VyY2UuJykpXG4gIH1cbn1cblxuY29uc3QgY2FsbGJhY2tNYXAgPSB7XG4gIHhocjogbG9hZEJ5WEhSLFxuICBqc29ucDogbG9hZEJ5SnNvbnAsXG4gIHNvdXJjZTogbG9hZEJ5U291cmNlQ29kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZCAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgbG9hZEZuID0gY2FsbGJhY2tNYXBbb3B0aW9ucy5sb2FkZXJdXG4gIGxvYWRGbihvcHRpb25zLCBjYWxsYmFjaylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTG9hZGVyIChuYW1lLCBsb2FkZXJGdW5jKSB7XG4gIGlmICh0eXBlb2YgbG9hZGVyRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrTWFwW25hbWVdID0gbG9hZGVyRnVuY1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL2xvYWRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgcHJvdG9jb2wgZnJvbSAnLi9wcm90b2NvbCdcbmltcG9ydCByZWNlaXZlciBmcm9tICcuL3JlY2VpdmVyJ1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL3NlbmRlcidcblxuZXhwb3J0IHsgcHJvdG9jb2wsIHJlY2VpdmVyLCBTZW5kZXIgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2JyaWRnZS9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLy8gd2VleCBpbnN0YW5jZXNcbiAgX2luc3RhbmNlczoge30sXG5cbiAgLy8gYXBpIG1ldGEgaW5mb1xuICBfbWV0YToge30sXG5cbiAgLy8gV2VleC5yZWdpc3RlckFwaU1vZHVsZSB1c2VkIHRoaXMgdG8gcmVnaXN0ZXIgYW5kIGFjY2VzcyBhcGlNb2R1bGVzLlxuICBhcGlNb2R1bGU6IHt9LFxuXG4gIC8vIGdldCB0aGUgYXBpIG1ldGhvZCBtZXRhIGluZm8gYXJyYXkgZm9yIHRoZSBtb2R1bGUuXG4gIGdldEFwaU1vZHVsZU1ldGE6IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgY29uc3QgbWV0YU9iaiA9IHt9XG4gICAgbWV0YU9ialttb2R1bGVOYW1lXSA9IHRoaXMuX21ldGFbbW9kdWxlTmFtZV1cbiAgICByZXR1cm4gbWV0YU9ialxuICB9LFxuXG4gIC8vIFNldCBtZXRhIGluZm8gZm9yIGEgYXBpIG1vZHVsZS5cbiAgLy8gSWYgdGhlcmUgaXMgYSBzYW1lIG5hbWVkIGFwaSwganVzdCByZXBsYWNlIGl0LlxuICAvLyBvcHRzOlxuICAvLyAtIG1ldGFPYmo6IG1ldGEgb2JqZWN0IGxpa2VcbiAgLy8ge1xuICAvLyAgICBkb206IFt7XG4gIC8vICAgICAgbmFtZTogJ2FkZEVsZW1lbnQnLFxuICAvLyAgICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCddXG4gIC8vICAgIH1dXG4gIC8vIH1cbiAgc2V0QXBpTW9kdWxlTWV0YTogZnVuY3Rpb24gKG1ldGFPYmopIHtcbiAgICBsZXQgbW9kdWxlTmFtZVxuICAgIGZvciAoY29uc3QgayBpbiBtZXRhT2JqKSB7XG4gICAgICBpZiAobWV0YU9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBtb2R1bGVOYW1lID0ga1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRhQXJyYXkgPSB0aGlzLl9tZXRhW21vZHVsZU5hbWVdXG4gICAgaWYgKCFtZXRhQXJyYXkpIHtcbiAgICAgIHRoaXMuX21ldGFbbW9kdWxlTmFtZV0gPSBtZXRhT2JqW21vZHVsZU5hbWVdXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmFtZU9iaiA9IHt9XG4gICAgICBtZXRhT2JqW21vZHVsZU5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICBuYW1lT2JqW2FwaS5uYW1lXSA9IGFwaVxuICAgICAgfSlcbiAgICAgIG1ldGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChhcGksIGkpIHtcbiAgICAgICAgaWYgKG5hbWVPYmpbYXBpLm5hbWVdKSB7XG4gICAgICAgICAgbWV0YUFycmF5W2ldID0gbmFtZU9ialthcGkubmFtZV1cbiAgICAgICAgICBkZWxldGUgbmFtZU9ialthcGkubmFtZV1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvciAoY29uc3QgayBpbiBtZXRhT2JqKSB7XG4gICAgICAgIGlmIChtZXRhT2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgbWV0YUFycmF5LnB1c2gobWV0YU9ialtrXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tZXRhW21vZHVsZU5hbWVdID0gbWV0YU9ialttb2R1bGVOYW1lXVxuICB9LFxuXG4gIC8vIFNldCBtZXRhIGluZm8gZm9yIGEgc2luZ2xlIGFwaS5cbiAgLy8gb3B0czpcbiAgLy8gIC0gbW9kdWxlTmFtZTogYXBpIG1vZHVsZSBuYW1lLlxuICAvLyAgLSBtZXRhOiBhIG1ldGEgb2JqZWN0IGxpa2U6XG4gIC8vICB7XG4gIC8vICAgIG5hbWU6ICdhZGRFbGVtZW50JyxcbiAgLy8gICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0J11cbiAgLy8gIH1cbiAgc2V0QXBpTWV0YTogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIG1ldGEpIHtcbiAgICBjb25zdCBtZXRhQXJyYXkgPSB0aGlzLl9tZXRhW21vZHVsZU5hbWVdXG4gICAgaWYgKCFtZXRhQXJyYXkpIHtcbiAgICAgIHRoaXMuX21ldGFbbW9kdWxlTmFtZV0gPSBbbWV0YV1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgbWV0YUlkeCA9IC0xXG4gICAgICBtZXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYXBpLCBpKSB7XG4gICAgICAgIGxldCBuYW1lIC8vIHRvZG9cbiAgICAgICAgaWYgKG1ldGEubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIG1ldGFJZHggPSBpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAobWV0YUlkeCAhPT0gLTEpIHtcbiAgICAgICAgbWV0YUFycmF5W21ldGFJZHhdID0gbWV0YVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1ldGFBcnJheS5wdXNoKG1ldGEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIF9yZWdpc3Rlck1vZHVsZXMoW3tcbi8vICAgbW9kYWw6IFt7XG4vLyAgICAgbmFtZTogJ3RvYXN0Jyxcbi8vICAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4vLyAgIH0sIHtcbi8vICAgICBuYW1lOiAnYWxlcnQnLFxuLy8gICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbi8vICAgfSwge1xuLy8gICAgIG5hbWU6ICdjb25maXJtJyxcbi8vICAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4vLyAgIH0sIHtcbi8vICAgICBuYW1lOiAncHJvbXB0Jyxcbi8vICAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4vLyAgIH1dXG4vLyB9LCB7XG4vLyAgIGFuaW1hdGlvbjogW3tcbi8vICAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4vLyAgICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbi8vICAgfV1cbi8vIH1dKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2JyaWRnZS9wcm90b2NvbC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL3JlbmRlci9jb25maWcnXG5pbXBvcnQgcHJvdG9jb2wgZnJvbSAnLi9wcm90b2NvbCdcbmltcG9ydCB7IGlzQXJyYXksIGZyYW1lVXBkYXRlciB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL3NlbmRlcidcblxuY29uc3QgY2FsbFF1ZXVlID0gW11cbi8vIE5lZWQgYSB0YXNrIGNvdW50ZXI/XG4vLyBXaGVuIGZyYW1lVXBkYXRlciBpcyBub3QgYWN0aXZhdGVkLCB0YXNrcyB3aWxsIG5vdCBiZSBwdXNoXG4vLyBpbnRvIGNhbGxRdWV1ZSBhbmQgdGhlcmUgd2lsbCBiZSBubyB0cmFjZSBmb3Igc2l0dWF0aW9uIG9mXG4vLyBleGVjdXRpb24gb2YgdGFza3MuXG5cbi8vIGdpdmUgMTBtcyBmb3IgY2FsbCBoYW5kbGluZywgYW5kIHJlc3QgNm1zIGZvciBvdGhlcnNcbmNvbnN0IE1BWF9USU1FX0ZPUl9FQUNIX0ZSQU1FID0gMTBcblxuLy8gY2FsbE5hdGl2ZToganNGcmFtZXdvcmsgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIHRvIHRhbGsgdG9cbi8vIHRoaXMgcmVuZGVyZXIuXG4vLyBwYXJhbXM6XG4vLyAgLSBpbnN0YW5jZUlkOiBzdHJpbmcuXG4vLyAgLSB0YXNrczogYXJyYXkgb2Ygb2JqZWN0LlxuLy8gIC0gY2FsbGJhY2tJZDogbnVtYmVyLlxuZnVuY3Rpb24gY2FsbE5hdGl2ZSAoaW5zdGFuY2VJZCwgdGFza3MsIGNhbGxiYWNrSWQpIHtcbiAgbGV0IGNhbGxzID0gW11cbiAgaWYgKHR5cGVvZiB0YXNrcyA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbHMgPSBKU09OLnBhcnNlKHRhc2tzKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignaW52YWxpZCB0YXNrczonLCB0YXNrcylcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNBcnJheSh0YXNrcykpIHtcbiAgICBjYWxscyA9IHRhc2tzXG4gIH1cbiAgY29uc3QgbGVuID0gY2FsbHMubGVuZ3RoXG4gIGNhbGxzW2xlbiAtIDFdLmNhbGxiYWNrSWQgPSAoIWNhbGxiYWNrSWQgJiYgY2FsbGJhY2tJZCAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsbGJhY2tJZFxuICAvLyBUbyBzb2x2ZSB0aGUgcHJvYmxlbSBvZiBjYWxsYXBwLCB0aGUgdHdvLXdheSB0aW1lIGxvb3AgcnVsZSBtdXN0XG4gIC8vIGJlIHJlcGxhY2VkIGJ5IGNhbGxpbmcgZGlyZWN0bHkgZXhjZXB0IHRoZSBzaXR1YXRpb24gb2YgcGFnZSBsb2FkaW5nLlxuICAvLyAyMDE1LTExLTAzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZnJhbWVVcGRhdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgIGNhbGxRdWV1ZS5wdXNoKHtcbiAgICAgICAgaW5zdGFuY2VJZDogaW5zdGFuY2VJZCxcbiAgICAgICAgY2FsbDogY2FsbHNbaV1cbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHJvY2Vzc0NhbGwoaW5zdGFuY2VJZCwgY2FsbHNbaV0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDYWxsUXVldWUgKCkge1xuICBsZXQgbGVuID0gY2FsbFF1ZXVlLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpXG4gIGxldCBlbGFwc2VkID0gMFxuXG4gIHdoaWxlICgtLWxlbiA+PSAwICYmIGVsYXBzZWQgPCBNQVhfVElNRV9GT1JfRUFDSF9GUkFNRSkge1xuICAgIGNvbnN0IGNhbGxPYmogPSBjYWxsUXVldWUuc2hpZnQoKVxuICAgIHByb2Nlc3NDYWxsKGNhbGxPYmouaW5zdGFuY2VJZCwgY2FsbE9iai5jYWxsKVxuICAgIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc3RhcnRcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2FsbCAoaW5zdGFuY2VJZCwgY2FsbCkge1xuICBjb25zdCBtb2R1bGVOYW1lID0gY2FsbC5tb2R1bGVcbiAgY29uc3QgbWV0aG9kTmFtZSA9IGNhbGwubWV0aG9kXG4gIGxldCBtb2R1bGUsIG1ldGhvZFxuICBjb25zdCBhcmdzID0gY2FsbC5hcmdzIHx8IGNhbGwuYXJndW1lbnRzIHx8IFtdXG5cbiAgaWYgKCEobW9kdWxlID0gcHJvdG9jb2wuYXBpTW9kdWxlW21vZHVsZU5hbWVdKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghKG1ldGhvZCA9IG1vZHVsZVttZXRob2ROYW1lXSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG1ldGhvZC5hcHBseShnbG9iYWwud2VleC5nZXRJbnN0YW5jZShpbnN0YW5jZUlkKSwgYXJncylcblxuICBjb25zdCBjYWxsYmFja0lkID0gY2FsbC5jYWxsYmFja0lkXG4gIGlmICgoY2FsbGJhY2tJZFxuICAgIHx8IGNhbGxiYWNrSWQgPT09IDBcbiAgICB8fCBjYWxsYmFja0lkID09PSAnMCcpXG4gICAgJiYgY2FsbGJhY2tJZCAhPT0gJy0xJ1xuICAgICYmIGNhbGxiYWNrSWQgIT09IC0xKSB7XG4gICAgcGVyZm9ybU5leHRUaWNrKGluc3RhbmNlSWQsIGNhbGxiYWNrSWQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybU5leHRUaWNrIChpbnN0YW5jZUlkLCBjYWxsYmFja0lkKSB7XG4gIFNlbmRlci5nZXRTZW5kZXIoaW5zdGFuY2VJZCkucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQpXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUxvZyAoKSB7XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdLm1hdGNoKC9ecGVyZi8pKSB7XG4gICAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4cG9ydHNCcmlkZ2VNZXRob2RzVG9HbG9iYWwgKCkge1xuICBnbG9iYWwuY2FsbE5hdGl2ZSA9IGNhbGxOYXRpdmVcbiAgZ2xvYmFsLm5hdGl2ZUxvZyA9IG5hdGl2ZUxvZ1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcm9jZXNzIGNhbGxRdWV1ZSBldmVyeSAxNiBtaWxsaXNlY29uZHMuXG4gICAgZnJhbWVVcGRhdGVyLmFkZFVwZGF0ZU9ic2VydmVyKHByb2Nlc3NDYWxsUXVldWUpXG4gICAgZnJhbWVVcGRhdGVyLnN0YXJ0KClcblxuICAgIC8vIGV4cG9ydHMgbWV0aG9kcyB0byBnbG9iYWwod2luZG93KS5cbiAgICBleHBvcnRzQnJpZGdlTWV0aG9kc1RvR2xvYmFsKClcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2JyaWRnZS9yZWNlaXZlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscydcblxuY29uc3QgX3NlbmRlck1hcCA9IHt9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNlbmRlciAoaW5zdGFuY2UpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlbmRlcikpIHtcbiAgICByZXR1cm4gbmV3IFNlbmRlcihpbnN0YW5jZSlcbiAgfVxuICB0aGlzLmluc3RhbmNlSWQgPSBpbnN0YW5jZS5pbnN0YW5jZUlkXG4gIHRoaXMud2VleEluc3RhbmNlID0gaW5zdGFuY2VcbiAgX3NlbmRlck1hcFt0aGlzLmluc3RhbmNlSWRdID0gdGhpc1xufVxuXG5mdW5jdGlvbiBfc2VuZCAoaW5zdGFuY2VJZCwgbXNnKSB7XG4gIGNhbGxKUyhpbnN0YW5jZUlkLCBbbXNnXSlcbn1cblxuU2VuZGVyLmdldFNlbmRlciA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gIHJldHVybiBfc2VuZGVyTWFwW2luc3RhbmNlSWRdXG59XG5cblNlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgLy8gcGVyZm9ybSBhIGNhbGxiYWNrIHRvIGpzZnJhbWV3b3JrLlxuICBwZXJmb3JtQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFja0lkLCBkYXRhLCBrZWVwQWxpdmUpIHtcbiAgICBjb25zdCBhcmdzID0gW2NhbGxiYWNrSWRdXG4gICAgZGF0YSAmJiBhcmdzLnB1c2goZGF0YSlcbiAgICBrZWVwQWxpdmUgJiYgYXJncy5wdXNoKGtlZXBBbGl2ZSlcbiAgICBfc2VuZCh0aGlzLmluc3RhbmNlSWQsIHtcbiAgICAgIG1ldGhvZDogJ2NhbGxiYWNrJyxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KVxuICB9LFxuXG4gIGZpcmVFdmVudDogZnVuY3Rpb24gKHJlZiwgdHlwZSwgZnVuYywgZXZlbnQpIHtcbiAgICBmdW5jLmV4dHJhICYmIGV4dGVuZChldmVudCwgZnVuYy5leHRyYSgpKVxuICAgIF9zZW5kKHRoaXMuaW5zdGFuY2VJZCwge1xuICAgICAgbWV0aG9kOiAnZmlyZUV2ZW50JyxcbiAgICAgIGFyZ3M6IFtyZWYsIHR5cGUsIGV2ZW50LCBmdW5jLnVwZGF0b3IgJiYgZnVuYy51cGRhdG9yKCldXG4gICAgfSlcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYnJpZGdlL3NlbmRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IENvbXBvbmVudE1hbmFnZXIgfSBmcm9tICcuLi8uLi9kb20nXG5pbXBvcnQgKiBhcyBvcGVyYXRlIGZyb20gJy4vb3BlcmF0ZSdcbmltcG9ydCAqIGFzIHBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nXG5pbXBvcnQgZmxleGJveCBmcm9tICcuL2ZsZXhib3gnXG5pbXBvcnQgeyBtYWtlSW1hZ2VMYXp5LCBmaXJlTGF6eWxvYWQgfSBmcm9tICcuL2xhenlsb2FkJ1xuXG5mdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24gKHJlY3QsIGN0UmVjdCkge1xuICByZXR1cm4gKHJlY3QubGVmdCA8IGN0UmVjdC5yaWdodCAmJiByZWN0LnJpZ2h0ID4gY3RSZWN0LmxlZnQpXG4gICAgJiYgKHJlY3QudG9wIDwgY3RSZWN0LmJvdHRvbSAmJiByZWN0LmJvdHRvbSA+IGN0UmVjdC50b3ApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbXBvbmVudCAoZGF0YSwgbm9kZVR5cGUpIHtcbiAgdGhpcy5kYXRhID0gZGF0YVxuICB0aGlzLm5vZGUgPSB0aGlzLmNyZWF0ZShub2RlVHlwZSlcbiAgdGhpcy5jcmVhdGVDaGlsZHJlbigpXG4gIHRoaXMudXBkYXRlQXR0cnModGhpcy5kYXRhLmF0dHIgfHwge30pXG4gIC8vIGlzc3VlOiB3aGVuIGFkZCBlbGVtZW50IHRvIGEgbGlzdCBpbiBsaWZldGltZSBob29rICdyZWFkeScsIHRoZVxuICAvLyBzdHlsZXMgaXMgc2V0IHRvIHRoZSBjbGFzc1N0eWxlLCBub3Qgc3R5bGUuIFRoaXMgaXMgYSBpc3N1ZVxuICAvLyB0aGF0IGpzZnJhbWV3b3JrIHNob3VsZCBkbyBzb21ldGhpbmcgYWJvdXQuXG4gIGNvbnN0IGNsYXNzU3R5bGUgPSB0aGlzLmRhdGEuY2xhc3NTdHlsZVxuICBjbGFzc1N0eWxlICYmIHRoaXMudXBkYXRlU3R5bGUodGhpcy5kYXRhLmNsYXNzU3R5bGUpXG4gIHRoaXMudXBkYXRlU3R5bGUodGhpcy5kYXRhLnN0eWxlIHx8IHt9KVxuICB0aGlzLmJpbmRFdmVudHModGhpcy5kYXRhLmV2ZW50IHx8IFtdKVxufVxuXG5Db21wb25lbnQucHJvdG90eXBlID0ge1xuXG4gIGdldENvbXBvbmVudE1hbmFnZXIgKCkge1xuICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldEluc3RhbmNlKHRoaXMuZGF0YS5pbnN0YW5jZUlkKVxuICB9LFxuXG4gIGdldFdlZXhJbnN0YW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLmdldFdlZXhJbnN0YW5jZSgpXG4gIH0sXG5cbiAgZ2V0UGFyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKCkuY29tcG9uZW50TWFwW3RoaXMucGFyZW50UmVmXVxuICB9LFxuXG4gIGdldFBhcmVudFNjcm9sbGVyICgpIHtcbiAgICBpZiAodGhpcy5pc0luU2Nyb2xsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50U2Nyb2xsZXJcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBnZXRSb290U2Nyb2xsZXIgKCkge1xuICAgIGlmICh0aGlzLmlzSW5TY3JvbGxhYmxlKCkpIHtcbiAgICAgIGxldCBzY3JvbGxlciA9IHRoaXMuX3BhcmVudFNjcm9sbGVyXG4gICAgICBsZXQgcGFyZW50ID0gc2Nyb2xsZXIuX3BhcmVudFNjcm9sbGVyXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHNjcm9sbGVyID0gcGFyZW50XG4gICAgICAgIHBhcmVudCA9IHNjcm9sbGVyLl9wYXJlbnRTY3JvbGxlclxuICAgICAgfVxuICAgICAgcmV0dXJuIHNjcm9sbGVyXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZ2V0Um9vdENvbnRhaW5lciAoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuZ2V0V2VleEluc3RhbmNlKCkuZ2V0Um9vdCgpXG4gICAgICB8fCBkb2N1bWVudC5ib2R5XG4gICAgcmV0dXJuIHJvb3RcbiAgfSxcblxuICBpc1Njcm9sbGFibGUgKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmRhdGEudHlwZVxuICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldFNjcm9sbGFibGVUeXBlcygpLmluZGV4T2YodCkgIT09IC0xXG4gIH0sXG5cbiAgaXNJblNjcm9sbGFibGUgKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faXNJblNjcm9sbGFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzSW5TY3JvbGxhYmxlXG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICBpZiAocGFyZW50XG4gICAgICAgICYmICh0eXBlb2YgcGFyZW50Ll9pc0luU2Nyb2xsYWJsZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAmJiAhcGFyZW50LmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICBpZiAocGFyZW50LmRhdGEucmVmID09PSAnX3Jvb3QnKSB7XG4gICAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IHBhcmVudC5pc0luU2Nyb2xsYWJsZSgpXG4gICAgICB0aGlzLl9wYXJlbnRTY3JvbGxlciA9IHBhcmVudC5fcGFyZW50U2Nyb2xsZXJcbiAgICAgIHJldHVybiB0aGlzLl9pc0luU2Nyb2xsYWJsZVxuICAgIH1cbiAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQuX2lzSW5TY3JvbGxhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gcGFyZW50Ll9pc0luU2Nyb2xsYWJsZVxuICAgICAgdGhpcy5fcGFyZW50U2Nyb2xsZXIgPSBwYXJlbnQuX3BhcmVudFNjcm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5faXNJblNjcm9sbGFibGVcbiAgICB9XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNTY3JvbGxhYmxlKCkpIHtcbiAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gdHJ1ZVxuICAgICAgdGhpcy5fcGFyZW50U2Nyb2xsZXIgPSBwYXJlbnRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gaXNJblNjcm9sbGFibGUgLSBwYXJlbnQgbm90IGV4aXN0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0sXG5cbiAgLy8gZGlzcGF0Y2ggYSBzcGVjaWZpZWQgZXZlbnQgb24gdGhpcy5ub2RlXG4gIC8vICAtIHR5cGU6IGV2ZW50IHR5cGVcbiAgLy8gIC0gZGF0YTogZXZlbnQgZGF0YVxuICAvLyAgLSBjb25maWc6IGV2ZW50IGNvbmZpZyBvYmplY3RcbiAgLy8gICAgIC0gYnViYmxlc1xuICAvLyAgICAgLSBjYW5jZWxhYmxlXG4gIGRpc3BhdGNoRXZlbnQgKHR5cGUsIGRhdGEsIGNvbmZpZykge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxuICAgIGV2ZW50LmluaXRFdmVudCh0eXBlLCBjb25maWcuYnViYmxlcyB8fCBmYWxzZSwgY29uZmlnLmNhbmNlbGFibGUgfHwgZmFsc2UpXG4gICAgIWRhdGEgJiYgKGRhdGEgPSB7fSlcbiAgICBldmVudC5kYXRhID0gZXh0ZW5kKHt9LCBkYXRhKVxuICAgIGV4dGVuZChldmVudCwgZGF0YSlcbiAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSxcblxuICBvbkFwcGVuZDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFNjcm9sbGVyKClcbiAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5ub2RlXG4gICAgICA6IHRoaXMuZ2V0Um9vdENvbnRhaW5lcigpXG4gICAgY29uc3QgY3RSZWN0ID0gcGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChoYXNJbnRlcnNlY3Rpb24ocmVjdCwgY3RSZWN0KSkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdhcHBlYXInLCB7IGRpcmVjdGlvbjogJycgfSlcbiAgICB9XG4gIH0sXG5cbiAgYWRkQXBwZW5kSGFuZGxlciAoY2IpIHtcbiAgICBsZXQgcHJlXG4gICAgaWYgKHRoaXMub25BcHBlbmQpIHtcbiAgICAgIHByZSA9IHRoaXMub25BcHBlbmQuYmluZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLm9uQXBwZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJlICYmIHByZS5jYWxsKHRoaXMpXG4gICAgICBjYiAmJiBjYi5jYWxsKHRoaXMpXG4gICAgfS5iaW5kKHRoaXMpXG4gIH0sXG5cbiAgLy8gY2hhbmdlIHNyYyB0byBpbWctc3JjIGZvciBsaWIuaW1nIHRvIGZpcmUgbGF6eWxvYWQgbGF0ZXIuXG4gIGVuYWJsZUxhenlsb2FkIChzcmMpIHtcbiAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICBtYWtlSW1hZ2VMYXp5KHRoaXMubm9kZSwgc3JjKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIHRoaXMubm9kZSBkb2VzIG5vdCBleGlzdC4nKVxuICAgIH1cbiAgfSxcblxuICAvLyBlbGVtZW50IGNhbiBiZSBib3RoIHdlZXggY29tcG9uZW50IGFuZCBkb20gZWxlbWVudC5cbiAgZmlyZUxhenlsb2FkIChlbGVtZW50KSB7XG4gICAgIWVsZW1lbnQgJiYgKGVsZW1lbnQgPSB0aGlzKVxuICAgIGZpcmVMYXp5bG9hZChlbGVtZW50KVxuICB9LFxuXG4gIGF0dHI6IHt9LCAvLyBhdHRyIHNldHRlcnNcblxuICBzdHlsZToge30sIC8vIHN0eWxlIHNldHRlcnNcblxuICAvLyBldmVudCBmdW5jc1xuICAvLyAgLSAxLiAndXBkYXRvcicgZm9yIHVwZGF0aW5nIGF0dHJzIG9yIHN0eWxlcyB3aXRoIG91dCB0cmlnZ2VyaW5nIG1lc3NhZ2VzLlxuICAvLyAgLSAyLiAnZXh0cmEnIGZvciBiaW5kaW5nIGV4dHJhIGRhdGEuXG4gIC8vICAtIDMuICdzZXR0ZXInIHNldCBhIHNwZWNpZmllZCBldmVudCBoYW5kbGVyLlxuICAvLyBmdW5jcyBzaG91bGQgYmUgZnVuY3Rpb25zIGxpa2UgdGhpczogKHRha2UgJ2NoYW5nZScgZXZlbnQgYXMgYSBleGFtcGxlKVxuICAvLyB7XG4gIC8vICAgY2hhbmdlOiB7XG4gIC8vICAgICB1cGRhdG9yICgpIHtcbiAgLy8gICAgICAgcmV0dXJuIHtcbiAgLy8gICAgICAgICBhdHRyczoge1xuICAvLyAgICAgICAgICAgY2hlY2tlZDogdGhpcy5jaGVja2VkXG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9LFxuICAvLyAgICAgZXh0cmEgKCkge1xuICAvLyAgICAgICByZXR1cm4ge1xuICAvLyAgICAgICAgIHZhbHVlOiB0aGlzLmNoZWNrZWRcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuICBldmVudDoge30sXG5cbiAgY2xlYXJBdHRyICgpIHtcbiAgfSxcblxuICBjbGVhclN0eWxlICgpIHtcbiAgICB0aGlzLm5vZGUuY3NzVGV4dCA9ICcnXG4gIH1cbn1cblxuLy8gZXh0ZW5kIG9wZXJhdGlvbnMuXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwgb3BlcmF0ZSlcblxuLy8gZXh0ZW5kIGF0dHIgYW5kIHN0eWxlIHNldHRlcnMgZnJvbSAncG9zaXRpb24nIGFuZCAnZmxleGJveCcuXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwgcG9zaXRpb24pXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZS5zdHlsZSwgZmxleGJveC5zdHlsZSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogQSBzaW1wbGUgdmlydHVhbCBkb20gaW1wbGVtZW50YXRpb25cbiAqL1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi9jb21wb25lbnRNYW5hZ2VyJ1xuXG5leHBvcnQgeyBDb21wb25lbnRNYW5hZ2VyIH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9kb20vaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBnZXRGaWx0ZXJzIH0gZnJvbSAnLi92YWx1ZUZpbHRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSAobm9kZVR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZVR5cGUgfHwgJ2RpdicpXG4gIHJldHVybiBub2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAoKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGNvbnN0IHBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgY29uc3QgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIGxldCBpc0ZsZXggPSBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLmluc3RhbmNlSWQgPSB0aGlzLmRhdGEuaW5zdGFuY2VJZFxuICAgICAgY2hpbGRyZW5baV0uc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgICAgIGNvbnN0IGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldKVxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICAgIGNoaWxkLnBhcmVudFJlZiA9IHBhcmVudFJlZlxuICAgICAgaWYgKCFpc0ZsZXhcbiAgICAgICAgJiYgY2hpbGQuZGF0YS5zdHlsZVxuICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlLmhhc093blByb3BlcnR5KCdmbGV4JylcbiAgICAgICkge1xuICAgICAgICBpc0ZsZXggPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChmcmFnbWVudClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKGRhdGEpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgY29uc3QgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gIGNvbnN0IGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGRhdGEpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHRoaXMuZGF0YS5jaGlsZHJlbiA9IFtkYXRhXVxuICB9XG4gIGVsc2Uge1xuICAgIGNoaWxkcmVuLnB1c2goZGF0YSlcbiAgfVxuICByZXR1cm4gY2hpbGRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEJlZm9yZSAoY2hpbGQsIGJlZm9yZSkge1xuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICBsZXQgaSA9IDBcbiAgbGV0IGxcbiAgbGV0IGlzQXBwZW5kID0gZmFsc2VcblxuICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCAhYmVmb3JlKSB7XG4gICAgaXNBcHBlbmQgPSB0cnVlXG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yIChsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ucmVmID09PSBiZWZvcmUuZGF0YS5yZWYpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IGwpIHtcbiAgICAgIGlzQXBwZW5kID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc0FwcGVuZCkge1xuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuZGF0YSlcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoYmVmb3JlLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLmZpeGVkUGxhY2Vob2xkZXIpXG4gICAgfVxuICAgIGVsc2UgaWYgKGJlZm9yZS5zdGlja3lQbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShjaGlsZC5ub2RlLCBiZWZvcmUuc3RpY2t5UGxhY2Vob2xkZXIpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShjaGlsZC5ub2RlLCBiZWZvcmUubm9kZSlcbiAgICB9XG4gICAgY2hpbGRyZW4uc3BsaWNlKGksIDAsIGNoaWxkLmRhdGEpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChjaGlsZCkge1xuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAvLyByZW1vdmUgZnJvbSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgbGV0IGkgPSAwXG4gIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgbGV0IGxcbiAgICBmb3IgKGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGNoaWxkLmRhdGEucmVmKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpIDwgbCkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG4gIC8vIHJlbW92ZSBmcm9tIGNvbXBvbmVudE1hcCByZWN1cnNpdmVseVxuICBjb21wb25lbnRNYW5hZ2VyLnJlbW92ZUNvbXBvbmVudChjaGlsZC5kYXRhLnJlZilcbiAgY2hpbGQudW5zZXRQb3NpdGlvbigpXG4gIGNoaWxkLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZC5ub2RlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQXR0cnMgKGF0dHJzKSB7XG4gIC8vIE5vdGXvvJphdHRyIG11c3QgYmUgaW5qZWN0ZWQgaW50byB0aGUgZG9tIGVsZW1lbnQgYmVjYXVzZVxuICAvLyBpdCB3aWxsIGJlIGFjY2Vzc2VkIGZyb20gdGhlIG91dHNpZGUgZGV2ZWxvcGVyIGJ5IGV2ZW50LnRhcmdldC5hdHRyLlxuICBpZiAoIXRoaXMubm9kZS5hdHRyKSB7XG4gICAgdGhpcy5ub2RlLmF0dHIgPSB7fVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhdHRyc1trZXldXG4gICAgY29uc3QgYXR0clNldHRlciA9IHRoaXMuYXR0cltrZXldXG4gICAgaWYgKHR5cGVvZiBhdHRyU2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhdHRyU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMubm9kZVtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgICB0aGlzLm5vZGUuYXR0cltrZXldID0gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChzdHlsZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgIGxldCB2YWx1ZSA9IHN0eWxlW2tleV1cbiAgICBjb25zdCBzdHlsZVNldHRlciA9IHRoaXMuc3R5bGVba2V5XVxuICAgIGlmICh0eXBlb2Ygc3R5bGVTZXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0eWxlU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBnZXRGaWx0ZXJzKGtleSxcbiAgICAgIHsgc2NhbGU6IHRoaXMuZGF0YS5zY2FsZSB9KVt0eXBlb2YgdmFsdWVdXG4gICAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGVba2V5XSA9IHZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRFdmVudHMgKGV2dHMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3Qgd2VleEluc3RhbmNlID0gdGhpcy5nZXRXZWV4SW5zdGFuY2UoKVxuICBldnRzLm1hcChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgY29uc3QgZnVuYyA9IHNlbGYuZXZlbnRbZXZ0XSB8fCB7fVxuICAgIGNvbnN0IHNldHRlciA9IGZ1bmMuc2V0dGVyXG4gICAgaWYgKHNldHRlcikge1xuICAgICAgc2VsZi5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBzZXR0ZXIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyID0gd2VleEluc3RhbmNlLnNlbmRlclxuICAgIGNvbnN0IGxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGRvIHN0b3AgYnViYmxpbmcuXG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0LCBvdGhlcndpc2UgdGhlIHRvdWNoc3RhcnRcbiAgICAgIC8vIGV2ZW50IHdpbGwgbm8gbG9uZ2VyIHRyaWdnZXIgYSBjbGljayBldmVudFxuICAgICAgaWYgKGUuX2FscmVhZHlUcmlnZ2VyZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlLl9hbHJlYWR5VHJpZ2dlcmVkID0gdHJ1ZVxuICAgICAgY29uc3QgZXZlbnQgPSBleHRlbmQoe30sIGUpXG4gICAgICBldmVudC50YXJnZXQgPSBzZWxmLmRhdGFcbiAgICAgIHNlbmRlci5maXJlRXZlbnQoc2VsZi5kYXRhLnJlZiwgZXZ0LCB7XG4gICAgICAgIGV4dHJhOiBmdW5jLmV4dHJhICYmIGZ1bmMuZXh0cmEuYmluZChzZWxmKSxcbiAgICAgICAgdXBkYXRvcjogZnVuYy51cGRhdG9yICYmIGZ1bmMudXBkYXRvci5iaW5kKHNlbGYpXG4gICAgICB9LCBldmVudClcbiAgICB9XG4gICAgc2VsZi5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UsIGZhbHNlKVxuICAgIGxldCBsaXN0ZW5lcnMgPSBzZWxmLl9saXN0ZW5lcnNcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gc2VsZi5fbGlzdGVuZXJzID0ge31cbiAgICAgIHNlbGYubm9kZS5fbGlzdGVuZXJzID0ge31cbiAgICB9XG4gICAgbGlzdGVuZXJzW2V2dF0gPSBsaXN0ZW5lclxuICAgIHNlbGYubm9kZS5fbGlzdGVuZXJzW2V2dF0gPSBsaXN0ZW5lclxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5iaW5kRXZlbnRzIChldnRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGV2dHMubWFwKGZ1bmN0aW9uIChldnQpIHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVyc1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgc2VsZi5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcilcbiAgICAgIHNlbGYuX2xpc3RlbmVyc1tldnRdID0gbnVsbFxuICAgICAgc2VsZi5ub2RlLl9saXN0ZW5lcnNbZXZ0XSA9IG51bGxcbiAgICB9XG4gIH0pXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvb3BlcmF0ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBOT1RfUFhfTlVNQkVSX1BST1BFUlRJRVMgPSBbJ2ZsZXgnLCAnb3BhY2l0eScsICd6SW5kZXgnLCAnZm9udFdlaWdodCddXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJTdHlsZXMgKHN0eWxlcywgY29uZmlnKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV1cbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLmdldEZpbHRlcnMoa2V5LCBjb25maWcpW3R5cGVvZiB2YWx1ZV1cbiAgICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3R5bGVzW2tleV0gPSBwYXJzZXIodmFsdWUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJzIChrZXksIGNvbmZpZykge1xuICBpZiAoTk9UX1BYX05VTUJFUl9QUk9QRVJUSUVTLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICByZXR1cm4ge1xuICAgIG51bWJlcjogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAqIGNvbmZpZy5zY2FsZSArICdweCdcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgLy8gc3RyaW5nIG9mIGEgcHVyZSBudW1iZXIgb3IgYSBudW1iZXIgc3VmZml4ZWQgd2l0aCBhICdweCcgdW5pdFxuICAgICAgaWYgKHZhbC5tYXRjaCgvXlxcLT9cXGQqXFwuP1xcZCsoPzpweCk/JC8pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCkgKiBjb25maWcuc2NhbGUgKyAncHgnXG4gICAgICB9XG4gICAgICBpZiAoa2V5Lm1hdGNoKC90cmFuc2Zvcm0vKSAmJiB2YWwubWF0Y2goL3RyYW5zbGF0ZS8pKSB7XG4gICAgICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFxkKlxcLj9cXGQrcHgvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnNlRmxvYXQobWF0Y2gpICogY29uZmlnLnNjYWxlKSArICdweCdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC92YWx1ZUZpbHRlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgU3RpY2t5IGZyb20gJy4vc3RpY2t5J1xuXG4vLyBTZXQgcG9zaXRvbiB0byBmaXhlZCwgd2l0aCBhIHBsYWNlaG9sZGVyIGlmIGl0J3MgaW4gYVxuLy8gc2Nyb2xsYWJsZSBjb21wb25lbnQuXG5leHBvcnQgZnVuY3Rpb24gc2V0Rml4ZWQgKCkge1xuICAvLyBkZWxheSBwcm9jZXNzaW5nIGluIGNhc2UgdGhlIG5vZGUgaXMgbm90IGFwcGVuZGVkIHlldC5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgIGlmICghdGhpcy5pc0luU2Nyb2xsYWJsZSgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudE5vZGVcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAvLyBGb3IgdGhlIGVsZW1lbnRzIHdobyBhcmUgZml4ZWQ6IHRoaXMgZml4ZWRQbGFjZWhvbGRlclxuICAgICAgLy8gc2hvdWQgYmUgaW5zZXJ0ZWQsIGFuZCB0aGUgZml4ZWQgZWxlbWVudCBpdHNlbGYgc2hvdWxkXG4gICAgICAvLyBiZSBtb3ZlZCB0byB0aGUgcm9vdCBjb250YWluZXIuXG4gICAgICB0aGlzLmZpeGVkUGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgdGhpcy5maXhlZFBsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3dlZXgtZml4ZWQtcGxhY2Vob2xkZXInKVxuICAgICAgdGhpcy5maXhlZFBsYWNlaG9sZGVyLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICdkaXNwbGF5Om5vbmU7JyxcbiAgICAgICAgJ3dpZHRoOjBweDsnLFxuICAgICAgICAnaGVpZ2h0OjBweDsnXG4gICAgICBdLmpvaW4oJycpXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZml4ZWRQbGFjZWhvbGRlciwgdGhpcy5ub2RlKVxuICAgICAgdGhpcy5nZXRSb290Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIH1cbiAgfS5iaW5kKHRoaXMpLCAwKVxufVxuXG4vLyB1bnNldCBhIGZpeGVkIG5vZGUgdG8gdGhlIHBlY2lmaWVkICdwb3NpdGlvbicgb3IgJ3JlbGF0aXZlJyBieSBkZWZhdWx0LlxuZXhwb3J0IGZ1bmN0aW9uIHVuc2V0Rml4ZWQgKHBvc2l0aW9uKSB7XG4gIC8vIEZvciB0aGUgZWxlbWVudHMgd2hvIGFyZSBmaXhlZCBlbGVtZW50cyBiZWZvcmUsIG5vd1xuICAvLyBhcmUgbm90IGZpeGVkOiB0aGUgZml4ZWRQbGFjZWhvbGRlciBoYXMgdG8gYmUgcmVwbGFjZWRcbiAgLy8gYnkgdGhpcyBlbGVtZW50LlxuICBwb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb24gKyAnJyA6ICdyZWxhdGl2ZSdcbiAgaWYgKHRoaXMuZml4ZWRQbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZml4ZWRQbGFjZWhvbGRlci5wYXJlbnROb2RlXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIHRoaXMuZml4ZWRQbGFjZWhvbGRlcilcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5maXhlZFBsYWNlaG9sZGVyKVxuICAgIHRoaXMuZml4ZWRQbGFjZWhvbGRlciA9IG51bGxcbiAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvblxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdGlja3kgKCkge1xuICB0aGlzLm5vZGUuc3R5bGUuekluZGV4ID0gMTAwXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RpY2t5ID0gbmV3IFN0aWNreSh0aGlzKVxuICB9LmJpbmQodGhpcyksIDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNldFN0aWNreSAoKSB7XG4gIGlmICh0aGlzLnN0aWNreSkge1xuICAgIHRoaXMuc3RpY2t5LmRlc3Ryb3koKVxuICAgIHRoaXMuc3RpY2t5ID0gbnVsbFxuICB9XG59XG5cbi8vIHVzYWxseSB1c2VkIHRvIHVuc2V0IHN0aWNreSBhbmQgZml4ZWRcbmV4cG9ydCBmdW5jdGlvbiB1bnNldFBvc2l0aW9uIChwb3NpdGlvbikge1xuICB0aGlzLnN0eWxlLnBvc2l0aW9uLmNhbGwodGhpcywgcG9zaXRpb24pXG59XG5cbmV4cG9ydCBjb25zdCBzdHlsZSA9IHtcbiAgcG9zaXRpb24gKHZhbHVlKSB7XG4gICAgLy8gVGhpcyBpcyBhIHBlYWNlIG9mIGhhY2tpbmcgdG8gZml4IHRoZSBwcm9ibGVtIGFib3V0XG4gICAgLy8gbWl4aW5nIGZpeGVkIGFuZCB0cmFuc2Zvcm0uIFNlZSAnaHR0cDovL3N0YWNrb3ZlcmZsb1xuICAgIC8vIHcuY29tL3F1ZXN0aW9ucy8xNTE5NDMxMy93ZWJraXQtY3NzLXRyYW5zZm9ybTNkLXBvc2lcbiAgICAvLyB0aW9uLWZpeGVkLWlzc3VlJyBmb3IgbW9yZSBpbmZvLlxuICAgIHZhbHVlICE9PSAnZml4ZWQnICYmIHRoaXMudW5zZXRGaXhlZCgpXG4gICAgdmFsdWUgIT09ICdzdGlja3knICYmIHRoaXMudW5zZXRTdGlja3koKVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Rml4ZWQoKVxuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICdzdGlja3knKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTdGlja3koKVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSB2YWx1ZVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvcG9zaXRpb24uanNcbiAqKi8iLCJpbXBvcnQgeyB0aHJvdHRsZSwgZGV0ZWN0U3RpY2t5IH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5cbmNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudFxuY29uc3QgaXNGaXJlZm94ID0gISF1YS5tYXRjaCgvRmlyZWZveC9pKVxuY29uc3QgaXNJRU1vYmlsZSA9ICEhdWEubWF0Y2goL0lFTW9iaWxlL2kpXG5jb25zdCBjc3NQcmVmaXggPSBpc0ZpcmVmb3ggPyAnLW1vei0nIDogaXNJRU1vYmlsZSA/ICctbXMtJyA6ICctd2Via2l0LSdcbmNvbnN0IHN0eWxlUHJlZml4ID0gaXNGaXJlZm94ID8gJ01veicgOiBpc0lFTW9iaWxlID8gJ21zJyA6ICd3ZWJraXQnXG5cbmNvbnN0IHN1cHBvcnRTdGlja3kgPSBkZXRlY3RTdGlja3koKVxuXG5mdW5jdGlvbiBjcmVhdGVTdGlja3lMYXllciAoc3RpY2t5KSB7XG4gIGNvbnN0IHBhcmVudCA9IHN0aWNreS5wYXJlbnRFbGVtZW50XG4gIGxldCBzbCA9IHBhcmVudC5fc3RpY2t5TGF5ZXJcbiAgaWYgKHNsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzbC5jbGFzc0xpc3QuYWRkKCd3ZWV4LXN0aWNreS1sYXllcicpXG4gIHNsLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgJ3Bvc2l0aW9uOmZpeGVkOycsXG4gICAgYHRvcDoke3BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3B9cHg7YCxcbiAgICAnYm94LXNpemluZzpib3JkZXItYm94OycsXG4gICAgJ3dpZHRoOjEwMCU7J1xuICBdLmpvaW4oJycpXG4gIHBhcmVudC5fc3RpY2t5TGF5ZXIgPSBzbFxuICBwYXJlbnQuYXBwZW5kQ2hpbGQoc2wpXG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lTdGlja3lMYXllciAoc3RpY2t5KSB7XG4gIGNvbnN0IHBhcmVudCA9IHN0aWNreS5wYXJlbnRFbGVtZW50XG4gIGNvbnN0IHNsID0gcGFyZW50Ll9zdGlja3lMYXllclxuICBpZiAoIXNsIHx8IHNsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBzbCAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQoc2wpXG4gIHBhcmVudC5fc3RpY2t5TGF5ZXIgPSBudWxsXG59XG5cbmZ1bmN0aW9uIGJpbmRQYXJlbnQgKHN0aWNreSkge1xuICBpZiAoIXN0aWNreSBpbnN0YW5jZW9mIFN0aWNreSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNjcm9sbGVyID0gc3RpY2t5LmNvbXBvbmVudC5nZXRQYXJlbnRTY3JvbGxlcigpXG4gIGxldCBwdFxuICBpZiAoc2Nyb2xsZXIpIHtcbiAgICBwdCA9IHN0aWNreS5wYXJlbnQgPSBzY3JvbGxlclxuICAgIHN0aWNreS5wYXJlbnRFbGVtZW50ID0gcHQubm9kZVxuICB9XG4gIGVsc2Uge1xuICAgIHB0ID0gc3RpY2t5LnBhcmVudCA9IHN0aWNreS5jb21wb25lbnQuZ2V0Um9vdENvbnRhaW5lcigpXG4gICAgc3RpY2t5LnBhcmVudEVsZW1lbnQgPSBwdFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFN0aWNreSAoc3RpY2t5KSB7XG4gIGNvbnN0IGNvbXAgPSBzdGlja3kuY29tcG9uZW50XG4gIGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIgPSBzdGlja3kuZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgY29tcC5zdGlja3lQbGFjZWhvbGRlci5jbGFzc0xpc3QuYWRkKCd3ZWV4LXN0aWNreS1wbGFjZWhvbGRlcicpXG4gIHN0aWNreS5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3dlZXgtc3RpY2t5JylcbiAgc3RpY2t5LnByZU1hcmdpblRvcCA9IHN0aWNreS5lbGVtZW50LnN0eWxlLm1hcmdpblRvcFxuICBzdGlja3kuZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSBzdGlja3kudG9wICsgJ3B4J1xuICBzdGlja3kuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICBjb21wLnN0aWNreVBsYWNlaG9sZGVyLCBzdGlja3kuZWxlbWVudClcbiAgY29uc3QgcHQgPSBzdGlja3kucGFyZW50RWxlbWVudFxuICAhcHQuc3RpY2t5cyAmJiAocHQuc3RpY2t5cyA9IFtdKVxuICBwdC5zdGlja3lzLnB1c2goc3RpY2t5KVxuICBjcmVhdGVTdGlja3lMYXllcihzdGlja3kpXG4gIHB0Ll9zdGlja3lMYXllci5hcHBlbmRDaGlsZChzdGlja3kuZWxlbWVudClcbn1cblxuLyoqXG4gKiB1bnNldFN0aWNreVxuICogQHBhcmFtICB7U3RpY2t5fSBzdGlja3kgOiBhIHN0aWNreSBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gcG9zaXRpb24gOiBwb3NpdGlvbiByZXBsYWNpbmcgd2l0aCAoZGVmYXVsdDogJ3JlbGF0aXZlJykuXG4gKi9cbmZ1bmN0aW9uIHVuc2V0U3RpY2t5IChzdGlja3ksIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGNvbXAgPSBzdGlja3kuY29tcG9uZW50XG4gIGNvbnN0IGVsZW1lbnQgPSBzdGlja3kuZWxlbWVudFxuICBwb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb24gKyAnJyA6IHN0aWNreS5wcmVQb3NpdGlvblxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSBzdGlja3kucHJlTWFyZ2luVG9wIHx8ICcnXG4gIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnd2VleC1zdGlja3knKVxuICBpZiAoY29tcC5zdGlja3lQbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIucGFyZW50Tm9kZVxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RpY2t5LmVsZW1lbnQsIGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIpXG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIpXG4gICAgY29tcC5zdGlja3lQbGFjZWhvbGRlciA9IG51bGxcbiAgfVxuICBjb25zdCBzdGtzID0gc3RpY2t5LnBhcmVudEVsZW1lbnQuc3RpY2t5c1xuICBjb25zdCBpZHggPSBzdGtzLmluZGV4T2Yoc3RpY2t5KVxuICBzdGtzLnNwbGljZShpZHgsIDEpXG4gIGRlc3Ryb3lTdGlja3lMYXllcihzdGlja3kpXG59XG5cbi8qKlxuICogQGNsYXNzICBTdGlja3lcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQ6IGEgd2VleCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjb25maWcgb3B0aW9ucy5cbiAqICAtIG9wdGlvbnMuY29tcG9uZW50IChvcHRpb25hbCkgaW5jYXNlIHRoZSBjb21wb25lbnQgcGFyYW0gaXMgbWlzc2luZywgaXQgY2FuXG4gKiAgICBiZSBzcGVjaWZpZWQgaW4gdGhpcyBvcHRpb25zLlxuICogIC0gb3B0aW9ucy53aXRoaW5QYXJlbnQ9ZmFsc2XvvIhvcHRpb25hbO+8jG9ubHkgZm9yIEFuZHJvaWTvvIl0aGUgc3RpY2t5IGVmZmVjdCBpc1xuICogICAgbGltaXRlZCB3aXRoaW4gdGhlIHBhcmVudCBlbGVtZW50IG9ubHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0aWNreSAoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50XG4gIHRoaXMuZWxlbWVudCA9IGNvbXBvbmVudC5ub2RlXG4gIHRoaXMucHJlUG9zaXRpb24gPSB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb25cbiAgdGhpcy53aXRoaW5QYXJlbnQgPSBvcHRpb25zLndpdGhpblBhcmVudCB8fCBmYWxzZVxuICB0aGlzLnBhcmVudCA9IG51bGxcbiAgdGhpcy5pbml0KClcbn1cblxuU3RpY2t5LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogU3RpY2t5LFxuXG4gIGluaXQgKCkge1xuICAgIGNvbnN0IGVsZW1lbnRTdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZVxuICAgIGVsZW1lbnRTdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGVaKDApJyAvLyBmaXggZmxpY2tlcmluZ1xuICAgIGVsZW1lbnRTdHlsZVsndHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlWigwKSdcbiAgICBiaW5kUGFyZW50KHRoaXMpXG4gICAgaWYgKHN1cHBvcnRTdGlja3kpIHtcbiAgICAgIGVsZW1lbnRTdHlsZS5wb3NpdGlvbiA9IGNzc1ByZWZpeCArICdzdGlja3knXG4gICAgICBlbGVtZW50U3R5bGUucG9zaXRpb24gPSAnc3RpY2t5J1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NpbXVsYXRlU3RpY2t5KClcbiAgICAgIHRoaXMuX2JpbmRSZXNpemUoKVxuICAgIH1cbiAgfSxcblxuICBfYmluZFJlc2l6ZSAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBpc0FuZHJvaWQgPSAoL2FuZHJvaWQvZ2kpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pXG4gICAgY29uc3QgcmVzaXplRXZlbnQgPSBzZWxmLl9yZXNpemVFdmVudCA9ICdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3dcbiAgICAgID8gJ29yaWVudGF0aW9uY2hhbmdlJ1xuICAgICAgOiAncmVzaXplJ1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSBzZWxmLl9yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucmVmcmVzaCgpXG4gICAgICB9LCBpc0FuZHJvaWQgPyAyMDAgOiAwKVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihyZXNpemVFdmVudCwgcmVzaXplSGFuZGxlciwgZmFsc2UpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggYSBpbnN0YW5jZS5cbiAgICogSWYgd2l0aFBhcmVudCBpcyB0cnVlIGFuZCB0aGUgcGFyZW50JyBoZWlnaHQgYWx0ZXJlZCwgdGhpc1xuICAgKiBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICovXG4gIHJlZnJlc2ggKCkge1xuICAgIGlmIChzdXBwb3J0U3RpY2t5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZGV0YWNoKClcbiAgICB0aGlzLl9zaW11bGF0ZVN0aWNreSgpXG4gIH0sXG5cbiAgX3NpbXVsYXRlU3RpY2t5ICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IGlzSW5TY3JvbGxhYmxlID0gdGhpcy5pc0luU2Nyb2xsYWJsZSgpXG4gICAgLy8gdGhlIGluaXRpYWwgeSBvZmZzZXQuXG4gICAgdGhpcy5vZmZzZXQgPSAoaXNJblNjcm9sbGFibGVcbiAgICAgID8gdGhpcy5nZXRQYXJlbnRTY3JvbGxlcigpLm9mZnNldFxuICAgICAgOiB3aW5kb3cucGFnZVlPZmZzZXQpXG4gICAgICB8fCAwXG4gICAgY29uc3QgcmVjdFRvcCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICBsZXQgd3JhcHBlclRvcCA9IDBcbiAgICBpZiAoaXNJblNjcm9sbGFibGUpIHtcbiAgICAgIHdyYXBwZXJUb3AgPSB0aGlzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgfVxuICAgIGNvbnN0IHdpdGhpblBhcmVudCA9IHRoaXMud2l0aGluUGFyZW50XG4gICAgY29uc3QgdGhyZXNob2xkQmFzZSA9IHJlY3RUb3AgLSB3cmFwcGVyVG9wICsgdGhpcy5vZmZzZXRcbiAgICAvKipcbiAgICAgKiBjdXJTdGF0ZTpcbiAgICAgKiAgIDEgLSBub3JtYWxcbiAgICAgKiAgIDIgLSBzdGlja3lcbiAgICAgKiAgIDMgLSBleGNlZWQgcGFyZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmN1clN0YXRlID0gMVxuICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxIYW5kbGVyID0gdGhyb3R0bGUoZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNvbnN0IHNsID0gc2VsZi5wYXJlbnRFbGVtZW50Ll9zdGlja3lMYXllclxuICAgICAgY29uc3QgbGF5ZXJIZWlnaHQgPSBzbCA/IHNsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA6IDBcbiAgICAgIGNvbnN0IHNlbGZIZWlnaHQgPSBzZWxmLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICBjb25zdCBzZWxmT2Zmc2V0ID0gc2VsZi5jdXJTdGF0ZSA9PT0gMiA/IHNlbGZIZWlnaHQgOiAwXG4gICAgICBjb25zdCB0aHJlc2hvbGRUb3AgPSB0aHJlc2hvbGRCYXNlIC0gbGF5ZXJIZWlnaHQgKyBzZWxmT2Zmc2V0XG4gICAgICBjb25zdCB5cG9zID0gc2VsZi5pc0luU2Nyb2xsYWJsZSgpID8gZS5vZmZzZXQgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIHNlbGYub2Zmc2V0ID0geXBvc1xuICAgICAgaWYgKHlwb3MgPCB0aHJlc2hvbGRUb3ApIHtcbiAgICAgICAgaWYgKHNlbGYuY3VyU3RhdGUgIT09IDEpIHtcbiAgICAgICAgICB1bnNldFN0aWNreShzZWxmKVxuICAgICAgICAgIHNlbGYuY3VyU3RhdGUgPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCghd2l0aGluUGFyZW50ICYmIHlwb3MgPj0gdGhyZXNob2xkVG9wKSB8fFxuICAgICAgICAod2l0aGluUGFyZW50ICYmIHlwb3MgPj0gdGhyZXNob2xkVG9wLyogJiYgeXBvcyA8IHRocmVzaG9sZEJvdHRvbSovKSkge1xuICAgICAgICBpZiAoc2VsZi5jdXJTdGF0ZSAhPT0gMikge1xuICAgICAgICAgIHNldFN0aWNreShzZWxmKVxuICAgICAgICAgIHNlbGYuY3VyU3RhdGUgPSAyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMDApXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIsIGZhbHNlKVxuXG4gICAgLy8gdGFrZSBlZmZlY3Qgb25jZSBpbml0ZWQgYWZ0ZXIgYSBkZXN0cm95bWVudC5cbiAgICBpZiAodGhpcy5vZmZzZXQgPj0gdGhyZXNob2xkQmFzZSkge1xuICAgICAgY29uc3QgZHVtbXlFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICAgIGR1bW15RXZlbnQuaW5pdEV2ZW50KCdzY3JvbGwnLCB0cnVlLCB0cnVlKVxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZHVtbXlFdmVudClcbiAgICB9XG4gIH0sXG5cbiAgX2RldGFjaCAocG9zaXRpb24pIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb24gKyAnJyA6ICdyZWxhdGl2ZSdcbiAgICBpZiAoIXN1cHBvcnRTdGlja3kpIHtcbiAgICAgIGlmICh0aGlzLmN1clN0YXRlID09PSAyKSB7XG4gICAgICAgIHVuc2V0U3RpY2t5KHRoaXMpXG4gICAgICB9XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2Nyb2xsSGFuZGxlciwgZmFsc2UpXG4gICAgfVxuICB9LFxuXG4gIGlzSW5TY3JvbGxhYmxlICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5TY3JvbGxhYmxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IHRoaXMuY29tcG9uZW50LmlzSW5TY3JvbGxhYmxlKClcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudFJlZiBpcyBub3QgaW4gY29tcG9uZW50TWFuYWdlcidzIGNvbXBvbmVudE1hcCB5ZXQsIHNvXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCB0byBnZXQgdGhlIHBhcmVudCBhbmQgdGVzdCBpZiBpdCdzIHNjcm9sbGFibGUuXG4gICAgICAgIC8vIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGluIHRoZSBjYXNlIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAvLyBjb21wb25lbnQncyAnYXBwZW5kJyBhdHRyaWJ1dGUgaXMgc2V0IHRvICd0cmVlJy5cbiAgICAgICAgY29uc29sZS5lcnJvcignaXNJblNjcm9sbGFibGUgaXMgbm90IHlldCBhdmFpbGFibGUgdG8gY2FsbCcsIGVycilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzSW5TY3JvbGxhYmxlXG4gIH0sXG5cbiAgZ2V0UGFyZW50U2Nyb2xsZXIgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRQYXJlbnRTY3JvbGxlcigpXG4gIH0sXG5cbiAgZGVzdHJveSAocG9zaXRpb24pIHtcbiAgICB0aGlzLl9kZXRhY2gocG9zaXRpb24pXG4gICAgY29uc3QgZWxlbWVudFN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlXG4gICAgZWxlbWVudFN0eWxlLnJlbW92ZVByb3BlcnR5KGNzc1ByZWZpeCArICd0cmFuc2Zvcm0nKVxuICAgIGVsZW1lbnRTdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNmb3JtJylcbiAgICBpZiAoIXN1cHBvcnRTdGlja3kpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3Jlc2l6ZUV2ZW50LCB0aGlzLl9yZXNpemVIYW5kbGVyLCBmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9zdGlja3kuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYm94QWxpZ25NYXAgPSB7XG4gIHN0cmV0Y2g6ICdzdHJldGNoJyxcbiAgJ2ZsZXgtc3RhcnQnOiAnc3RhcnQnLFxuICAnZmxleC1lbmQnOiAnZW5kJyxcbiAgY2VudGVyOiAnY2VudGVyJ1xufVxuXG5jb25zdCBib3hPcmllbnRNYXAgPSB7XG4gIHJvdzogJ2hvcml6b250YWwnLFxuICBjb2x1bW46ICd2ZXJ0aWNhbCdcbn1cblxuY29uc3QgYm94UGFja01hcCA9IHtcbiAgJ2ZsZXgtc3RhcnQnOiAnc3RhcnQnLFxuICAnZmxleC1lbmQnOiAnZW5kJyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgJ3NwYWNlLWJldHdlZW4nOiAnanVzdGlmeScsXG4gICdzcGFjZS1hcm91bmQnOiAnanVzdGlmeScgLy8gSnVzdCBzYW1lIGFzIGBzcGFjZS1iZXR3ZWVuYFxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0eWxlOiB7XG4gICAgZmxleCAodmFsdWUpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRCb3hGbGV4ID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRGbGV4ID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5mbGV4ID0gdmFsdWVcbiAgICB9LFxuXG4gICAgYWxpZ25JdGVtcyAodmFsdWUpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRCb3hBbGlnbiA9IGJveEFsaWduTWFwW3ZhbHVlXVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEFsaWduSXRlbXMgPSB2YWx1ZVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLmFsaWduSXRlbXMgPSB2YWx1ZVxuICAgIH0sXG5cbiAgICBhbGlnblNlbGYgKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0QWxpZ25TZWxmID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5hbGlnblNlbGYgPSB2YWx1ZVxuICAgIH0sXG5cbiAgICBmbGV4RGlyZWN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEJveE9yaWVudCA9IGJveE9yaWVudE1hcFt2YWx1ZV1cbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRGbGV4RGlyZWN0aW9uID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gdmFsdWVcbiAgICB9LFxuXG4gICAganVzdGlmeUNvbnRlbnQgKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0Qm94UGFjayA9IGJveFBhY2tNYXBbdmFsdWVdXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0SnVzdGlmeUNvbnRlbnQgPSB2YWx1ZVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9mbGV4Ym94LmpzXG4gKiovIiwiLyogZ2xvYmFsIGxpYiwgSFRNTEVsZW1lbnQgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJ2xhenlpbWcnKVxuXG5sZXQgbGF6eWxvYWRUaW1lclxuXG4vLyBmaXJlIGxhenlpbWcgb24gaW1hZ2VzLlxuZnVuY3Rpb24gZmlyZSAoKSB7XG4gIGxpYi5pbWcuZmlyZSgpXG59XG5cbi8vIHdlIGRvbid0IGtub3cgd2hlbiBhbGwgaW1hZ2VzIGFyZSBhcHBlbmRlZFxuLy8ganVzdCB1c2Ugc2V0VGltZW91dCB0byBkbyBkZWxheSBsYXp5bG9hZFxuLy9cbi8vIC0tIGFjdHVhbGx5IGV2ZXJ5dGltZSB3ZSBhZGQgYSBlbGVtZW50IG9yIHVwZGF0ZSBzdHlsZXMsXG4vLyB0aGUgY29tcG9uZW50IG1hbmFnZXIgd2lsbCBjYWxsIHN0YXJ0SWZOZWVkIHRvIGZpcmVcbi8vIGxhenlsb2FkIG9uY2UgYWdhaW4gaW4gdGhlIGhhbmRsZUFwcGVuZCBmdW5jdGlvbi4gc28gdGhlcmVcbi8vIGlzIG5vIHdheSB0aGF0IGFueSBpbWFnZSBlbGVtZW50IGNhbiBtaXNzIGl0LiBTZWUgc291cmNlXG4vLyBjb2RlIGluIGNvbXBvbmVudE1hbmdhZ2VyLmpzLlxuXG4vLyBjb21wb25lbnQgaXMgbm90IGEgZG9tIGVsZW1lbnQgYnV0IGEgd2VleCBjb21wb25lbnQuXG5mdW5jdGlvbiBzdGFydElmTmVlZGVkIChjb21wb25lbnQpIHtcbiAgaWYgKGNvbXBvbmVudC5kYXRhLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICBpZiAoIWxhenlsb2FkVGltZXIpIHtcbiAgICAgIGxhenlsb2FkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmlyZSgpXG4gICAgICAgIGNsZWFyVGltZW91dChsYXp5bG9hZFRpbWVyKVxuICAgICAgICBsYXp5bG9hZFRpbWVyID0gbnVsbFxuICAgICAgfSwgMTYpXG4gICAgfVxuICB9XG59XG5cbi8vIGVsZW1lbnRTY29wZSBpcyBhIGRvbSBlbGVtZW50LlxuZnVuY3Rpb24gbG9hZElmTmVlZGVkIChlbGVtZW50U2NvcGUpIHtcbiAgY29uc3Qgbm90UHJlUHJvY2Vzc2VkID0gZWxlbWVudFNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbWctc3JjXScpXG4gIC8vIGltYWdlIGVsZW1lbnRzIHdoaWNoIGhhdmUgYXR0cmlidXRlICdpLWxhenktc3JjJyB3ZXJlIGVsZW1lbnRzXG4gIC8vIHRoYXQgaGFkIGJlZW4gcHJlcHJvY2Vzc2VkIGJ5IGxpYi1pbWctY29yZSwgYnV0IG5vdCBsb2FkZWQgeWV0LCBhbmRcbiAgLy8gbXVzdCBiZSBsb2FkZWQgd2hlbiAnYXBwZWFyJyBldmVudHMgd2VyZSBmaXJlZC4gSXQgdHVybnMgb3V0IHRoZVxuICAvLyAnYXBwZWFyJyBldmVudCB3YXMgbm90IGZpcmVkIGNvcnJlY3RseSBpbiB0aGUgY3NzLXRyYW5zbGF0ZS10cmFuc2l0aW9uXG4gIC8vIHNpdHVhdGlvbiwgc28gJ2ktbGF6eS1zcmMnIG11c3QgYmUgY2hlY2tlZCBhbmQgbGF6eWxvYWQgbXVzdCBiZVxuICAvLyBmaXJlZCBtYW51YWxseS5cbiAgY29uc3QgcHJlUHJvY2Vzc2VkID0gZWxlbWVudFNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpLWxhenktc3JjXScpXG4gIGlmIChub3RQcmVQcm9jZXNzZWQubGVuZ3RoID4gMCB8fCBwcmVQcm9jZXNzZWQubGVuZ3RoID4gMCkge1xuICAgIGZpcmUoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW1hZ2VMYXp5IChpbWFnZSwgc3JjKSB7XG4gIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpXG4gIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJylcbiAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdpbWctc3JjJywgc3JjKVxuICBmaXJlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcmVMYXp5bG9hZCAoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIGxvYWRJZk5lZWRlZChjb21wb25lbnQpXG4gIH1cbiAgZWxzZSB7XG4gICAgc3RhcnRJZk5lZWRlZChjb21wb25lbnQpXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L2xhenlsb2FkLmpzXG4gKiovIiwiLypcbiAgICBsaWItaW1nLWFkcHRlciBcbiAgICBBdXRob3I6IGtvbmdzaGkud2xAYWxpYmFiYS1pbmMuY29tIFxuICAgIERhdGU6ICAgRGVjLDIwMTVcbiovXG47XG5cbihmdW5jdGlvbiAod2luLCBsaWIpIHtcbiAgICByZXF1aXJlKCdhcHBlYXJqcycpO1xuXG4gICAgdmFyIGFkYXB0ZXIgPSB7fTtcbiAgICB2YXIgYXBwZWFySW5zdGFuY2U7XG4gICAgdmFyIHJ1bnRpbWVGbGFncyA9IHt9O1xuXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgJ2RhdGFTcmMnOiAnaW1nLXNyYycsIC8v5oyH5a6a5Zu+54mH5Zyw5Z2A55qEYXR0cmlidXRl5ZCNLCDlhbzlgZpsYXp5LWNsYXNz55qE5L2c55SoXG4gICAgICAgICdsYXp5SGVpZ2h0JzogMCwgLy/ku6XmraTpq5jluqbmj5DliY3op6blj5Hmh5LliqDovb1cbiAgICAgICAgJ2xhenlXaWR0aCc6IDAgLy/ku6XmraTlrr3luqbmj5DliY3op6blj5Hmh5LliqDovb1cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBleHRlbmRTdHJpY3QobWFpbiwgc3ViKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBtYWluKSB7XG4gICAgICAgICAgICBpZiAobWFpbi5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJldFtrXSA9IHN1Yi5oYXNPd25Qcm9wZXJ0eShrKSA/IHN1YltrXSA6IG1haW5ba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVNyYyhpdGVtLCBwcm9jZXNzZWRTcmMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRTcmMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnc3JjJywgcHJvY2Vzc2VkU3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyBwcm9jZXNzZWRTcmMgKyAnXCIpJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGFwcGVhckluc3RhbmNlID0gbGliLmFwcGVhci5pbml0KHtcbiAgICAgICAgICAgIGNsczogJ2ltZ3RtcCcsIC8v5Y+v6YCJ77yM6ZyA6KaB6YGN5Y6G55qE5YWD57SgXG4gICAgICAgICAgICBvbmNlOiB0cnVlLCAvL+WPr+mAie+8jOaYr+WQpuWPquinpuWPkeS4gOasoVxuICAgICAgICAgICAgeDogY29uZmlnLmxhenlXaWR0aCwgLy/lj6/pgInvvIzlrrnlmajlj7Povrnot53nprt45Lul5YaF55qE5YWD57Sg5Yqg6L2977yM6buY6K6k5Li6MFxuICAgICAgICAgICAgeTogY29uZmlnLmxhenlIZWlnaHQsIC8v5Y+v6YCJ77yM5a655Zmo5bqV6YOo6Led56a7eeS7peWGheeahOWFg+e0oOWKoOi9ve+8jOm7mOiupOS4ujBcbiAgICAgICAgICAgIG9uQXBwZWFyOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGFwcGx5U3JjKGl0ZW0sIGl0ZW0uZ2V0QXR0cmlidXRlKCdpLWxhenktc3JjJykpO1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdpLWxhenktc3JjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgYWRhcHRlci5sb2dDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdsaWItaW1nIENvbmZpZ1xcbicsIGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBhZGFwdGVyLmZpcmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCFhcHBlYXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsID0gJ2lfJyArIERhdGUubm93KCkgJSAxMDAwMDA7XG4gICAgICAgIHZhciBkb21MaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyBjb25maWcuZGF0YVNyYyArICddJyk7XG5cbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGRvbUxpc3QsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kYXRhc2V0LmxhenkgPT0gJ2ZhbHNlJyAmJiBpdGVtLmRhdGFzZXQubGF6eSAhPSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICBhcHBseVNyYyhpdGVtLCBwcm9jZXNzU3JjKGl0ZW0sIGl0ZW0uZ2V0QXR0cmlidXRlKGNvbmZpZy5kYXRhU3JjKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQobGFiZWwpO1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdpLWxhenktc3JjJywgaXRlbS5nZXRBdHRyaWJ1dGUoY29uZmlnLmRhdGFTcmMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKGNvbmZpZy5kYXRhU3JjKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXBwZWFySW5zdGFuY2UuYmluZCgnLicgKyBsYWJlbCk7XG4gICAgICAgIGFwcGVhckluc3RhbmNlLmZpcmUoKTtcbiAgICB9XG5cblxuXG4gICAgYWRhcHRlci5kZWZhdWx0U3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZRSW1XTmdZR0JnQUFBQUJRQUJoNkZPMUFBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuXG5cblxuICAgIGxpYi5pbWcgPSBhZGFwdGVyO1xuICAgIFxuICAgIG1vZHVsZS5leHBvcnRzID0gYWRhcHRlcjtcblxufSkod2luZG93LCB3aW5kb3dbJ2xpYiddIHx8ICh3aW5kb3dbJ2xpYiddID0ge30pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xhenlpbWcvc3JjL2FkYXB0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIjtcbihmdW5jdGlvbiAod2luLCBsaWIpIHtcbiAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICB2YXIgYXBwZWFyRXZ0O1xuICB2YXIgZGlzYXBwZWFyRXZ0O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KCkge1xuICAgIGFwcGVhckV2dCA9IGRvYy5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIik7Ly/liJvlu7roh6rlrprkuYnmmL7npLrkuovku7YgIFxuICAgIGRpc2FwcGVhckV2dCA9IGRvYy5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIik7Ly/liJvlu7roh6rlrprkuYnmtojlpLHkuovku7YgIFxuICAgIGFwcGVhckV2dC5pbml0RXZlbnQoJ19hcHBlYXInLCBmYWxzZSwgdHJ1ZSk7ICAgICAgXG4gICAgZGlzYXBwZWFyRXZ0LmluaXRFdmVudCgnX2Rpc2FwcGVhcicsIGZhbHNlLCB0cnVlKTsgICAgICBcbiAgfVxuXG4gIC8qKlxuICAgKiBbdGhyb3R0bGUg6IqC5rWB5Ye95pWwXVxuICAgKiBAcGFyYW0gIHtbZnVuY3Rpb25dfSBmdW5jIFvmiafooYzlh73mlbBdXG4gICAqIEBwYXJhbSAge1tpbnRdfSB3YWl0IFvnrYnlvoXml7bplb9dXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGxhdGVzdCA9IERhdGUubm93KCksXG4gICAgICBwcmV2aW91cyA9IDAsLy/kuIrmrKHmiafooYznmoTml7bpl7RcbiAgICAgIHRpbWVvdXQgPSBudWxsLC8vc2V0VGltb3V05Lu75YqhXG4gICAgICBjb250ZXh0LC8v5LiK5LiL5paHXG4gICAgICBhcmdzLC8v5Y+C5pWwXG4gICAgICByZXN1bHQ7Ly/nu5PmnpxcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2aW91cyA9IERhdGUubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDsvL+a4heepuuiuoeaXtuWZqFxuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID49IHdhaXQpIHtcbiAgICAgICAgLy/lpoLmnpzmsqHmnInliankvZnml7bpl7TvvIzmiJbogIXlrZjlnKjkv67mlLnov4fns7vnu5/ml7bpl7Tlr7zoh7TliankvZnml7bpl7Tlop7lpKfnmoTmg4XlhrXvvIzliJnmiafooYxcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogW2dldE9mZnNldCDojrflj5bovrnot53lsLrlr7hdXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZWwgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcGFyYW0gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9mZnNldChlbCwgcGFyYW0pIHtcbiAgICB2YXIgZWwsIGwsICByLCBiLCB0O1xuICAgIGlmICghZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgcGFyYW0gPSB7eDogMCwgeTogMH07XG4gICAgfVxuXG4gICAgaWYgKGVsICE9IHdpbmRvdykge1xuICAgICAgZWwgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGwgPSBlbC5sZWZ0O1xuICAgICAgdCA9IGVsLnRvcDtcbiAgICAgIHIgPSBlbC5yaWdodDtcbiAgICAgIGIgPSBlbC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSAwO1xuICAgICAgdCA9IDA7XG4gICAgICByID0gbCArIGVsLmlubmVyV2lkdGg7XG4gICAgICBiID0gdCArIGVsLmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ2xlZnQnOiBsLFxuICAgICAgJ3RvcCc6IHQsXG4gICAgICAncmlnaHQnOiByICsgcGFyYW0ueCxcbiAgICAgICdib3R0b20nOiBiICsgcGFyYW0ueVxuICAgIH07XG4gIH1cbiAgLy/lhYPntKDkvY3nva7mr5TovoNcbiAgZnVuY3Rpb24gY29tcGFyZU9mZnNldChkMSwgZDIpIHtcbiAgICB2YXIgbGVmdCA9IGQyLnJpZ2h0ID4gZDEubGVmdCAmJiBkMi5sZWZ0IDwgZDEucmlnaHQ7XG4gICAgdmFyIHRvcCA9IGQyLmJvdHRvbSA+IGQxLnRvcCAmJiBkMi50b3AgPCBkMS5ib3R0b207XG4gICAgcmV0dXJuIGxlZnQgJiYgdG9wO1xuICB9XG4gIC8v6I635Y+W56e75Yqo5pa55ZCRXG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbihiZWZvcmVPZmZzZXQsIG5vd09mZnNldCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSAnbm9uZSc7XG4gICAgdmFyIGhvcml6ZW50YWwgPSBiZWZvcmVPZmZzZXQubGVmdCAtIG5vd09mZnNldC5sZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbCA9IGJlZm9yZU9mZnNldC50b3AgLSBub3dPZmZzZXQudG9wO1xuICAgIGlmICh2ZXJ0aWNhbCA9PSAwKSB7XG4gICAgICBpZiAoaG9yaXplbnRhbCAhPSAwKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IGhvcml6ZW50YWwgPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICdub25lJ1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaG9yaXplbnRhbCA9PSAwKSB7XG4gICAgICBpZiAodmVydGljYWwgIT0gMCkge1xuICAgICAgICBkaXJlY3Rpb24gPSB2ZXJ0aWNhbCA+IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgZWwpIHtcbiAgICBmb3IgKHZhciBrIGluIGVsKSB7XG4gICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgdGFyZ2V0W2tdID0gZWxba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogW19fYmluZEV2ZW50IOe7keWumuS6i+S7tu+8jOWMheaLrOa7muWKqOOAgXRvdWNobW92ZeOAgXRyYW5zZm9ybeOAgXJlc2l6ZeetiV1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGZ1bmN0aW9uIF9fYmluZEV2ZW50KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaGFuZGxlID0gdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgX19maXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfSwgdGhpcy5vcHRpb25zLndhaXQpO1xuICAgIGlmICh0aGlzLl9faGFuZGxlKSB7XG4gICAgICAvL+mBv+WFjemHjeWkjee7keWumlxuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fX2hhbmRsZSk7XG4gICAgICB0aGlzLl9faGFuZGxlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fX2hhbmRsZSA9IGhhbmRsZTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGUsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbihldikge1xuICAgICAgX19maXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbkVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgX19maXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfSwgZmFsc2UpO1xuICAgIC8vIGFuZHJvaWQ0LjDku6XkuItcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRBbmltYXRpb25FbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIF9fZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBfX2ZpcmUuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvL+iOt+WPluWuueWZqOWGheaJgOacieeahOWKoOi9veWFg+e0oFxuICBmdW5jdGlvbiBfX2dldEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8v6I635Y+W5a655ZmoXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8v5aaC5p6c5piv5a2X56ym5Liy77yM5YiZ6YCJ5oup5ZmoXG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGRvYy5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8v5a+56LGh5Lyg5YC8XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLy/ojrflj5blrrnlmajlhoXnmoTmiYDmnInnm67moIflhYPntKBcbiAgICBpZiAodGhpcy5jb250YWluZXIgPT0gd2luZG93KSB7XG4gICAgICB2YXIgYXBwZWFyV2F0Y2hFbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgICAgICAgICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFwcGVhcldhdGNoRWxlbWVudHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIGFwcGVhcldhdGNoRWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGFwcGVhcldhdGNoRWxlbWVudHMsIG51bGwpO1xuXG4gICAgYXBwZWFyV2F0Y2hFbGVtZW50cyA9IGFwcGVhcldhdGNoRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGVsZSkge1xuICAgICAgLy8g5aaC5p6c5bey57uP57uR5a6a6L+H77yM5riF6ZmkYXBwZWFy54q25oCB77yM5LiN5YaN5Yqg5YWl5Yiw5pWw57uE6YeMXG4gICAgICBpZiAoZWxlLmRhdGFzZXRbJ2JpbmQnXSA9PSAnMScpIHtcbiAgICAgICAgZGVsZXRlIGVsZS5faGFzQXBwZWFyO1xuICAgICAgICBkZWxldGUgZWxlLl9oYXNEaXNBcHBlYXI7XG4gICAgICAgIGRlbGV0ZSBlbGUuX2FwcGVhcjsgICAgICBcbiAgICAgICAgZWxlLmNsYXNzTGlzdC5yZW1vdmUoc2VsZi5vcHRpb25zLmNscyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwcGVhcldhdGNoRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBfX2luaXRCb3VuZGluZ1JlY3QoZWxlbWVudHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIFtdLmZvckVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBlbGUuX2VsZU9mZnNldCA9IGdldE9mZnNldChlbGUpOyBcbiAgICAgICAgLy/np7vpmaTnsbvlkI1cbiAgICAgICAgZWxlLmNsYXNzTGlzdC5yZW1vdmUoc2VsZi5vcHRpb25zLmNscyk7XG4gICAgICAgIC8vIOagh+W/l+W3sue7j+e7keWumlxuICAgICAgICBlbGUuZGF0YXNldFsnYmluZCddID0gMTtcbiAgICAgIH0pO1xuICAgIH0gICAgICAgIFxuICB9XG5cbiAgLy8g6Kem5Y+R5Yqg6L29XG4gIGZ1bmN0aW9uIF9fZmlyZSgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICBlbGVtZW50cyA9IHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyxcbiAgICAgIGFwcGVhckNhbGxiYWNrID0gdGhpcy5vcHRpb25zLm9uQXBwZWFyLC8vYXBwZWFy55qE5omn6KGM5Ye95pWwXG4gICAgICBkaXNhcHBlYXJDYWxsYmFjayA9IHRoaXMub3B0aW9ucy5vbkRpc2FwcGVhciwvL2Rpc2FwcGVhcueahOaJp+ihjOWHveaVsFxuICAgICAgY29udGFpbmVyT2Zmc2V0ID0gZ2V0T2Zmc2V0KGNvbnRhaW5lciwge1xuICAgICAgICB4OiB0aGlzLm9wdGlvbnMueCxcbiAgICAgICAgeTogdGhpcy5vcHRpb25zLnlcbiAgICAgIH0pLFxuICAgICAgaXNPbmNlID0gdGhpcy5vcHRpb25zLm9uY2UsLy/mmK/lkKblj6rmiafooYzkuIDmrKFcbiAgICAgIGV2ID0gYXJndW1lbnRzWzBdIHx8IHt9O1xuICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICAgICAgLy/ojrflj5blt6blj7Pot53nprtcbiAgICAgICAgdmFyIGVsZU9mZnNldCA9IGdldE9mZnNldChlbGUpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGVsZS5fZWxlT2Zmc2V0LCBlbGVPZmZzZXQpO1xuICAgICAgICAvL+S/neWtmOS4iuS4quaXtuauteeahOS9jee9ruS/oeaBr1xuICAgICAgICBlbGUuX2VsZU9mZnNldCA9IGVsZU9mZnNldDtcbiAgICAgICAgLy/mn6XnnIvmmK/lkKblnKjlj6/op4bljLrln5/ojIPlm7TlhoVcbiAgICAgICAgdmFyIGlzSW5WaWV3ID0gY29tcGFyZU9mZnNldChjb250YWluZXJPZmZzZXQsIGVsZU9mZnNldCk7XG4gICAgICAgIHZhciBhcHBlYXIgPSBlbGUuX2FwcGVhcjtcbiAgICAgICAgdmFyIF9oYXNBcHBlYXIgPSBlbGUuX2hhc0FwcGVhcjtcbiAgICAgICAgdmFyIF9oYXNEaXNBcHBlYXIgPSBlbGUuX2hhc0Rpc0FwcGVhcjtcbiAgICAgICAgYXBwZWFyRXZ0LmRhdGEgPSB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBkaXNhcHBlYXJFdnQuZGF0YSA9IHtcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luVmlldyAmJiAhYXBwZWFyKSB7XG4gICAgICAgICAgaWYgKChpc09uY2UgJiYgIV9oYXNBcHBlYXIpIHx8ICFpc09uY2UpIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5Y+q6Kem5Y+R5LiA5qyh5bm25LiU5rKh5pyJ6Kem5Y+R6L+H5oiW6ICF5YWB6K646Kem5Y+R5aSa5qyhXG4gICAgICAgICAgICAvL+WmguaenOWcqOWPr+inhuWMuuWfn+WGhe+8jOW5tuS4lOaYr+S7jmRpc3BwZWFy6L+b5YWlYXBwZWFy77yM5YiZ5omn6KGM5Zue6LCDXG4gICAgICAgICAgICBhcHBlYXJDYWxsYmFjayAmJiBhcHBlYXJDYWxsYmFjay5jYWxsKGVsZSwgZXYpO1xuICAgICAgICAgICAgLy/op6blj5Hoh6rlrprkuYnkuovku7ZcbiAgICAgICAgICAgIGVsZS5kaXNwYXRjaEV2ZW50KGFwcGVhckV2dCk7XG4gICAgICAgICAgICBlbGUuX2hhc0FwcGVhciA9IHRydWU7XG4gICAgICAgICAgICBlbGUuX2FwcGVhciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0luVmlldyAmJiBhcHBlYXIpIHtcbiAgICAgICAgICBpZiAoKGlzT25jZSAmJiAhX2hhc0Rpc0FwcGVhcikgfHwgIWlzT25jZSkge1xuICAgICAgICAgICAgLy/lpoLmnpzkuI3lnKjlj6/op4bljLrln5/lhoXvvIzlubbkuJTmmK/ku45hcHBlYXLov5vlhaVkaXNhcHBlYXLvvIzmiafooYxkaXNhcHBlYXLlm57osINcbiAgICAgICAgICAgIGRpc2FwcGVhckNhbGxiYWNrICYmIGRpc2FwcGVhckNhbGxiYWNrLmNhbGwoZWxlLCBldik7XG4gICAgICAgICAgICAvL+inpuWPkeiHquWumuS5ieS6i+S7tlxuICAgICAgICAgICAgZWxlLmRpc3BhdGNoRXZlbnQoZGlzYXBwZWFyRXZ0KTtcbiAgICAgICAgICAgIGVsZS5faGFzRGlzQXBwZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsZS5fYXBwZWFyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm90byA9IGV4dGVuZChwcm90bywgbGlzdGVuZXIpO1xuXG4gIGZ1bmN0aW9uIF9faW5pdChvcHRzKSB7XG4gICAgLy/mianlsZXlj4LmlbBcbiAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IChvcHRzID0ge30pKTtcbiAgICAvL+iOt+WPluebruagh+WFg+e0oFxuICAgIHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyA9IHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyB8fCBfX2dldEVsZW1lbnRzLmNhbGwodGhpcywgJy4nICsgdGhpcy5vcHRpb25zLmNscyk7XG4gICAgLy/liJ3lp4vljJbkvY3nva7kv6Hmga9cbiAgICBfX2luaXRCb3VuZGluZ1JlY3QuY2FsbCh0aGlzLCB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMpO1xuICAgIC8v57uR5a6a5LqL5Lu2XG4gICAgX19iaW5kRXZlbnQuY2FsbCh0aGlzKTtcbiAgfVxuICBcbiAgdmFyIEFwcGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfX2luaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG5cbiAgdmFyIGFwcGVhciA9IHtcbiAgICBpbnN0YW5jZXM6IFtdLFxuICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICB2YXIgcHJvdG8gPSB7XG4gICAgICAgIC8v6buY6K6k5Y+C5pWwXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBjb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAgICB3YWl0OiAxMDAsXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIGNsczogJ2xpYi1hcHBlYXInLFxuICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgIG9uUmVzZXQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgIG9uQXBwZWFyOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICBvbkRpc2FwcGVhcjogZnVuY3Rpb24gKCkge31cbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgICBhcHBlYXJXYXRjaEVsZW1lbnRzOiBudWxsLFxuICAgICAgICBiaW5kOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBjbHMgPSB0aGlzLm9wdGlvbnMuY2xzO1xuICAgICAgICAgIC8vIOa3u+WKoOmcgOimgee7keWumueahGFwcGVhcuWFg+e0oFxuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gX19nZXRFbGVtZW50cy5jYWxsKHRoaXMsIG5vZGUpO1xuICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICAgICAgICAgIGlmICghZWxlLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKSB7XG4gICAgICAgICAgICAgICAgZWxlLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmNvbnRhaW5lci5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgLy/lpoLmnpzkvKDlhaXnmoTmmK/lhYPntKDlubbkuJTlnKjljIXlkKvlnKjlrrnlmajkuK3vvIznm7TmjqXmt7vliqDnsbvlkI1cbiAgICAgICAgICAgIGlmICghbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xzKSkge1xuICAgICAgICAgICAgICAvL+a3u+WKoOexu+WQjVxuICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8v5paw5aKe55qE5a2Q5YWD57SgXG4gICAgICAgICAgdmFyIG5ld0VsZW1lbnRzID0gX19nZXRFbGVtZW50cy5jYWxsKHRoaXMsICcuJyArIHRoaXMub3B0aW9ucy5jbHMpO1xuICAgICAgICAgIC8v5a+557yT5a2Y55qE5a2Q5YWD57Sg5YGa5aKe6YePXG4gICAgICAgICAgdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzID0gdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzLmNvbmNhdChuZXdFbGVtZW50cyk7XG4gICAgICAgICAgLy/liJ3lp4vljJbmlrDlrZDlhYPntKDnmoTkvY3nva7kv6Hmga9cbiAgICAgICAgICBfX2luaXRCb3VuZGluZ1JlY3QuY2FsbCh0aGlzLCBuZXdFbGVtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIOmHjee9ruWHveaVsFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICBfX2luaXQuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgICB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGUuX2hhc0FwcGVhcjtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGUuX2hhc0Rpc0FwcGVhcjtcbiAgICAgICAgICAgIGRlbGV0ZSBlbGUuX2FwcGVhcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld0VsZW1lbnRzID0gX19nZXRFbGVtZW50cy5jYWxsKHRoaXMsICcuJyArIHRoaXMub3B0aW9ucy5jbHMpO1xuICAgICAgICAgIHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyA9IHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cy5jb25jYXQobmV3RWxlbWVudHMpO1xuICAgICAgICAgIC8v5Yid5aeL5YyW5L2N572u5L+h5oGvXG4gICAgICAgICAgX19pbml0Qm91bmRpbmdSZWN0LmNhbGwodGhpcywgbmV3RWxlbWVudHMpO1xuICAgICAgICAgIF9fZmlyZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBBcHBlYXIucHJvdG90eXBlID0gcHJvdG87XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQXBwZWFyKG9wdHMpO1xuICAgICAgdGhpcy5pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBmaXJlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuZmlyZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8v5rOo5YaM5LqL5Lu2XG4gIGNyZWF0ZUV2ZW50KCk7XG5cbiAgbGliLmFwcGVhciA9IGFwcGVhcjtcblxufSkod2luZG93LCB3aW5kb3cubGliIHx8ICh3aW5kb3cubGliID0ge30pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sYXp5aW1nL34vYXBwZWFyanMvc3JjL2FwcGVhci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnXG5cbi8vIENvbXBvbmVudCB3aGljaCBjYW4gaGF2ZSBubyBzdWJjb21wb25lbnRzLlxuLy8gVGhpcyBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIHNpbmNlXG4vLyBpdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIGEgYmFzZSBjbGFzcyB0byBleHRlbmQgZnJvbS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF0b21pYyAoZGF0YSkge1xuICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5BdG9taWMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5BdG9taWMucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gZG8gbm9udGhpbmdcbiAgcmV0dXJuXG59XG5cbkF0b21pYy5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAvLyBkbyBub3RoaW5nXG4gIHJldHVyblxufVxuXG5BdG9taWMucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIC8vIGRvIG5vdGhpbmdcbiAgcmV0dXJuXG59XG5cbkF0b21pYy5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgLy8gZG8gbm90aGluZ1xuICByZXR1cm5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2F0b21pYy5qc1xuICoqLyIsImltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL2RvbS9jb21wb25lbnRNYW5hZ2VyJ1xuaW1wb3J0IHsgcmVnaXN0ZXJMb2FkZXIgfSBmcm9tICcuL2xvYWRlcidcbmltcG9ydCB7IHByb3RvY29sIH0gZnJvbSAnLi4vYnJpZGdlJ1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gIC8vIFJlZ2lzdGVyIGEgbmV3IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgcmVnaXN0ZXJDb21wb25lbnQgKG5hbWUsIGNvbXApIHtcbiAgICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIGNvbXApXG4gIH0sXG5cbiAgLy8gUmVnaXN0ZXIgYSBuZXcgYXBpIG1vZHVsZS5cbiAgLy8gSWYgdGhlIG1vZHVsZSBhbHJlYWR5IGV4aXN0cywganVzdCBhZGQgbWV0aG9kcyBmcm9tIHRoZVxuICAvLyBuZXcgbW9kdWxlIHRvIHRoZSBvbGQgb25lLlxuICByZWdpc3RlckFwaU1vZHVsZSAobmFtZSwgbW9kdWxlLCBtZXRhKSB7XG4gICAgaWYgKCFwcm90b2NvbC5hcGlNb2R1bGVbbmFtZV0pIHtcbiAgICAgIHByb3RvY29sLmFwaU1vZHVsZVtuYW1lXSA9IG1vZHVsZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG1vZHVsZSkge1xuICAgICAgICBpZiAobW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBwcm90b2NvbC5hcGlNb2R1bGVbbmFtZV1ba2V5XSA9IG1vZHVsZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVnaXN0ZXIgQVBJIG1vZHVsZSdzIG1ldGEgaW5mbyB0byBqc2ZyYW1ld29ya1xuICAgIGlmIChtZXRhKSB7XG4gICAgICBwcm90b2NvbC5zZXRBcGlNb2R1bGVNZXRhKG1ldGEpXG4gICAgICBnbG9iYWwucmVnaXN0ZXJNb2R1bGVzKHByb3RvY29sLmdldEFwaU1vZHVsZU1ldGEobmFtZSksIHRydWUpXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlZ2lzdGVyIGEgbmV3IGFwaSBtZXRob2QgZm9yIHRoZSBzcGVjaWZpZWQgbW9kdWxlLlxuICAvLyBvcHRzOlxuICAvLyAgLSBhcmdzOiB0eXBlIG9mIGFyZ3VtZW50cyB0aGUgQVBJIG1ldGhvZCB0YWtlcyBzdWNoXG4gIC8vICAgIGFzIFsnc3RyaW5nJywgJ2Z1bmN0aW9uJ11cbiAgcmVnaXN0ZXJBcGkgKG1vZHVsZU5hbWUsIG5hbWUsIG1ldGhvZCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV0pIHtcbiAgICAgIHByb3RvY29sLmFwaU1vZHVsZVttb2R1bGVOYW1lXSA9IHt9XG4gICAgICBwcm90b2NvbC5fbWV0YVttb2R1bGVOYW1lXSA9IFtdXG4gICAgfVxuICAgIHByb3RvY29sLmFwaU1vZHVsZVttb2R1bGVOYW1lXVtuYW1lXSA9IG1ldGhvZFxuICAgIGlmICghYXJncykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlZ2lzdGVyIEFQSSBtZXRhIGluZm8gdG8ganNmcmFtZXdvcmtcbiAgICBwcm90b2NvbC5zZXRBcGlNZXRhKG1vZHVsZU5hbWUsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSlcbiAgICBnbG9iYWwucmVnaXN0ZXJNb2R1bGVzKHByb3RvY29sLmdldEFwaU1vZHVsZU1ldGEobW9kdWxlTmFtZSksIHRydWUpXG4gIH0sXG5cbiAgLy8gUmVnaXN0ZXIgYSBuZXcgd2VleC1idW5kbGUtbG9hZGVyLlxuICByZWdpc3RlckxvYWRlciAobmFtZSwgbG9hZGVyRnVuYykge1xuICAgIHJlZ2lzdGVyTG9hZGVyKG5hbWUsIGxvYWRlckZ1bmMpXG4gIH1cblxufVxuXG4vLyBUbyBpbnN0YWxsIGNvbXBvbmVudHMgYW5kIHBsdWdpbnMuXG5mdW5jdGlvbiBpbnN0YWxsIChtb2QpIHtcbiAgbW9kLmluaXQodGhpcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQgKFdlZXgpIHtcbiAgV2VleC5pbnN0YWxsID0gaW5zdGFsbC5iaW5kKFdlZXgpXG4gIGV4dGVuZChXZWV4LCBtZXRob2RzKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3JlbmRlci9yZWdpc3Rlci5qc1xuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInZhbFwiLHt2YWx1ZTphLnRvU3RyaW5nKCksZW51bWVyYWJsZTohMH0pLHRoaXMuZ3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPjB9LHRoaXMuZ3RlPWZ1bmN0aW9uKGEpe3JldHVybiBjLmNvbXBhcmUodGhpcyxhKT49MH0sdGhpcy5sdD1mdW5jdGlvbihhKXtyZXR1cm4gYy5jb21wYXJlKHRoaXMsYSk8MH0sdGhpcy5sdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPD0wfSx0aGlzLmVxPWZ1bmN0aW9uKGEpe3JldHVybiAwPT09Yy5jb21wYXJlKHRoaXMsYSl9fWIuZW52PWIuZW52fHx7fSxjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbH0sYy5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnZhbC5zcGxpdChcIi5cIiksYj1bXSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXBhcnNlSW50KGFbY10sMTApO2lzTmFOKGQpJiYoZD0wKTt2YXIgZT1kLnRvU3RyaW5nKCk7ZS5sZW5ndGg8NSYmKGU9QXJyYXkoNi1lLmxlbmd0aCkuam9pbihcIjBcIikrZSksYi5wdXNoKGUpLDE9PT1iLmxlbmd0aCYmYi5wdXNoKFwiLlwiKX1yZXR1cm4gcGFyc2VGbG9hdChiLmpvaW4oXCJcIikpfSxjLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXthPWEudG9TdHJpbmcoKS5zcGxpdChcIi5cIiksYj1iLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGh8fGM8Yi5sZW5ndGg7YysrKXt2YXIgZD1wYXJzZUludChhW2NdLDEwKSxlPXBhcnNlSW50KGJbY10sMTApO2lmKHdpbmRvdy5pc05hTihkKSYmKGQ9MCksd2luZG93LmlzTmFOKGUpJiYoZT0wKSxlPmQpcmV0dXJuLTE7aWYoZD5lKXJldHVybiAxfXJldHVybiAwfSxiLnZlcnNpb249ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGM9YS5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvXlxcPy8sXCJcIik7aWYoYi5lbnYucGFyYW1zPXt9LGMpZm9yKHZhciBkPWMuc3BsaXQoXCImXCIpLGU9MDtlPGQubGVuZ3RoO2UrKyl7ZFtlXT1kW2VdLnNwbGl0KFwiPVwiKTt0cnl7Yi5lbnYucGFyYW1zW2RbZV1bMF1dPWRlY29kZVVSSUNvbXBvbmVudChkW2VdWzFdKX1jYXRjaChmKXtiLmVudi5wYXJhbXNbZFtlXVswXV09ZFtlXVsxXX19fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKSxmdW5jdGlvbihhLGIpe2IuZW52PWIuZW52fHx7fTt2YXIgYyxkPWEubmF2aWdhdG9yLnVzZXJBZ2VudDtpZihjPWQubWF0Y2goL1dpbmRvd3NcXHNQaG9uZVxccyg/Ok9TXFxzKT8oW1xcZFxcLl0rKS8pKWIuZW52Lm9zPXtuYW1lOlwiV2luZG93cyBQaG9uZVwiLGlzV2luZG93c1Bob25lOiEwLHZlcnNpb246Y1sxXX07ZWxzZSBpZihkLm1hdGNoKC9TYWZhcmkvKSYmKGM9ZC5tYXRjaCgvQW5kcm9pZFtcXHNcXC9dKFtcXGRcXC5dKykvKSkpYi5lbnYub3M9e3ZlcnNpb246Y1sxXX0sZC5tYXRjaCgvTW9iaWxlXFxzK1NhZmFyaS8pPyhiLmVudi5vcy5uYW1lPVwiQW5kcm9pZFwiLGIuZW52Lm9zLmlzQW5kcm9pZD0hMCk6KGIuZW52Lm9zLm5hbWU9XCJBbmRyb2lkUGFkXCIsYi5lbnYub3MuaXNBbmRyb2lkUGFkPSEwKTtlbHNlIGlmKGM9ZC5tYXRjaCgvKGlQaG9uZXxpUGFkfGlQb2QpLykpe3ZhciBlPWNbMV07Yz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pLGIuZW52Lm9zPXtuYW1lOmUsaXNJUGhvbmU6XCJpUGhvbmVcIj09PWV8fFwiaVBvZFwiPT09ZSxpc0lQYWQ6XCJpUGFkXCI9PT1lLGlzSU9TOiEwLHZlcnNpb246Y1sxXS5zcGxpdChcIl9cIikuam9pbihcIi5cIil9fWVsc2UgYi5lbnYub3M9e25hbWU6XCJ1bmtub3duXCIsdmVyc2lvbjpcIjAuMC4wXCJ9O2IudmVyc2lvbiYmKGIuZW52Lm9zLnZlcnNpb249Yi52ZXJzaW9uKGIuZW52Lm9zLnZlcnNpb24pKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZD1hLm5hdmlnYXRvci51c2VyQWdlbnQ7KGM9ZC5tYXRjaCgvKD86VUNXRUJ8VUNCcm93c2VyXFwvKShbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJVQ1wiLGlzVUM6ITAsdmVyc2lvbjpjWzFdfTooYz1kLm1hdGNoKC9NUVFCcm93c2VyXFwvKFtcXGRcXC5dKykvKSk/Yi5lbnYuYnJvd3Nlcj17bmFtZTpcIlFRXCIsaXNRUTohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiRmlyZWZveFwiLGlzRmlyZWZveDohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL01TSUVcXHMoW1xcZFxcLl0rKS8pKXx8KGM9ZC5tYXRjaCgvSUVNb2JpbGVcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17dmVyc2lvbjpjWzFdfSxkLm1hdGNoKC9JRU1vYmlsZS8pPyhiLmVudi5icm93c2VyLm5hbWU9XCJJRU1vYmlsZVwiLGIuZW52LmJyb3dzZXIuaXNJRU1vYmlsZT0hMCk6KGIuZW52LmJyb3dzZXIubmFtZT1cIklFXCIsYi5lbnYuYnJvd3Nlci5pc0lFPSEwKSxkLm1hdGNoKC9BbmRyb2lkfGlQaG9uZS8pJiYoYi5lbnYuYnJvd3Nlci5pc0lFTGlrZVdlYmtpdD0hMCkpOihjPWQubWF0Y2goLyg/OkNocm9tZXxDcmlPUylcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17bmFtZTpcIkNocm9tZVwiLGlzQ2hyb21lOiEwLHZlcnNpb246Y1sxXX0sZC5tYXRjaCgvVmVyc2lvblxcL1tcXGQrXFwuXStcXHMqQ2hyb21lLykmJihiLmVudi5icm93c2VyLm5hbWU9XCJDaHJvbWUgV2Vidmlld1wiLGIuZW52LmJyb3dzZXIuaXNXZWJ2aWV3PSEwKSk6ZC5tYXRjaCgvU2FmYXJpLykmJihjPWQubWF0Y2goL0FuZHJvaWRbXFxzXFwvXShbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJBbmRyb2lkXCIsaXNBbmRyb2lkOiEwLHZlcnNpb246Y1sxXX06ZC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC8pP2QubWF0Y2goL1NhZmFyaS8pPyhjPWQubWF0Y2goL1ZlcnNpb25cXC8oW1xcZFxcLl0rKS8pLGIuZW52LmJyb3dzZXI9e25hbWU6XCJTYWZhcmlcIixpc1NhZmFyaTohMCx2ZXJzaW9uOmNbMV19KTooYz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pLGIuZW52LmJyb3dzZXI9e25hbWU6XCJpT1MgV2Vidmlld1wiLGlzV2VidmlldzohMCx2ZXJzaW9uOmNbMV0ucmVwbGFjZSgvXFxfL2csXCIuXCIpfSk6Yi5lbnYuYnJvd3Nlcj17bmFtZTpcInVua25vd25cIix2ZXJzaW9uOlwiMC4wLjBcIn0sYi52ZXJzaW9uJiYoYi5lbnYuYnJvd3Nlci52ZXJzaW9uPWIudmVyc2lvbihiLmVudi5icm93c2VyLnZlcnNpb24pKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGM9YS5uYXZpZ2F0b3IudXNlckFnZW50O2MubWF0Y2goL1dlaWJvL2kpP2IuZW52LnRoaXJkYXBwPXthcHBuYW1lOlwiV2VpYm9cIixpc1dlaWJvOiEwfTpjLm1hdGNoKC9NaWNyb01lc3Nlbmdlci9pKT9iLmVudi50aGlyZGFwcD17YXBwbmFtZTpcIldlaXhpblwiLGlzV2VpeGluOiEwfTpiLmVudi50aGlyZGFwcD0hMX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZCxlPWEubmF2aWdhdG9yLnVzZXJBZ2VudDsoZD1lLm1hdGNoKC9XaW5kVmFuZVtcXC9cXHNdKFtcXGRcXC5cXF9dKykvKSkmJihjPWRbMV0pO3ZhciBmPSExLGc9XCJcIixoPVwiXCIsaT1cIlwiOyhkPWUubWF0Y2goL0FsaUFwcFxcKChbQS1aXFwtXSspXFwvKFtcXGRcXC5dKylcXCkvaSkpJiYoZj0hMCxnPWRbMV0saT1kWzJdLGg9Zy5pbmRleE9mKFwiLVBEXCIpPjA/Yi5lbnYub3MuaXNJT1M/XCJpUGFkXCI6Yi5lbnYub3MuaXNBbmRyb2lkP1wiQW5kcm9pZFBhZFwiOmIuZW52Lm9zLm5hbWU6Yi5lbnYub3MubmFtZSksIWcmJmUuaW5kZXhPZihcIlRCSU9TXCIpPjAmJihnPVwiVEJcIiksZj9iLmVudi5hbGlhcHA9e3dpbmR2YW5lOmIudmVyc2lvbihjfHxcIjAuMC4wXCIpLGFwcG5hbWU6Z3x8XCJ1bmtvd25cIix2ZXJzaW9uOmIudmVyc2lvbihpfHxcIjAuMC4wXCIpLHBsYXRmb3JtOmh8fGIuZW52Lm9zLm5hbWV9OmIuZW52LmFsaWFwcD0hMSxiLmVudi50YW9iYW9BcHA9Yi5lbnYuYWxpYXBwfSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWydlbnYnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lbnZkL2J1aWxkL2VudmQuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJwYXJhbXNcIix7c2V0OmZ1bmN0aW9uKGEpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtmb3IodmFyIGMgaW4gYilkZWxldGUgYltjXTtmb3IodmFyIGMgaW4gYSliW2NdPWFbY119fSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYn0sZW51bWVyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic2VhcmNoXCIse3NldDpmdW5jdGlvbihhKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYSl7MD09PWEuaW5kZXhPZihcIj9cIikmJihhPWEuc3Vic3RyKDEpKTt2YXIgYz1hLnNwbGl0KFwiJlwiKTtmb3IodmFyIGQgaW4gYilkZWxldGUgYltkXTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9Y1tlXS5zcGxpdChcIj1cIik7aWYodm9pZCAwIT09ZlsxXSYmKGZbMV09ZlsxXS50b1N0cmluZygpKSxmWzBdKXRyeXtiW2RlY29kZVVSSUNvbXBvbmVudChmWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KGZbMV0pfWNhdGNoKGcpe2JbZlswXV09ZlsxXX19fX0sZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9W107Zm9yKHZhciBjIGluIGIpaWYodm9pZCAwIT09YltjXSlpZihcIlwiIT09YltjXSl0cnl7YS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoYltjXSkpfWNhdGNoKGQpe2EucHVzaChjK1wiPVwiK2JbY10pfWVsc2UgdHJ5e2EucHVzaChlbmNvZGVVUklDb21wb25lbnQoYykpfWNhdGNoKGQpe2EucHVzaChjKX1yZXR1cm4gYS5sZW5ndGg/XCI/XCIrYS5qb2luKFwiJlwiKTpcIlwifSxlbnVtZXJhYmxlOiEwfSk7dmFyIGM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJoYXNoXCIse3NldDpmdW5jdGlvbihhKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGEmJmEuaW5kZXhPZihcIiNcIik8MCYmKGE9XCIjXCIrYSksYz1hfHxcIlwiKX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9LGVudW1lcmFibGU6ITB9KSx0aGlzLnNldD1mdW5jdGlvbihhKXthPWF8fFwiXCI7dmFyIGI7aWYoIShiPWEubWF0Y2gobmV3IFJlZ0V4cChcIl4oW2EtejAtOS1dKzopP1svXXsyfSg/OihbXkAvOj9dKykoPzo6KFteQC86XSspKT9AKT8oW146Lz8jXSspKD86WzpdKFswLTldKykpPyhbL11bXj8jO10qKT8oPzpbP10oW14jXSopKT8oWyNdW14/XSopPyRcIixcImlcIikpKSl0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB1cmkgc2NoZW1lLlwiKTt0aGlzLnByb3RvY29sPWJbMV18fChcIm9iamVjdFwiPT10eXBlb2YgbG9jYXRpb24/bG9jYXRpb24ucHJvdG9jb2w6XCJcIiksdGhpcy51c2VybmFtZT1iWzJdfHxcIlwiLHRoaXMucGFzc3dvcmQ9YlszXXx8XCJcIix0aGlzLmhvc3RuYW1lPXRoaXMuaG9zdD1iWzRdLHRoaXMucG9ydD1iWzVdfHxcIlwiLHRoaXMucGF0aG5hbWU9Yls2XXx8XCIvXCIsdGhpcy5zZWFyY2g9Yls3XXx8XCJcIix0aGlzLmhhc2g9Yls4XXx8XCJcIix0aGlzLm9yaWdpbj10aGlzLnByb3RvY29sK1wiLy9cIit0aGlzLmhvc3RuYW1lfSx0aGlzLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wcm90b2NvbCtcIi8vXCI7cmV0dXJuIHRoaXMudXNlcm5hbWUmJihhKz10aGlzLnVzZXJuYW1lLHRoaXMucGFzc3dvcmQmJihhKz1cIjpcIit0aGlzLnBhc3N3b3JkKSxhKz1cIkBcIiksYSs9dGhpcy5ob3N0LHRoaXMucG9ydCYmXCI4MFwiIT09dGhpcy5wb3J0JiYoYSs9XCI6XCIrdGhpcy5wb3J0KSx0aGlzLnBhdGhuYW1lJiYoYSs9dGhpcy5wYXRobmFtZSksdGhpcy5zZWFyY2gmJihhKz10aGlzLnNlYXJjaCksdGhpcy5oYXNoJiYoYSs9dGhpcy5oYXNoKSxhfSxhJiZ0aGlzLnNldChhLnRvU3RyaW5nKCkpfWIuaHR0cHVybD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSl9fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWydodHRwdXJsJ107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaHR0cHVybC9idWlsZC9odHRwdXJsLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBpc0luaXRpYWxpemVkID0gZmFsc2VcblxuLy8gbWFqb3IgZXZlbnRzIHN1cHBvcnRlZDpcbi8vICAgcGFuc3RhcnRcbi8vICAgcGFubW92ZVxuLy8gICBwYW5lbmRcbi8vICAgc3dpcGVcbi8vICAgbG9uZ3ByZXNzXG4vLyBleHRyYSBldmVudHMgc3VwcG9ydGVkOlxuLy8gICBkdWFsdG91Y2hzdGFydFxuLy8gICBkdWFsdG91Y2hcbi8vICAgZHVhbHRvdWNoZW5kXG4vLyAgIHRhcFxuLy8gICBkb3VibGV0YXBcbi8vICAgcHJlc3NlbmRcblxudmFyIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxudmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudFxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgZ2VzdHVyZXMgPSB7fVxudmFyIGxhc3RUYXAgPSBudWxsXG5cbi8qKlxuICogZmluZCB0aGUgY2xvc2VzdCBjb21tb24gYW5jZXN0b3JcbiAqIGlmIHRoZXJlJ3Mgbm8gb25lLCByZXR1cm4gbnVsbFxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsMSBmaXJzdCBlbGVtZW50XG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbDIgc2Vjb25kIGVsZW1lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICBjb21tb24gYW5jZXN0b3JcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3IoZWwxLCBlbDIpIHtcbiAgdmFyIGVsID0gZWwxXG4gIHdoaWxlIChlbCkge1xuICAgIGlmIChlbC5jb250YWlucyhlbDIpIHx8IGVsID09IGVsMikge1xuICAgICAgcmV0dXJuIGVsXG4gICAgfVxuICAgIGVsID0gZWwucGFyZW50Tm9kZVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogZmlyZSBhIEhUTUxFdmVudFxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgd2hpY2ggZWxlbWVudCB0byBmaXJlIGEgZXZlbnQgb25cbiAqIEBwYXJhbSAge3N0cmluZ30gIHR5cGUgICAgdHlwZSBvZiBldmVudFxuICogQHBhcmFtICB7b2JqZWN0fSAgZXh0cmEgICBleHRyYSBkYXRhIGZvciB0aGUgZXZlbnQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpcmVFdmVudChlbGVtZW50LCB0eXBlLCBleHRyYSkge1xuICB2YXIgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICBldmVudC5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSlcblxuICBpZiAodHlwZW9mIGV4dHJhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHAgaW4gZXh0cmEpIHtcbiAgICAgIGV2ZW50W3BdID0gZXh0cmFbcF1cbiAgICB9XG4gIH1cblxuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogY2FsYyB0aGUgdHJhbnNmb3JtXG4gKiBhc3N1bWUgNCBwb2ludHMgQUJDRCBvbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW1cbiAqID4gcm90YXRl77yaYW5nbGUgcm90YXRpbmcgZnJvbSBBQiB0byBDRFxuICogPiBzY2FsZe+8mnNjYWxlIHJhdGlvIGZyb20gQUIgdG8gQ0RcbiAqID4gdHJhbnNsYXRl77yadHJhbnNsYXRlIHNoaWZ0IGZyb20gQSB0byBDXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSB4MSBhYnNjaXNzYSBvZiBBXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIG9yZGluYXRlIG9mIEFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgYWJzY2lzc2Egb2YgQlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiBvcmRpbmF0ZSBvZiBCXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgzIGFic2Npc3NhIG9mIENcbiAqIEBwYXJhbSAge251bWJlcn0geTMgb3JkaW5hdGUgb2YgQ1xuICogQHBhcmFtICB7bnVtYmVyfSB4NCBhYnNjaXNzYSBvZiBEXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHk0IG9yZGluYXRlIG9mIERcbiAqIEByZXR1cm4ge29iamVjdH0gICAgdHJhbnNmb3JtIG9iamVjdCBsaWtlXG4gKiAgIHtyb3RhdGUsIHNjYWxlLCB0cmFuc2xhdGVbMl0sIG1hdHJpeFszXVszXX1cbiAqL1xuZnVuY3Rpb24gY2FsYyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcbiAgdmFyIHJvdGF0ZSA9IE1hdGguYXRhbjIoeTQgLSB5MywgeDQgLSB4MykgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpXG4gIHZhciBzY2FsZSA9IE1hdGguc3FydCgoTWF0aC5wb3coeTQgLSB5MywgMilcbiAgICArIE1hdGgucG93KHg0IC0geDMsIDIpKSAvIChNYXRoLnBvdyh5MiAtIHkxLCAyKVxuICAgICsgTWF0aC5wb3coeDIgLSB4MSwgMikpKVxuICB2YXIgdHJhbnNsYXRlID0gW1xuICAgIHgzXG4gICAgLSBzY2FsZSAqIHgxICogTWF0aC5jb3Mocm90YXRlKVxuICAgICsgc2NhbGUgKiB5MSAqIE1hdGguc2luKHJvdGF0ZSksXG4gICAgeTNcbiAgICAtIHNjYWxlICogeTEgKiBNYXRoLmNvcyhyb3RhdGUpXG4gICAgLSBzY2FsZSAqIHgxICogTWF0aC5zaW4ocm90YXRlKV1cblxuICByZXR1cm4ge1xuICAgIHJvdGF0ZTogcm90YXRlLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICBtYXRyaXg6IFtcbiAgICAgIFtzY2FsZSAqIE1hdGguY29zKHJvdGF0ZSksIC1zY2FsZSAqIE1hdGguc2luKHJvdGF0ZSksIHRyYW5zbGF0ZVswXV0sXG4gICAgICBbc2NhbGUgKiBNYXRoLnNpbihyb3RhdGUpLCBzY2FsZSAqIE1hdGguY29zKHJvdGF0ZSksIHRyYW5zbGF0ZVsxXV0sXG4gICAgICBbMCwgMCwgMV1cbiAgICBdXG4gIH1cbn1cblxuLyoqXG4gKiB0YWtlIG92ZXIgdGhlIHRvdWNoc3RhcnQgZXZlbnRzLiBBZGQgbmV3IHRvdWNoZXMgdG8gdGhlIGdlc3R1cmVzLlxuICogSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgcmVjb3JkcywgdGhlbiBiaW5kIHRvdWNobW92ZSwgdG9jaGVuZFxuICogYW5kIHRvdWNoY2FuY2VsIGV2ZW50cy5cbiAqIG5ldyB0b3VjaGVzIGluaXRpYWxpemVkIHdpdGggc3RhdGUgJ3RhcHBpbmcnLCBhbmQgd2l0aGluIDUwMCBtaWxsaXNlY29uZHNcbiAqIGlmIHRoZSBzdGF0ZSBpcyBzdGlsbCB0YXBwaW5nLCB0aGVuIHRyaWdnZXIgZ2VzdHVyZSAncHJlc3MnLlxuICogSWYgdGhlcmUgYXJlIHR3byB0b3VjaGUgcG9pbnRzLCB0aGVuIHRoZSAnZHVhbHRvdWNoc3RhcnQnIGlzIHRyaWdnZXJkLiBUaGVcbiAqIG5vZGUgb2YgdGhlIHRvdWNoIGdlc3R1cmUgaXMgdGhlaXIgY2xvZXN0IGNvbW1vbiBhbmNlc3Rvci5cbiAqXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihldmVudCkge1xuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09PSAwKSB7XG4gICAgZG9jRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciwgZmFsc2UpXG4gICAgZG9jRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyLCBmYWxzZSlcbiAgfVxuXG4gIC8vIHJlY29yZCBldmVyeSB0b3VjaFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV1cbiAgICB2YXIgdG91Y2hSZWNvcmQgPSB7fVxuXG4gICAgZm9yICh2YXIgcCBpbiB0b3VjaCkge1xuICAgICAgdG91Y2hSZWNvcmRbcF0gPSB0b3VjaFtwXVxuICAgIH1cblxuICAgIHZhciBnZXN0dXJlID0ge1xuICAgICAgc3RhcnRUb3VjaDogdG91Y2hSZWNvcmQsXG4gICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICBzdGF0dXM6ICd0YXBwaW5nJyxcbiAgICAgIGVsZW1lbnQ6IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQudGFyZ2V0LFxuICAgICAgcHJlc3NpbmdIYW5kbGVyOiBzZXRUaW1lb3V0KGZ1bmN0aW9uIChlbGVtZW50LCB0b3VjaCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3RhcHBpbmcnKSB7XG4gICAgICAgICAgICBnZXN0dXJlLnN0YXR1cyA9ICdwcmVzc2luZydcblxuICAgICAgICAgICAgZmlyZUV2ZW50KGVsZW1lbnQsICdsb25ncHJlc3MnLCB7XG4gICAgICAgICAgICAgIC8vIGFkZCB0b3VjaCBkYXRhIGZvciB3ZWV4XG4gICAgICAgICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcbiAgICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpXG4gICAgICAgICAgZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0oZXZlbnQuc3JjRWxlbWVudCB8fCBldmVudC50YXJnZXQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldKSwgNTAwKVxuICAgIH1cbiAgICBnZXN0dXJlc1t0b3VjaC5pZGVudGlmaWVyXSA9IGdlc3R1cmVcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXVxuXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cblxuICAgIGZpcmVFdmVudChnZXRDb21tb25BbmNlc3RvcihlbGVtZW50c1swXSwgZWxlbWVudHNbMV0pLCAnZHVhbHRvdWNoc3RhcnQnLCB7XG4gICAgICB0b3VjaGVzOiBzbGljZS5jYWxsKGV2ZW50LnRvdWNoZXMpLFxuICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogdGFrZSBvdmVyIHRvdWNobW92ZSBldmVudHMsIGFuZCBoYW5kbGUgcGFuIGFuZCBkdWFsIHJlbGF0ZWQgZ2VzdHVyZXMuXG4gKlxuICogMS4gdHJhdmVyc2UgZXZlcnkgdG91Y2ggcG9pbnTvvJpcbiAqID4gaWYgJ3RhcHBpbmcnIGFuZCB0aGUgc2hpZnQgaXMgb3ZlciAxMCBwaXhsZXMsIHRoZW4gaXQncyBhICdwYW5uaW5nJy5cbiAqIDIuIGlmIHRoZXJlIGFyZSB0d28gdG91Y2ggcG9pbnRzLCB0aGVuIGNhbGMgdGhlIHRyYW5mb3JtIGFuZCB0cmlnZ2VyXG4gKiAgICdkdWFsdG91Y2gnLlxuICpcbiAqIEBldmVudFxuICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHRvdWNobW92ZUhhbmRsZXIoZXZlbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldXG4gICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaC5pZGVudGlmaWVyXVxuXG4gICAgaWYgKCFnZXN0dXJlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWdlc3R1cmUubGFzdFRvdWNoKSB7XG4gICAgICBnZXN0dXJlLmxhc3RUb3VjaCA9IGdlc3R1cmUuc3RhcnRUb3VjaFxuICAgIH1cbiAgICBpZiAoIWdlc3R1cmUubGFzdFRpbWUpIHtcbiAgICAgIGdlc3R1cmUubGFzdFRpbWUgPSBnZXN0dXJlLnN0YXJ0VGltZVxuICAgIH1cbiAgICBpZiAoIWdlc3R1cmUudmVsb2NpdHlYKSB7XG4gICAgICBnZXN0dXJlLnZlbG9jaXR5WCA9IDBcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLnZlbG9jaXR5WSkge1xuICAgICAgZ2VzdHVyZS52ZWxvY2l0eVkgPSAwXG4gICAgfVxuICAgIGlmICghZ2VzdHVyZS5kdXJhdGlvbikge1xuICAgICAgZ2VzdHVyZS5kdXJhdGlvbiA9IDBcbiAgICB9XG5cbiAgICB2YXIgdGltZSA9ICBEYXRlLm5vdygpIC0gZ2VzdHVyZS5sYXN0VGltZVxuICAgIHZhciB2eCA9ICh0b3VjaC5jbGllbnRYIC0gZ2VzdHVyZS5sYXN0VG91Y2guY2xpZW50WCkgLyB0aW1lXG4gICAgdmFyIHZ5ID0gKHRvdWNoLmNsaWVudFkgLSBnZXN0dXJlLmxhc3RUb3VjaC5jbGllbnRZKSAvIHRpbWVcblxuICAgIHZhciBSRUNPUkRfRFVSQVRJT04gPSA3MFxuICAgIGlmICh0aW1lID4gUkVDT1JEX0RVUkFUSU9OKSB7XG4gICAgICB0aW1lID0gUkVDT1JEX0RVUkFUSU9OXG4gICAgfVxuICAgIGlmIChnZXN0dXJlLmR1cmF0aW9uICsgdGltZSA+IFJFQ09SRF9EVVJBVElPTikge1xuICAgICAgZ2VzdHVyZS5kdXJhdGlvbiA9IFJFQ09SRF9EVVJBVElPTiAtIHRpbWVcbiAgICB9XG5cbiAgICBnZXN0dXJlLnZlbG9jaXR5WCA9IChnZXN0dXJlLnZlbG9jaXR5WCAqIGdlc3R1cmUuZHVyYXRpb24gKyB2eCAqIHRpbWUpXG4gICAgICAvIChnZXN0dXJlLmR1cmF0aW9uICsgdGltZSlcbiAgICBnZXN0dXJlLnZlbG9jaXR5WSA9IChnZXN0dXJlLnZlbG9jaXR5WSAqIGdlc3R1cmUuZHVyYXRpb24gKyB2eSAqIHRpbWUpXG4gICAgICAvIChnZXN0dXJlLmR1cmF0aW9uICsgdGltZSlcbiAgICBnZXN0dXJlLmR1cmF0aW9uICs9IHRpbWVcblxuICAgIGdlc3R1cmUubGFzdFRvdWNoID0ge31cblxuICAgIGZvciAodmFyIHAgaW4gdG91Y2gpIHtcbiAgICAgIGdlc3R1cmUubGFzdFRvdWNoW3BdID0gdG91Y2hbcF1cbiAgICB9XG4gICAgZ2VzdHVyZS5sYXN0VGltZSA9IERhdGUubm93KClcblxuICAgIHZhciBkaXNwbGFjZW1lbnRYID0gdG91Y2guY2xpZW50WCAtIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRYXG4gICAgdmFyIGRpc3BsYWNlbWVudFkgPSB0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFlcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlzcGxhY2VtZW50WCwgMilcbiAgICAgICsgTWF0aC5wb3coZGlzcGxhY2VtZW50WSwgMikpXG4gICAgdmFyIGlzVmVydGljYWwgPSAhKE1hdGguYWJzKGRpc3BsYWNlbWVudFgpID4gTWF0aC5hYnMoZGlzcGxhY2VtZW50WSkpXG4gICAgdmFyIGRpcmVjdGlvbiA9IGlzVmVydGljYWxcbiAgICAgID8gZGlzcGxhY2VtZW50WSA+PSAwID8gJ2Rvd24nIDogJ3VwJ1xuICAgICAgOiBkaXNwbGFjZW1lbnRYID49IDAgPyAncmlnaHQnIDogJ2xlZnQnXG5cbiAgICAvLyBtYWdpYyBudW1iZXIgMTA6IG1vdmluZyAxMHB4IG1lYW5zIHBhbiwgbm90IHRhcFxuICAgIGlmICgoZ2VzdHVyZS5zdGF0dXMgPT09ICd0YXBwaW5nJyB8fCBnZXN0dXJlLnN0YXR1cyA9PT0gJ3ByZXNzaW5nJylcbiAgICAgICAgJiYgZGlzdGFuY2UgPiAxMCkge1xuICAgICAgZ2VzdHVyZS5zdGF0dXMgPSAncGFubmluZydcbiAgICAgIGdlc3R1cmUuaXNWZXJ0aWNhbCA9IGlzVmVydGljYWxcbiAgICAgIGdlc3R1cmUuZGlyZWN0aW9uID0gZGlyZWN0aW9uXG5cbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwYW5zdGFydCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50LFxuICAgICAgICBpc1ZlcnRpY2FsOiBnZXN0dXJlLmlzVmVydGljYWwsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3Bhbm5pbmcnKSB7XG4gICAgICBnZXN0dXJlLnBhblRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwYW5tb3ZlJywge1xuICAgICAgICBkaXNwbGFjZW1lbnRYOiBkaXNwbGFjZW1lbnRYLFxuICAgICAgICBkaXNwbGFjZW1lbnRZOiBkaXNwbGFjZW1lbnRZLFxuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnQsXG4gICAgICAgIGlzVmVydGljYWw6IGdlc3R1cmUuaXNWZXJ0aWNhbCxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT0gMikge1xuICAgIHZhciBwb3NpdGlvbiA9IFtdXG4gICAgdmFyIGN1cnJlbnQgPSBbXVxuICAgIHZhciBlbGVtZW50cyA9IFtdXG4gICAgdmFyIHRyYW5zZm9ybVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC50b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzW2ldXG4gICAgICB2YXIgZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoLmlkZW50aWZpZXJdXG4gICAgICBwb3NpdGlvbi5wdXNoKFtnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WCwgZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFldKVxuICAgICAgY3VycmVudC5wdXNoKFt0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZXSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIGdlc3R1cmVzKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKGdlc3R1cmVzW3BdLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdHJhbnNmb3JtID0gY2FsYyhcbiAgICAgIHBvc2l0aW9uWzBdWzBdLFxuICAgICAgcG9zaXRpb25bMF1bMV0sXG4gICAgICBwb3NpdGlvblsxXVswXSxcbiAgICAgIHBvc2l0aW9uWzFdWzFdLFxuICAgICAgY3VycmVudFswXVswXSxcbiAgICAgIGN1cnJlbnRbMF1bMV0sXG4gICAgICBjdXJyZW50WzFdWzBdLFxuICAgICAgY3VycmVudFsxXVsxXVxuICAgIClcbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaCcsIHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcbiAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIGhhbmRsZSB0b3VjaGVuZCBldmVudFxuICpcbiAqIDEuIGlmIHRoZXJlIGFyZSB0b3cgdG91Y2ggcG9pbnRzLCB0aGVuIHRyaWdnZXIgJ2R1YWx0b3VjaGVuZCflpoJcbiAqXG4gKiAyLiB0cmF2ZXJzZSBldmVyeSB0b3VjaCBwaW9udO+8mlxuICogPiBpZiB0YXBwaW5nLCB0aGVuIHRyaWdnZXIgJ3RhcCcuXG4gKiBJZiB0aGVyZSBpcyBhIHRhcCAzMDAgbWlsbGlzZWNvbmRzIGJlZm9yZSwgdGhlbiBpdCdzIGEgJ2RvdWJsZXRhcCcuXG4gKiA+IGlmIHBhZGRpbmcsIHRoZW4gZGVjaWRlIHRvIHRyaWdnZXIgJ3BhbmVuZCcgb3IgJ3N3aXBlJ1xuICogPiBpZiBwcmVzc2luZywgdGhlbiB0cmlnZ2VyICdwcmVzc2VuZCcuXG4gKlxuICogMy4gcmVtb3ZlIGxpc3RlbmVycy5cbiAqXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiB0b3VjaGVuZEhhbmRsZXIoZXZlbnQpIHtcblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PSAyKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW11cbiAgICBmb3IgKHZhciBwIGluIGdlc3R1cmVzKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKGdlc3R1cmVzW3BdLmVsZW1lbnQpXG4gICAgfVxuICAgIGZpcmVFdmVudChnZXRDb21tb25BbmNlc3RvcihlbGVtZW50c1swXSwgZWxlbWVudHNbMV0pLCAnZHVhbHRvdWNoZW5kJywge1xuICAgICAgdG91Y2hlczogc2xpY2UuY2FsbChldmVudC50b3VjaGVzKSxcbiAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXVxuICAgIHZhciBpZCA9IHRvdWNoLmlkZW50aWZpZXJcbiAgICB2YXIgZ2VzdHVyZSA9IGdlc3R1cmVzW2lkXVxuXG4gICAgaWYgKCFnZXN0dXJlKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnByZXNzaW5nSGFuZGxlcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyKVxuICAgICAgZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGdlc3R1cmUuc3RhdHVzID09PSAndGFwcGluZycpIHtcbiAgICAgIGdlc3R1cmUudGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ3RhcCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgfSlcblxuICAgICAgaWYgKGxhc3RUYXAgJiYgZ2VzdHVyZS50aW1lc3RhbXAgLSBsYXN0VGFwLnRpbWVzdGFtcCA8IDMwMCkge1xuICAgICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAnZG91YmxldGFwJywge1xuICAgICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBsYXN0VGFwID0gZ2VzdHVyZVxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3Bhbm5pbmcnKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGR1cmF0aW9uID0gbm93IC0gZ2VzdHVyZS5zdGFydFRpbWVcbiAgICAgIHZhciBkaXNwbGFjZW1lbnRYID0gdG91Y2guY2xpZW50WCAtIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRYXG4gICAgICB2YXIgZGlzcGxhY2VtZW50WSA9IHRvdWNoLmNsaWVudFkgLSBnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WVxuXG4gICAgICB2YXIgdmVsb2NpdHkgPSBNYXRoLnNxcnQoZ2VzdHVyZS52ZWxvY2l0eVkgKiBnZXN0dXJlLnZlbG9jaXR5WVxuICAgICAgICArIGdlc3R1cmUudmVsb2NpdHlYICogZ2VzdHVyZS52ZWxvY2l0eVgpXG4gICAgICB2YXIgaXNTd2lwZSA9IHZlbG9jaXR5ID4gMC41ICYmIChub3cgLSBnZXN0dXJlLmxhc3RUaW1lKSA8IDEwMFxuICAgICAgdmFyIGV4dHJhID0ge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGlzU3dpcGU6IGlzU3dpcGUsXG4gICAgICAgIHZlbG9jaXR5WDogZ2VzdHVyZS52ZWxvY2l0eVgsXG4gICAgICAgIHZlbG9jaXR5WTogZ2VzdHVyZS52ZWxvY2l0eVksXG4gICAgICAgIGRpc3BsYWNlbWVudFg6IGRpc3BsYWNlbWVudFgsXG4gICAgICAgIGRpc3BsYWNlbWVudFk6IGRpc3BsYWNlbWVudFksXG4gICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudCxcbiAgICAgICAgaXNWZXJ0aWNhbDogZ2VzdHVyZS5pc1ZlcnRpY2FsLFxuICAgICAgICBkaXJlY3Rpb246IGdlc3R1cmUuZGlyZWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwYW5lbmQnLCBleHRyYSlcbiAgICAgIGlmIChpc1N3aXBlKSB7XG4gICAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdzd2lwZScsIGV4dHJhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3ByZXNzaW5nJykge1xuICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ3ByZXNzZW5kJywge1xuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgICB9KVxuICAgIH1cblxuICAgIGRlbGV0ZSBnZXN0dXJlc1tpZF1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09PSAwKSB7XG4gICAgZG9jRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciwgZmFsc2UpXG4gICAgZG9jRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyLCBmYWxzZSlcbiAgfVxufVxuXG4vKipcbiAqIGhhbmRsZSB0b3VjaGNhbmNlbFxuICpcbiAqIDEuIGlmIHRoZXJlIGFyZSB0d28gdG91Y2ggcG9pbnRzLCB0aGVuIHRyaWdnZXIgJ2R1YWx0b3VjaGVuZCdcbiAqXG4gKiAyLiB0cmF2ZXJzZSBldmVydHkgdG91Y2ggcG9pbnQ6XG4gKiA+IGlmIHBhbm5uaWcsIHRoZW4gdHJpZ2dlciAncGFuZW5kJ1xuICogPiBpZiBwcmVzc2luZywgdGhlbiB0cmlnZ2VyICdwcmVzc2VuZCdcbiAqXG4gKiAzLiByZW1vdmUgbGlzdGVuZXJzXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGV2ZW50KSB7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT0gMikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaGVuZCcsIHtcbiAgICAgIHRvdWNoZXM6IHNsaWNlLmNhbGwoZXZlbnQudG91Y2hlcyksXG4gICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV1cbiAgICB2YXIgaWQgPSB0b3VjaC5pZGVudGlmaWVyXG4gICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1tpZF1cblxuICAgIGlmICghZ2VzdHVyZSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChnZXN0dXJlLnByZXNzaW5nSGFuZGxlcilcbiAgICAgIGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3Bhbm5pbmcnKSB7XG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFuZW5kJywge1xuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3ByZXNzaW5nJykge1xuICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ3ByZXNzZW5kJywge1xuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgICB9KVxuICAgIH1cbiAgICBkZWxldGUgZ2VzdHVyZXNbaWRdXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciwgZmFsc2UpXG4gIH1cbn1cblxuaWYgKCFpc0luaXRpYWxpemVkKSB7XG4gIGRvY0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciwgZmFsc2UpXG4gIGlzSW5pdGlhbGl6ZWQgPSB0cnVlXG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvZ2VzdHVyZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9kb20vY29tcG9uZW50TWFuYWdlcidcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vcmVuZGVyL2NvbmZpZydcblxuZnVuY3Rpb24gZGV0ZWN0Um9vdEhlaWdodCAocm9vdCkge1xuICBjb25zdCByb290UXVlcnkgPSAnIycgKyByb290LmdldFdlZXhJbnN0YW5jZSgpLnJvb3RJZFxuICBjb25zdCByb290Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290UXVlcnkpIHx8IGRvY3VtZW50LmJvZHlcbiAgY29uc3QgaGVpZ2h0ID0gcm9vdENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgaWYgKGhlaWdodCA+IGdsb2JhbC5pbm5lckhlaWdodCkge1xuICAgIGNvbnNvbGUud2FybihbXG4gICAgICAnW2g1LXJlbmRlcl0gZm9yIHNjcm9sbGFibGUgcm9vdCBsaWtlIFxcJ2xpc3RcXCcgYW5kIFxcJ3Njcm9sbGVyXFwnLCB0aGUgaGVpZ2h0IG9mICcsXG4gICAgICAndGhlIHJvb3QgY29udGFpbmVyIG11c3QgYmUgYSB1c2VyLXNwZWNpZmllZCB2YWx1ZS4gT3RoZXJ3aXNlICcsXG4gICAgICAndGhlIHNjcm9sbGFibGUgZWxlbWVudCBtYXkgbm90IGJlIGFibGUgdG8gd29yayBjb3JyZWN0bHkuICcsXG4gICAgICAnQ3VycmVudCBoZWlnaHQgb2YgdGhlIHJvb3QgZWxlbWVudCBcXCcnICsgcm9vdFF1ZXJ5ICsgJ1xcJyBpcyAnLFxuICAgICAgaGVpZ2h0ICsgJ3B4LCBhbmQgbW9zdGx5IGl0cyBoZWlnaHQgc2hvdWxkIGJlIGxlc3MgdGhhbiB0aGUgJyxcbiAgICAgICd2aWV3cG9ydFxcJ3MgaGVpZ2h0ICcgKyBnbG9iYWwuaW5uZXJIZWlnaHQgKyAncHguIFBsZWFzZSAnLFxuICAgICAgJ21ha2Ugc3VyZSB0aGUgaGVpZ2h0IGlzIGNvcnJlY3QuJ1xuICAgIF0uam9pbignJykpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBDb21wb25lbnQgPSBXZWV4LkNvbXBvbmVudFxuXG4gIGZ1bmN0aW9uIFJvb3RDb21wb25lbnQgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgY29uc3QgaWQgPSBkYXRhLnJvb3RJZCArICctcm9vdCdcbiAgICBjb25zdCBjbSA9IENvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoZGF0YS5pbnN0YW5jZUlkKVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuXG4gICAgLy8gSW4gc29tZSBzaXR1YXRpb24gdGhlIHJvb3QgY29tcG9uZW50IHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhc1xuICAgIC8vIGl0cyBvd24gdHlwZSwgb3RoZXJ3aXNlIGl0IGhhcyB0byBiZSBhIGRpdiBjb21wb25lbnQgYXMgYSByb290LlxuICAgIGlmICghbm9kZVR5cGUpIHtcbiAgICAgIG5vZGVUeXBlID0gJ2RpdidcbiAgICB9XG4gICAgZWxzZSBpZiAoY29uZmlnLnZhbGlkUm9vdHMuaW5kZXhPZihub2RlVHlwZSkgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIHRoZSByb290IGNvbXBvbmVudCB0eXBlIFxcJycgKyBub2RlVHlwZSArICdcXCcgaXMgbm90IG9uZSBvZiAnXG4gICAgICAgICsgJ3RoZSB0eXBlcyBpbiBbJyArIGNvbmZpZy52YWxpZFJvb3RzICsgJ10gbGlzdC4gSXQgaXMgYXV0byBkb3duZ3JhZGVkICdcbiAgICAgICAgKyAndG8gXFwnZGl2XFwnLicpXG4gICAgICBub2RlVHlwZSA9ICdkaXYnXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCFnbG9iYWwud2VleC5nZXRJbnN0YW5jZShkYXRhLmluc3RhbmNlSWQpLmVtYmVkKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXJlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGV0ZWN0Um9vdEhlaWdodCh0aGlzKVxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgICAhdGhpcy5kYXRhLnN0eWxlLmhlaWdodCAmJiAodGhpcy5kYXRhLnN0eWxlLmhlaWdodCA9ICcxMDAlJylcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBub2RlVHlwZVxuICAgIGNvbnN0IGNtcCA9IGNtLmNyZWF0ZUVsZW1lbnQoZGF0YSlcbiAgICBjbXAubm9kZS5pZCA9IGlkXG4gICAgcmV0dXJuIGNtcFxuICB9XG5cbiAgUm9vdENvbXBvbmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgncm9vdCcsIFJvb3RDb21wb25lbnQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9yb290LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcblxuICBmdW5jdGlvbiBEaXYgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSwgbm9kZVR5cGUpXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJylcbiAgfVxuICBEaXYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2RpdicsIERpdilcbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnY29udGFpbmVyJywgRGl2KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2Jhc2UvZGl2LmpzXG4gKiovIiwiaW1wb3J0IEltYWdlIGZyb20gJy4vaW1hZ2UnXG5pbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnXG4vLyBpbXBvcnQgVmxpc3QgZnJvbSAnLi92bGlzdCdcbi8vIGltcG9ydCBIbGlzdCBmcm9tICcuL2hsaXN0J1xuaW1wb3J0IFNjcm9sbGFibGUgZnJvbSAnLi9zY3JvbGxhYmxlJyAgIC8vIFRPRE9cbi8vIGltcG9ydCBDb3VudGRvd24gZnJvbSAnLi9jb3VudGRvd24nXG4vLyBpbXBvcnQgTWFycXVlZSBmcm9tICcuL21hcnF1ZWUnXG5pbXBvcnQgU2xpZGVyIGZyb20gJy4vc2xpZGVyJ1xuaW1wb3J0IEluZGljYXRvciBmcm9tICcuL2luZGljYXRvcidcbmltcG9ydCBUYWJoZWFkZXIgZnJvbSAnLi90YWJoZWFkZXInICAgICAvLyBUT0RPXG4vLyBpbXBvcnQgU2Nyb2xsZXIgZnJvbSAnLi9zY3JvbGxlcidcbmltcG9ydCBJbnB1dCBmcm9tICcuL2lucHV0J1xuLy8gaW1wb3J0IFNlbGVjdCBmcm9tICcuL3NlbGVjdCdcbi8vIGltcG9ydCBEYXRlcGlja2VyIGZyb20gJy4vZGF0ZXBpY2tlcidcbi8vIGltcG9ydCBUaW1lcGlja2VyIGZyb20gJy4vdGltZXBpY2tlcidcbmltcG9ydCBWaWRlbyBmcm9tICcuL3ZpZGVvJ1xuaW1wb3J0IFN3aXRjaCBmcm9tICcuL3N3aXRjaCdcbmltcG9ydCBBIGZyb20gJy4vYSdcbmltcG9ydCBFbWJlZCBmcm9tICcuL2VtYmVkJ1xuLy8gaW1wb3J0IFJlZnJlc2ggZnJvbSAnLi9yZWZyZXNoJ1xuLy8gaW1wb3J0IExvYWRpbmcgZnJvbSAnLi9sb2FkaW5nJ1xuaW1wb3J0IFNwaW5uZXIgZnJvbSAnLi9zcGlubmVyJ1xuaW1wb3J0IFdlYiBmcm9tICcuL3dlYidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXguaW5zdGFsbChJbWFnZSlcbiAgICBXZWV4Lmluc3RhbGwoVGV4dClcbiAgICBXZWV4Lmluc3RhbGwoU2Nyb2xsYWJsZSkgICAgLy8gVE9ET1xuICAgIC8vIFdlZXguaW5zdGFsbChDb3VudGRvd24pXG4gICAgLy8gV2VleC5pbnN0YWxsKE1hcnF1ZWUpXG4gICAgV2VleC5pbnN0YWxsKFNsaWRlcilcbiAgICBXZWV4Lmluc3RhbGwoSW5kaWNhdG9yKVxuICAgIFdlZXguaW5zdGFsbChUYWJoZWFkZXIpICAgICAvLyBUT0RPXG4gICAgV2VleC5pbnN0YWxsKElucHV0KVxuICAgIC8vIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2xpc3QnLCBWbGlzdClcbiAgICAvLyBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCd2bGlzdCcsIFZsaXN0KVxuICAgIC8vIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2hsaXN0JywgSGxpc3QpXG4gICAgLy8gV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc2Nyb2xsZXInLCBTY3JvbGxlcilcbiAgICAvLyBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzZWxlY3QnLCBTZWxlY3QpXG4gICAgLy8gV2VleC5yZWdpc3RlckNvbXBvbmVudCgnZGF0ZXBpY2tlcicsIERhdGVwaWNrZXIpXG4gICAgLy8gV2VleC5yZWdpc3RlckNvbXBvbmVudCgndGltZXBpY2tlcicsIFRpbWVwaWNrZXIpXG4gICAgV2VleC5pbnN0YWxsKFZpZGVvKVxuICAgIFdlZXguaW5zdGFsbChTd2l0Y2gpXG4gICAgV2VleC5pbnN0YWxsKEEpXG4gICAgV2VleC5pbnN0YWxsKEVtYmVkKVxuICAgIC8vIFdlZXguaW5zdGFsbChSZWZyZXNoKVxuICAgIC8vIFdlZXguaW5zdGFsbChMb2FkaW5nKVxuICAgIFdlZXguaW5zdGFsbChTcGlubmVyKVxuICAgIFdlZXguaW5zdGFsbChXZWIpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbmRleC5qc1xuICoqLyIsIi8qIGdsb2JhbCBsaWIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAnLi9pbWFnZS5jc3MnXG5cbmNvbnN0IERFRkFVTFRfU0laRSA9IDIwMFxuY29uc3QgUkVTSVpFX01PREVTID0gWydzdHJldGNoJywgJ2NvdmVyJywgJ2NvbnRhaW4nXVxuY29uc3QgREVGQVVMVF9SRVNJWkVfTU9ERSA9ICdzdHJldGNoJ1xuXG4vKipcbiAqIHJlc2l6ZTogJ2NvdmVyJyB8ICdjb250YWluJyB8ICdzdHJldGNoJywgZGVmYXVsdCBpcyAnc3RyZXRjaCdcbiAqIHNyYzogdXJsXG4gKi9cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1pbWcnLCAnd2VleC1lbGVtZW50JylcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIGNsZWFyQXR0ciAoKSB7XG4gICAgdGhpcy5zcmMgPSAnJ1xuICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJ1xuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIHNyYzogZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICghdGhpcy5zcmMpIHtcbiAgICAgIHRoaXMuc3JjID0gbGliLmltZy5kZWZhdWx0U3JjXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgdGhpcy5zcmMgKyAnKSdcbiAgICB9XG4gICAgdGhpcy5lbmFibGVMYXp5bG9hZCh2YWwpXG4gIH0sXG5cbiAgcmVzaXplOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKFJFU0laRV9NT0RFUy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICB2YWwgPSAnc3RyZXRjaCdcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRTaXplID0gdmFsID09PSAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzEwMCUgMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsXG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIHdpZHRoOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpICogdGhpcy5kYXRhLnNjYWxlXG4gICAgaWYgKHZhbCA8IDAgfHwgaXNOYU4odmFsKSkge1xuICAgICAgdmFsID0gREVGQVVMVF9TSVpFXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS53aWR0aCA9IHZhbCArICdweCdcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICBpZiAodmFsIDwgMCB8fCBpc05hTih2YWwpKSB7XG4gICAgICB2YWwgPSBERUZBVUxUX1NJWkVcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLmhlaWdodCA9IHZhbCArICdweCdcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgZnVuY3Rpb24gSW1hZ2UgKGRhdGEpIHtcbiAgICB0aGlzLnJlc2l6ZSA9IERFRkFVTFRfUkVTSVpFX01PREVcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIEltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKEltYWdlLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChJbWFnZS5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoSW1hZ2UucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdpbWFnZScsIEltYWdlKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2ltYWdlL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbWFnZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbWFnZS9pbWFnZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtaW1nIHtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDUwJTtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW1hZ2UvaW1hZ2UuY3NzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMlxuY29uc3QgREVGQVVMVF9URVhUX09WRVJGTE9XID0gJ2VsbGlwc2lzJ1xuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJylcbiAgICBub2RlLnN0eWxlLmZvbnRTaXplID0gREVGQVVMVF9GT05UX1NJWkUgKiB0aGlzLmRhdGEuc2NhbGUgKyAncHgnXG4gICAgdGhpcy50ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIC8vIEdpdmUgdGhlIGRldmVsb3BlcnMgdGhlIGFiaWxpdHkgdG8gY29udHJvbCBzcGFjZVxuICAgIC8vIGFuZCBsaW5lLWJyZWFrZXJzLlxuICAgIHRoaXMudGV4dE5vZGUuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCdcbiAgICB0aGlzLnRleHROb2RlLnN0eWxlLndvcmRXcmFwID0gJ2JyZWFrLXdvcmQnXG4gICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS5kaXNwbGF5ID0gJy13ZWJraXQtYm94J1xuICAgIHRoaXMudGV4dE5vZGUuc3R5bGUud2Via2l0Qm94T3JpZW50ID0gJ3ZlcnRpY2FsJ1xuICAgIHRoaXMuc3R5bGUubGluZXMuY2FsbCh0aGlzLCB0aGlzLmRhdGEuc3R5bGUubGluZXMpXG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlKVxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgY2xlYXJBdHRyICgpIHtcbiAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9ICcnXG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGNvbnN0IHNwYW4gPSB0aGlzLm5vZGUuZmlyc3RDaGlsZFxuICAgIHNwYW4uaW5uZXJIVE1MID0gJydcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzcGFuLnRleHRDb250ZW50ID0gdmFsdWVcbiAgICAvKipcbiAgICAgKiBEZXZlbG9wZXJzIGFyZSBzdXBwb3NlZCB0byBoYXZlIHRoZSBhYmlsaXR5IHRvIGJyZWFrIHRleHRcbiAgICAgKiBsaW5lcyBtYW51YWxseS4gVXNpbmcgYGAmbmJzcDtgYCB0byByZXBsYWNlIHRleHQgc3BhY2UgaXNcbiAgICAgKiBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBgYC13ZWJraXQtbGluZS1jbGFtcGBgLiBUaGVyZWZvclxuICAgICAqIHdlIHVzZSBgYHdoaXRlLXNwYWNlOiBuby13cmFwYGAgaW5zdGVhZCAoaW5zdGVhZCBvZiB0aGVcbiAgICAgKiBjb2RlIGJlbGxvdykuXG5cbiAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICAgICAgdGV4dC5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpXG4gICAgICAgICAgY29uc3Qgc3BhY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJylcbiAgICAgICAgICBzcGFjZS5pbm5lckhUTUwgPSAnJm5ic3A7J1xuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoc3BhY2UpXG4gICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgICAgICAgfSlcbiAgICAgICAgZnJhZy5yZW1vdmVDaGlsZChmcmFnLmZpcnN0Q2hpbGQpXG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSlcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChmcmFnKVxuICAgICAgfSlcbiAgICAgIHNwYW4ucmVtb3ZlQ2hpbGQoc3Bhbi5maXJzdENoaWxkKVxuICAgICAqL1xuICB9XG59XG5cbmNvbnN0IHN0eWxlID0ge1xuICBsaW5lczogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlSW50KHZhbClcbiAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS50ZXh0T3ZlcmZsb3cgPSAnJ1xuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJ1xuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS53ZWJraXRMaW5lQ2xhbXAgPSAnJ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kYXRhID8gdGhpcy5kYXRhLnN0eWxlIDogbnVsbFxuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgICB0aGlzLnRleHROb2RlLnN0eWxlLnRleHRPdmVyZmxvdyA9IHN0eWxlXG4gICAgICAgID8gc3R5bGUudGV4dE92ZXJmbG93XG4gICAgICAgIDogREVGQVVMVF9URVhUX09WRVJGTE9XXG4gICAgICB0aGlzLnRleHROb2RlLnN0eWxlLndlYmtpdExpbmVDbGFtcCA9IHZhbFxuICAgIH1cbiAgfSxcblxuICB0ZXh0T3ZlcmZsb3c6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnRleHROb2RlLnN0eWxlLnRleHRPdmVyZmxvdyA9IHZhbFxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICAvLyBhdHRyXG4gIC8vICAtIHZhbHVlOiB0ZXh0IGNvbnRlbnQuXG4gIC8vIHN0eWxlXG4gIC8vICAtIGxpbmVzOiBtYXhpbXVtIGxpbmVzIG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBUZXh0IChkYXRhKSB7XG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKFRleHQucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7IGF0dHIgfSlcbiAgZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCd0ZXh0JywgVGV4dClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy90ZXh0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBsaXN0IGZyb20gJy4vbGlzdCdcbmltcG9ydCBzY3JvbGxlciBmcm9tICcuL3Njcm9sbGVyJ1xuaW1wb3J0IHJlZnJlc2ggZnJvbSAnLi9yZWZyZXNoJ1xuaW1wb3J0IGxvYWRpbmcgZnJvbSAnLi9sb2FkaW5nJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5pbnN0YWxsKGxpc3QpXG4gICAgV2VleC5pbnN0YWxsKHNjcm9sbGVyKVxuICAgIFdlZXguaW5zdGFsbChyZWZyZXNoKVxuICAgIFdlZXguaW5zdGFsbChsb2FkaW5nKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgVmxpc3QgZnJvbSAnLi92bGlzdCdcbmltcG9ydCBIbGlzdCBmcm9tICcuL2hsaXN0J1xuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIFdlZXguaW5zdGFsbChWbGlzdClcbiAgV2VleC5pbnN0YWxsKEhsaXN0KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgbGlzdE1vZHVsZSBmcm9tICcuL2xpc3QnXG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgTGlzdCA9IGxpc3RNb2R1bGUuaW5pdChXZWV4KVxuXG4gIGZ1bmN0aW9uIFZsaXN0IChkYXRhLCBub2RlVHlwZSkge1xuICAgIGRhdGEuYXR0ci5kaXJlY3Rpb24gPSAndidcbiAgICBMaXN0LmNhbGwodGhpcywgZGF0YSwgbm9kZVR5cGUpXG4gIH1cbiAgVmxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaXN0LnByb3RvdHlwZSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdsaXN0JywgVmxpc3QpXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3ZsaXN0JywgVmxpc3QpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9saXN0L3ZsaXN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBzY3JvbGxhYmxlTW9kdWxlIGZyb20gJy4uL3Njcm9sbGFibGUnXG5cbmNvbnN0IGF2YWlsYWJsZUNoaWxkcmVuVHlwZXMgPSBbJ2NlbGwnLCAnbG9hZGluZycsICdyZWZyZXNoJ11cblxuZnVuY3Rpb24gZ2V0UHJvdG8gKFNjcm9sbGFibGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUgKCkge1xuICAgICAgY29uc3Qgbm9kZSA9IFNjcm9sbGFibGUucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMpXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2xpc3Qtd3JhcCcpXG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGlzdC1lbGVtZW50JylcbiAgICAgIHJldHVybiBub2RlXG4gICAgfSxcblxuICAgIGNyZWF0ZUNoaWxkcmVuICgpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuIHx8IFtdXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLnR5cGVcbiAgICAgICAgaWYgKGF2YWlsYWJsZUNoaWxkcmVuVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ1toNS1yZW5kZXJdIGludmFsaWQgY2hpbGQgdHlwZSBcIidcbiAgICAgICAgICAvLyAgICsgdHlwZSArICdcIiBmb3IgbGlzdC4nKVxuICAgICAgICAgIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gaW52YWxpZCBjaGlsZCB0eXBlIFwiJ1xuICAgICAgICAgICAgKyB0eXBlICsgJ1wiIGZvciBsaXN0LicpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gU2Nyb2xsYWJsZS5wcm90b3R5cGUuY3JlYXRlQ2hpbGRyZW4uY2FsbCh0aGlzKVxuICAgIH0sXG5cbiAgICBhcHBlbmRDaGlsZCAoZGF0YSkge1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGEudHlwZVxuICAgICAgaWYgKGF2YWlsYWJsZUNoaWxkcmVuVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGNoaWxkIHR5cGUgXCInXG4gICAgICAgIC8vICAgKyB0eXBlICsgJ1wiIGZvciBsaXN0LicpXG4gICAgICAgIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gaW52YWxpZCBjaGlsZCB0eXBlIFwiJ1xuICAgICAgICAgICsgdHlwZSArICdcIiBmb3IgbGlzdC4nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFNjcm9sbGFibGUucHJvdG90eXBlLmFwcGVuZENoaWxkLmNhbGwodGhpcywgZGF0YSlcbiAgICB9LFxuXG4gICAgaW5zZXJ0QmVmb3JlIChjaGlsZCwgYmVmb3JlKSB7XG4gICAgICBjb25zdCB0eXBlID0gY2hpbGQuZGF0YS50eXBlXG4gICAgICBpZiAoYXZhaWxhYmxlQ2hpbGRyZW5UeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ1toNS1yZW5kZXJdIGludmFsaWQgY2hpbGQgdHlwZSBcIidcbiAgICAgICAgLy8gICArIHR5cGUgKyAnXCIgZm9yIGxpc3QuJylcbiAgICAgICAgY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGNoaWxkIHR5cGUgXCInXG4gICAgICAgICAgKyB0eXBlICsgJ1wiIGZvciBsaXN0LicpXG4gICAgICB9XG4gICAgICByZXR1cm4gU2Nyb2xsYWJsZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgY2hpbGQsIGJlZm9yZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBTY3JvbGxhYmxlID0gc2Nyb2xsYWJsZU1vZHVsZS5pbml0KFdlZXgpXG4gIGZ1bmN0aW9uIExpc3QgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgU2Nyb2xsYWJsZS5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjcm9sbGFibGUucHJvdG90eXBlKVxuICBleHRlbmQoTGlzdC5wcm90b3R5cGUsIGdldFByb3RvKFNjcm9sbGFibGUpKVxuXG4gIHJldHVybiBMaXN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9saXN0L2xpc3QuanNcbiAqKi8iLCIvKiBnbG9iYWwgbGliICovXG5cbid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuL3Njcm9sbGFibGUuY3NzJylcbnJlcXVpcmUoJy4vc2Nyb2xsJylcblxuLy8gbGliLnNjcm9sbCBldmVudHM6XG4vLyAgLSBzY3JvbGxzdGFydFxuLy8gIC0gc2Nyb2xsaW5nXG4vLyAgLSBwdWxsZG93bmVuZFxuLy8gIC0gcHVsbHVwZW5kXG4vLyAgLSBwdWxsbGVmdGVuZFxuLy8gIC0gcHVsbHJpZ2h0ZW5kXG4vLyAgLSBwdWxsZG93blxuLy8gIC0gcHVsbHVwXG4vLyAgLSBwdWxsbGVmdFxuLy8gIC0gcHVsbHJpZ2h0XG4vLyAgLSBjb250ZW50cmVmcmVzaFxuXG5jb25zdCBkaXJlY3Rpb25NYXAgPSB7XG4gIGg6IFsncm93JywgJ2hvcml6b250YWwnLCAnaCcsICd4J10sXG4gIHY6IFsnY29sdW1uJywgJ3ZlcnRpY2FsJywgJ3YnLCAneSddXG59XG5cbmNvbnN0IERFRkFVTFRfRElSRUNUSU9OID0gJ2NvbHVtbidcbmNvbnN0IERFRkFVTFRfTE9BRF9NT1JFX09GRlNFVCA9IDBcblxuZnVuY3Rpb24gcmVmcmVzaFdoZW5Eb21SZW5kZXJlbmQgKGNvbXApIHtcbiAgaWYgKCFjb21wLnJlbmRlcmVuZEhhbmRsZXIpIHtcbiAgICBjb21wLnJlbmRlcmVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb21wLnNjcm9sbGVyLnJlZnJlc2goKVxuICAgIH1cbiAgfVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyZW5kJywgY29tcC5yZW5kZXJlbmRIYW5kbGVyKVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudHMgKGNvbXApIHtcbiAgaWYgKGNvbXAucmVuZGVyZW5kSGFuZGxlcikge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW5kZXJlbmQnLCBjb21wLnJlbmRlcmVuZEhhbmRsZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG8gKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcblxuICBmdW5jdGlvbiBjcmVhdGUgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgU2Nyb2xsID0gbGliLnNjcm9sbFxuICAgIGNvbnN0IG5vZGUgPSBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIG5vZGVUeXBlKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnc2Nyb2xsYWJsZS13cmFwJylcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QuYWRkKFxuICAgICAgJ3dlZXgtY29udGFpbmVyJyxcbiAgICAgICdzY3JvbGxhYmxlLWVsZW1lbnQnLFxuICAgICAgJ2Rpci0nICsgdGhpcy5kaXJlY3Rpb25cbiAgICApXG5cbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQuc3R5bGUud2Via2l0Qm94T3JpZW50ID0gZGlyZWN0aW9uTWFwW3RoaXMuZGlyZWN0aW9uXVsxXVxuICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5zdHlsZS53ZWJraXRGbGV4RGlyZWN0aW9uID0gZGlyZWN0aW9uTWFwW3RoaXMuZGlyZWN0aW9uXVswXVxuICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5zdHlsZS5mbGV4RGlyZWN0aW9uID0gZGlyZWN0aW9uTWFwW3RoaXMuZGlyZWN0aW9uXVswXVxuXG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbEVsZW1lbnQpXG4gICAgdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGwoe1xuICAgICAgLy8gaWYgdGhlIGRpcmVjdGlvbiBpcyB4LCB0aGVuIHRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBzY3JvbGwgZWxlbWVudFxuICAgICAgLy8gc2hvdWxkIGJlIGdvdCBieSB0aGUgJ1JhbmdlJyBBUEkgb3RoZXIgdGhhbiB0aGUgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCdcbiAgICAgIC8vIEFQSSwgYmVjYXVzZSB0aGUgd2lkdGggb3V0c2lkZSB0aGUgdmlld3BvcnQgd29uJ3QgYmUgY291bnQgaW4gYnlcbiAgICAgIC8vICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnLlxuICAgICAgLy8gT3RoZXJ3aXNlIHNob3VsZCB1c2UgdGhlIGVsZW1lbnQgcmVjdCBpbiBjYXNlIHRoZXJlIGlzIGEgY2hpbGQgc2Nyb2xsZXJcbiAgICAgIC8vIG9yIGxpc3QgaW4gdGhpcyBzY3JvbGxlci4gSWYgdXNpbmcgJ1JhbmdlJywgdGhlIHdob2xlIHNjcm9sbCBlbGVtZW50XG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGhpZGluZyBwYXJ0IHdpbGwgYmUgY291bnQgaW4gdGhlIHJlY3QuXG4gICAgICB1c2VFbGVtZW50UmVjdDogdGhpcy5kaXJlY3Rpb24gPT09ICd2JyxcbiAgICAgIHNjcm9sbEVsZW1lbnQ6IHRoaXMuc2Nyb2xsRWxlbWVudCxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24gPT09ICdoJyA/ICd4JyA6ICd5J1xuICAgIH0pXG4gICAgdGhpcy5zY3JvbGxlci5pbml0KClcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgY29uc3QgcGFyZW50UmVmID0gdGhpcy5kYXRhLnJlZlxuICAgIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICBsZXQgaXNGbGV4ID0gZmFsc2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uaW5zdGFuY2VJZCA9IHRoaXMuZGF0YS5pbnN0YW5jZUlkXG4gICAgICAgIGNoaWxkcmVuW2ldLnNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldKVxuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAgICAgICBjaGlsZC5wYXJlbnRSZWYgPSBwYXJlbnRSZWZcbiAgICAgICAgaWYgKCFpc0ZsZXhcbiAgICAgICAgICAgICYmIGNoaWxkLmRhdGEuc3R5bGVcbiAgICAgICAgICAgICYmIGNoaWxkLmRhdGEuc3R5bGUuaGFzT3duUHJvcGVydHkoJ2ZsZXgnKVxuICAgICAgICAgICkge1xuICAgICAgICAgIGlzRmxleCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICAgIH1cbiAgICAvLyB3YWl0IGZvciBmcmFnbWVudCB0byBhcHBlbmRlZCBvbiBzY3JvbGxFbGVtZW50IG9uIFVJIHRocmVhZC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gICAgfS5iaW5kKHRoaXMpLCAwKVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKGRhdGEpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICAgIGNvbnN0IGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGRhdGEpXG4gICAgdGhpcy5zY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG5cbiAgICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zY3JvbGxlci5yZWZyZXNoKClcbiAgICB9LmJpbmQodGhpcyksIDApXG5cbiAgICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRhdGEuY2hpbGRyZW4gPSBbZGF0YV1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGRhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkXG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUgKGNoaWxkLCBiZWZvcmUpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGxldCBpID0gMFxuICAgIGxldCBpc0FwcGVuZCA9IGZhbHNlXG5cbiAgICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8ICFiZWZvcmUpIHtcbiAgICAgIGlzQXBwZW5kID0gdHJ1ZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBsXG4gICAgICBmb3IgKGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gYmVmb3JlLmRhdGEucmVmKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IGwpIHtcbiAgICAgICAgaXNBcHBlbmQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXBwZW5kKSB7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuZGF0YSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCByZWZyZXNoTG9hZGluZ1BsYWNlaG9sZGVyID0gYmVmb3JlLnJlZnJlc2hQbGFjZWhvbGRlclxuICAgICAgICB8fCBiZWZvcmUubG9hZGluZ1BsYWNlaG9sZGVyXG4gICAgICBpZiAocmVmcmVzaExvYWRpbmdQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIHJlZnJlc2hMb2FkaW5nUGxhY2Vob2xkZXIpXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiZWZvcmUuZml4ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmVmb3JlLnN0aWNreVBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLnN0aWNreVBsYWNlaG9sZGVyKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLm5vZGUpXG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMCwgY2hpbGQuZGF0YSlcbiAgICB9XG5cbiAgICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zY3JvbGxlci5yZWZyZXNoKClcbiAgICB9LmJpbmQodGhpcyksIDApXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIC8vIHJlbW92ZSBmcm9tIHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGxldCBpID0gMFxuICAgIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGxldCBsXG4gICAgICBmb3IgKGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gY2hpbGQuZGF0YS5yZWYpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA8IGwpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlbW92ZSBmcm9tIGNvbXBvbmVudE1hcCByZWN1cnNpdmVseVxuICAgIGNvbXBvbmVudE1hbmFnZXIucmVtb3ZlQ29tcG9uZW50KGNoaWxkLmRhdGEucmVmKVxuICAgIGNvbnN0IHJlZnJlc2hMb2FkaW5nUGxhY2Vob2xkZXIgPSBjaGlsZC5yZWZyZXNoUGxhY2Vob2xkZXJcbiAgICAgIHx8IGNoaWxkLmxvYWRpbmdQbGFjZWhvbGRlclxuICAgIGNoaWxkLnVuc2V0UG9zaXRpb24oKVxuICAgIGlmIChyZWZyZXNoTG9hZGluZ1BsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQucmVtb3ZlQ2hpbGQocmVmcmVzaExvYWRpbmdQbGFjZWhvbGRlcilcbiAgICB9XG4gICAgY2hpbGQubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkLm5vZGUpXG5cbiAgICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zY3JvbGxlci5yZWZyZXNoKClcbiAgICB9LmJpbmQodGhpcyksIDApXG4gIH1cblxuICBmdW5jdGlvbiBiaW5kRXZlbnRzIChldnRzKSB7XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcbiAgICAvLyB0byBlbmFibGUgbGF6eWxvYWQgZm9yIEltYWdlc1xuICAgIHRoaXMuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsaW5nJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNvbnN0IHNvID0gZS5zY3JvbGxPYmpcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNvLmdldFNjcm9sbFRvcCgpXG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gc28uZ2V0U2Nyb2xsTGVmdCgpXG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3YnID8gc2Nyb2xsVG9wIDogc2Nyb2xsTGVmdFxuICAgICAgY29uc3QgZGlmZiA9IG9mZnNldCAtIHRoaXMub2Zmc2V0XG4gICAgICBsZXQgZGlyXG4gICAgICBpZiAoZGlmZiA+PSAwKSB7XG4gICAgICAgIGRpciA9IHRoaXMuZGlyZWN0aW9uID09PSAndicgPyAndXAnIDogJ2xlZnQnXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGlyID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2JyA/ICdkb3duJyA6ICdyaWdodCdcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnc2Nyb2xsJywge1xuICAgICAgICBvcmlnaW5hbFR5cGU6ICdzY3JvbGxpbmcnLFxuICAgICAgICBzY3JvbGxUb3A6IHNvLmdldFNjcm9sbFRvcCgpLFxuICAgICAgICBzY3JvbGxMZWZ0OiBzby5nZXRTY3JvbGxMZWZ0KCksXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBkaXJlY3Rpb246IGRpclxuICAgICAgfSwge1xuICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICB9KVxuICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcblxuICAgICAgLy8gZmlyZSBsb2FkbW9yZSBldmVudC5cbiAgICAgIGNvbnN0IGxlZnREaXN0ID0gTWF0aC5hYnMoc28ubWF4U2Nyb2xsT2Zmc2V0KSAtIHRoaXMub2Zmc2V0XG4gICAgICBpZiAobGVmdERpc3QgPD0gdGhpcy5sb2FkbW9yZW9mZnNldCAmJiB0aGlzLmlzQXZhaWxhYmxlVG9GaXJlbG9hZG1vcmUpIHtcbiAgICAgICAgdGhpcy5pc0F2YWlsYWJsZVRvRmlyZWxvYWRtb3JlID0gZmFsc2VcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdsb2FkbW9yZScpXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZWZ0RGlzdCA+IHRoaXMubG9hZG1vcmVvZmZzZXQgJiYgIXRoaXMuaXNBdmFpbGFibGVUb0ZpcmVsb2FkbW9yZSkge1xuICAgICAgICB0aGlzLmlzQXZhaWxhYmxlVG9GaXJlbG9hZG1vcmUgPSB0cnVlXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKVxuICB9XG5cbiAgZnVuY3Rpb24gb25BcHBlbmQgKCkge1xuICAgIHJlZnJlc2hXaGVuRG9tUmVuZGVyZW5kKHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBvblJlbW92ZSAoKSB7XG4gICAgcmVtb3ZlRXZlbnRzKHRoaXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZSxcbiAgICBjcmVhdGVDaGlsZHJlbixcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQsXG4gICAgYmluZEV2ZW50cyxcbiAgICBvbkFwcGVuZCxcbiAgICBvblJlbW92ZVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIGxvYWRtb3Jlb2Zmc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpXG4gICAgaWYgKHZhbCA8IDAgfHwgaXNOYU4odmFsKSkge1xuICAgICAgY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSBpbnZhbGlkYScpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5sb2FkbW9yZW9mZnNldCA9IHZhbFxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICAvLyBhdHRyczpcbiAgLy8gIC0gbG9hZG1vcmVvZmZzZXQ6IHVwZGF0YWJsZVxuICAvLyAgLSBzY3JvbGwtZGlyZWNpdG9uOiBub25lfHZlcnRpY2FsfGhvcml6b250YWwgKGRlZmF1bHQgaXMgdmVydGljYWwpXG4gIC8vICAtIHNob3ctc2Nyb2xsYmFyOiB0cnVlfGZhbHNlIChkZWZhdWx0IGlzIHRydWUpXG4gIGZ1bmN0aW9uIFNjcm9sbGFibGUgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgdGhpcy5sb2FkbW9yZW9mZnNldCA9IERFRkFVTFRfTE9BRF9NT1JFX09GRlNFVFxuICAgIHRoaXMuaXNBdmFpbGFibGVUb0ZpcmVsb2FkbW9yZSA9IHRydWVcbiAgICBjb25zdCBhdHRycyA9IGRhdGEuYXR0ciB8fCB7fVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGF0dHJzLnNjcm9sbERpcmVjdGlvblxuICAgICAgfHwgYXR0cnMuZGlyZWN0aW9uXG4gICAgICB8fCBERUZBVUxUX0RJUkVDVElPTlxuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uTWFwLmguaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMVxuICAgICAgPyAndidcbiAgICAgIDogJ2gnXG4gICAgdGhpcy5zaG93U2Nyb2xsYmFyID0gYXR0cnMuc2hvd1Njcm9sbGJhciB8fCB0cnVlXG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSwgbm9kZVR5cGUpXG4gIH1cbiAgU2Nyb2xsYWJsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChTY3JvbGxhYmxlLnByb3RvdHlwZSwgZ2V0UHJvdG8oV2VleCkpXG4gIGV4dGVuZChTY3JvbGxhYmxlLnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIHJldHVybiBTY3JvbGxhYmxlXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zY3JvbGxhYmxlLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zY3JvbGxhYmxlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3Njcm9sbGFibGUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbGFibGUuY3NzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5zY3JvbGxhYmxlLXdyYXAge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uc2Nyb2xsYWJsZS1lbGVtZW50Lmhvcml6b250YWwge1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuLnNjcm9sbGFibGUtZWxlbWVudC52ZXJ0aWNhbCB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxucmVxdWlyZSgnLi9tb3Rpb24nKVxuXG52YXIgZG9jID0gd2luZG93LmRvY3VtZW50XG52YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxudmFyIHNjcm9sbE9ianMgPSB7fVxudmFyIHBsdWdpbnMgPSB7fVxudmFyIGRwciA9IHdpbmRvdy5kcHJcbiAgfHwgKCEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvKVxuICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC8gd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoXG4gICAgOiAxKVxudmFyIGluZXJ0aWFDb2VmZmljaWVudCA9IHtcbiAgbm9ybWFsOiBbMiAqIGRwciwgMC4wMDE1ICogZHByXSxcbiAgc2xvdzogWzEuNSAqIGRwciwgMC4wMDMgKiBkcHJdLFxuICB2ZXJ5c2xvdzogWzEuNSAqIGRwciwgMC4wMDUgKiBkcHJdXG59XG52YXIgdGltZUZ1bmN0aW9uID0ge1xuICBlYXNlOiBbLjI1LC4xLC4yNSwxXSxcbiAgbGluZXI6IFswLDAsMSwxXSxcbiAgJ2Vhc2UtaW4nOiBbLjQyLDAsMSwxXSxcbiAgJ2Vhc2Utb3V0JzogWzAsMCwuNTgsMV0sXG4gICdlYXNlLWluLW91dCc6IFsuNDIsMCwuNTgsMV1cbn1cbnZhciBGaXJlZm94ID0gISF1YS5tYXRjaCgvRmlyZWZveC9pKVxudmFyIElFTW9iaWxlID0gISF1YS5tYXRjaCgvSUVNb2JpbGUvaSlcbnZhciBjc3NQcmVmaXggPSBGaXJlZm94ID8gJy1tb3otJyA6IElFTW9iaWxlID8gJy1tcy0nIDogJy13ZWJraXQtJ1xudmFyIHN0eWxlUHJlZml4ID0gRmlyZWZveCA/ICdNb3onIDogSUVNb2JpbGUgPyAnbXMnIDogJ3dlYmtpdCdcblxuZnVuY3Rpb24gZGVidWdMb2coKSB7XG4gIGlmIChsaWIuc2Nyb2xsLm91dHB1dERlYnVnTG9nKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGlmICghcmVjdCkge1xuICAgIHJlY3QgPSB7fVxuICAgIHJlY3Qud2lkdGggPSBlbC5vZmZzZXRXaWR0aFxuICAgIHJlY3QuaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0XG5cbiAgICByZWN0LmxlZnQgPSBlbC5vZmZzZXRMZWZ0XG4gICAgcmVjdC50b3AgPSBlbC5vZmZzZXRUb3BcbiAgICB2YXIgcGFyZW50ID0gZWwub2Zmc2V0UGFyZW50XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgcmVjdC5sZWZ0ICs9IHBhcmVudC5vZmZzZXRMZWZ0XG4gICAgICByZWN0LnRvcCArPSBwYXJlbnQub2Zmc2V0VG9wXG4gICAgICBwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50XG4gICAgfVxuXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGhcbiAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHRcbiAgfVxuICByZXR1cm4gcmVjdFxufVxuXG5mdW5jdGlvbiBnZXRNaW5TY3JvbGxPZmZzZXQoc2Nyb2xsT2JqKSB7XG4gIHJldHVybiAwIC0gc2Nyb2xsT2JqLm9wdGlvbnNbc2Nyb2xsT2JqLmF4aXMgKyAnUGFkZGluZ1RvcCddXG59XG5cbmZ1bmN0aW9uIGdldE1heFNjcm9sbE9mZnNldChzY3JvbGxPYmopIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Nyb2xsT2JqLmVsZW1lbnQpXG4gIHZhciBwUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzY3JvbGxPYmoudmlld3BvcnQpXG4gIHZhciBtaW4gPSBnZXRNaW5TY3JvbGxPZmZzZXQoc2Nyb2xsT2JqKVxuICBpZiAoc2Nyb2xsT2JqLmF4aXMgPT09ICd5Jykge1xuICAgIHZhciBtYXggPSAwIC0gcmVjdC5oZWlnaHQgKyBwUmVjdC5oZWlnaHRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF4ID0gMCAtIHJlY3Qud2lkdGggKyBwUmVjdC53aWR0aFxuICB9XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBtYXggKyBzY3JvbGxPYmoub3B0aW9uc1tzY3JvbGxPYmouYXhpcyArICdQYWRkaW5nQm90dG9tJ10sXG4gICAgbWluXG4gIClcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRhcnlPZmZzZXQoc2Nyb2xsT2JqLCBvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA+IHNjcm9sbE9iai5taW5TY3JvbGxPZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0IC0gc2Nyb2xsT2JqLm1pblNjcm9sbE9mZnNldFxuICB9XG4gIGlmIChvZmZzZXQgPCBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCAtIHNjcm9sbE9iai5tYXhTY3JvbGxPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiB0b3VjaEJvdW5kYXJ5KHNjcm9sbE9iaiwgb2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPiBzY3JvbGxPYmoubWluU2Nyb2xsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gc2Nyb2xsT2JqLm1pblNjcm9sbE9mZnNldFxuICB9IGVsc2UgaWYgKG9mZnNldCA8IHNjcm9sbE9iai5tYXhTY3JvbGxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0XG4gIH1cbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiBmaXJlRXZlbnQoc2Nyb2xsT2JqLCBldmVudE5hbWUsIGV4dHJhKSB7XG4gIGRlYnVnTG9nKHNjcm9sbE9iai5lbGVtZW50LnNjcm9sbElkLCBldmVudE5hbWUsIGV4dHJhKVxuICB2YXIgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCBmYWxzZSwgdHJ1ZSlcbiAgZXZlbnQuc2Nyb2xsT2JqID0gc2Nyb2xsT2JqXG4gIGlmIChleHRyYSkge1xuICAgIGZvciAodmFyIGtleSBpbiBleHRyYSkge1xuICAgICAgZXZlbnRba2V5XSA9IGV4dHJhW2tleV1cbiAgICB9XG4gIH1cbiAgc2Nyb2xsT2JqLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudClcbiAgc2Nyb2xsT2JqLnZpZXdwb3J0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU9mZnNldChzY3JvbGxPYmopIHtcbiAgdmFyIG9mZnNldCA9IHt4OiAwLCB5OiAwfVxuICB2YXIgdHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxPYmouZWxlbWVudClcbiAgICBbc3R5bGVQcmVmaXggKyAnVHJhbnNmb3JtJ11cbiAgdmFyIG1hdGNoZWRcbiAgdmFyIHJlZzEgPSBuZXcgUmVnRXhwKCdebWF0cml4M2QnXG4gICAgKyAnXFxcXCgoPzpbLVxcXFxkLl0rLFxcXFxzKil7MTJ9KFstXFxcXGQuXSspLCdcbiAgICArICdcXFxccyooWy1cXFxcZC5dKykoPzosXFxcXHMqWy1cXFxcZC5dKyl7Mn1cXFxcKScpXG4gIHZhciByZWcyID0gbmV3IFJlZ0V4cCgnXm1hdHJpeCdcbiAgICArICdcXFxcKCg/OlstXFxcXGQuXSssXFxcXHMqKXs0fShbLVxcXFxkLl0rKSxcXFxccyooWy1cXFxcZC5dKylcXFxcKSQnKVxuICBpZiAodHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICBpZiAoKG1hdGNoZWQgPSB0cmFuc2Zvcm0ubWF0Y2gocmVnMSkgfHxcbiAgICAgICAgdHJhbnNmb3JtLm1hdGNoKHJlZzIpKSkge1xuICAgICAgb2Zmc2V0LnggPSBwYXJzZUZsb2F0KG1hdGNoZWRbMV0pIHx8IDBcbiAgICAgIG9mZnNldC55ID0gcGFyc2VGbG9hdChtYXRjaGVkWzJdKSB8fCAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldFxufVxuXG52YXIgQ1NTTWF0cml4ID0gSUVNb2JpbGUgPyAnTVNDU1NNYXRyaXgnIDogJ1dlYktpdENTU01hdHJpeCdcbnZhciBoYXMzZCA9ICEhRmlyZWZveFxuICB8fCBDU1NNYXRyaXggaW4gd2luZG93XG4gICYmICdtMTEnIGluIG5ldyB3aW5kb3dbQ1NTTWF0cml4XSgpXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoeCwgeSkge1xuICB4ID0gcGFyc2VGbG9hdCh4KVxuICB5ID0gcGFyc2VGbG9hdCh5KVxuXG4gIGlmICh4ICE9IDApIHtcbiAgICB4ICs9ICdweCdcbiAgfVxuXG4gIGlmICh5ICE9IDApIHtcbiAgICB5ICs9ICdweCdcbiAgfVxuXG4gIGlmIChoYXMzZCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoJyArIHggKyAnLCAnICsgeSArICcsIDApJ1xuICB9XG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvblN0eWxlKHNjcm9sbE9iaiwgZHVyYXRpb24sIHRpbWluZ0Z1bmN0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PT0gJycgJiYgdGltaW5nRnVuY3Rpb24gPT09ICcnKSB7XG4gICAgc2Nyb2xsT2JqLmVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNpdGlvbiddID0gJydcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxPYmouZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2l0aW9uJ11cbiAgICAgID0gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSAnICsgZHVyYXRpb24gKyAnICcgKyB0aW1pbmdGdW5jdGlvbiArICcgMHMnXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtU3R5bGUoc2Nyb2xsT2JqLCBvZmZzZXQpIHtcbiAgdmFyIHggPSAwXG4gIHZhciB5ID0gMFxuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ29iamVjdCcpIHtcbiAgICB4ID0gb2Zmc2V0LnhcbiAgICB5ID0gb2Zmc2V0LnlcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2Nyb2xsT2JqLmF4aXMgPT09ICd5Jykge1xuICAgICAgeSA9IG9mZnNldFxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gb2Zmc2V0XG4gICAgfVxuICB9XG4gIHNjcm9sbE9iai5lbGVtZW50LnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddID0gZ2V0VHJhbnNsYXRlKHgsIHkpXG59XG5cbnZhciBwYW5uaW5nID0gZmFsc2VcbmRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICBpZiAocGFubmluZykge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59LCBmYWxzZSlcblxuZnVuY3Rpb24gU2Nyb2xsKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgb3B0aW9ucy5ub0JvdW5jZSA9ICEhb3B0aW9ucy5ub0JvdW5jZVxuICBvcHRpb25zLnBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgfHwge31cblxuICBpZiAob3B0aW9ucy5pc1ByZXZlbnQgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMuaXNQcmV2ZW50ID0gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuaXNQcmV2ZW50ID0gISFvcHRpb25zLmlzUHJldmVudFxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGljayA9PSBudWxsKSB7XG4gICAgb3B0aW9ucy5pc0ZpeFNjcm9sbGVuZENsaWNrID0gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGljayA9ICEhb3B0aW9ucy5pc0ZpeFNjcm9sbGVuZENsaWNrXG4gIH1cblxuICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgb3B0aW9ucy55UGFkZGluZ1RvcCA9IC1vcHRpb25zLnBhZGRpbmcudG9wIHx8IDBcbiAgICBvcHRpb25zLnlQYWRkaW5nQm90dG9tID0gLW9wdGlvbnMucGFkZGluZy5ib3R0b20gfHwgMFxuICAgIG9wdGlvbnMueFBhZGRpbmdUb3AgPSAtb3B0aW9ucy5wYWRkaW5nLmxlZnQgfHwgMFxuICAgIG9wdGlvbnMueFBhZGRpbmdCb3R0b20gPSAtb3B0aW9ucy5wYWRkaW5nLnJpZ2h0IHx8IDBcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnlQYWRkaW5nVG9wID0gMFxuICAgIG9wdGlvbnMueVBhZGRpbmdCb3R0b20gPSAwXG4gICAgb3B0aW9ucy54UGFkZGluZ1RvcCA9IDBcbiAgICBvcHRpb25zLnhQYWRkaW5nQm90dG9tID0gMFxuICB9XG5cbiAgb3B0aW9ucy5kaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCAneSdcbiAgb3B0aW9ucy5pbmVydGlhID0gb3B0aW9ucy5pbmVydGlhIHx8ICdub3JtYWwnXG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGF0LmF4aXMgPSBvcHRpb25zLmRpcmVjdGlvblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gIHRoaXMudmlld3BvcnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgdGhpcy5wbHVnaW5zID0ge31cblxuICB0aGlzLmVsZW1lbnQuc2Nyb2xsSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzY3JvbGxPYmpzW3RoYXQuZWxlbWVudC5zY3JvbGxJZCArICcnXSA9IHRoYXRcbiAgfSwgMSlcblxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciwgZmFsc2UpXG4gIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdwYW5zdGFydCcsIHBhbnN0YXJ0SGFuZGxlciwgZmFsc2UpXG4gIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncGFubW92ZScsIHBhbkhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmVuZCcsIHBhbmVuZEhhbmRsZXIsIGZhbHNlKVxuXG4gIGlmIChvcHRpb25zLmlzUHJldmVudCkge1xuICAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBwYW5uaW5nID0gdHJ1ZVxuICAgIH0sIGZhbHNlKVxuICAgIHRoYXQudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcGFubmluZyA9IGZhbHNlXG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICAvLyBpZiAob3B0aW9ucy5pc1ByZXZlbnQpIHtcbiAgLy8gICB2YXIgZCA9IHRoaXMuYXhpcyA9PT0gJ3knPyd2ZXJ0aWNhbCc6J2hvcml6b250YWwnXG4gIC8vICAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKGQgKyAncGFuc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAvLyAgICAgcGFubmluZyA9IHRydWVcbiAgLy8gICB9LCBmYWxzZSlcbiAgLy8gICB0aGF0LnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gIC8vICAgICBwYW5uaW5nID0gZmFsc2VcbiAgLy8gICB9LCBmYWxzZSlcbiAgLy8gfVxuXG4gIGlmIChvcHRpb25zLmlzRml4U2Nyb2xsZW5kQ2xpY2spIHtcbiAgICB2YXIgcHJldmVudFNjcm9sbGVuZENsaWNrXG4gICAgdmFyIGZpeFNjcm9sbGVuZENsaWNrVGltZW91dElkXG5cbiAgICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHByZXZlbnRTY3JvbGxlbmRDbGljayA9IHRydWVcbiAgICAgIGZpeFNjcm9sbGVuZENsaWNrVGltZW91dElkICYmIGNsZWFyVGltZW91dChmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZClcbiAgICAgIGZpeFNjcm9sbGVuZENsaWNrVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoZSkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsZW5kQ2xpY2sgPSBmYWxzZVxuICAgICAgfSwgNDAwKVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZnVuY3Rpb24gcHJldmVudFNjcm9sbGVuZENsaWNrSGFuZGxlcihlKSB7XG4gICAgICBpZiAocHJldmVudFNjcm9sbGVuZENsaWNrIHx8IGlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJlTmljZVRhcEV2ZW50SGFuZGxlcihlKSB7XG4gICAgICBpZiAoIXByZXZlbnRTY3JvbGxlbmRDbGljayAmJiAhaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5pY2VUYXBFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICAgICAgICBuaWNlVGFwRXZlbnQuaW5pdEV2ZW50KCduaWNlY2xpY2snLCB0cnVlLCB0cnVlKVxuICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmljZVRhcEV2ZW50KVxuICAgICAgICB9LCAzMDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXZlbnRTY3JvbGxlbmRDbGlja0hhbmRsZXIpXG4gICAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCBmaXJlTmljZVRhcEV2ZW50SGFuZGxlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKGgsIHQpIHtcbiAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gbnVsbFxuICAgIGNsZWFyVGltZW91dCh0cmFuc2l0aW9uRW5kVGltZW91dElkKVxuXG4gICAgdHJhbnNpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRyYW5zaXRpb25FbmRIYW5kbGVyKSB7XG4gICAgICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gbnVsbFxuICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShoKVxuICAgICAgfVxuICAgIH0sICh0IHx8IDQwMCkpXG5cbiAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGhcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVzZUZyYW1lQW5pbWF0aW9uKSB7XG4gICAgdmFyIHNjcm9sbEFuaW1hdGlvblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhbmltYXRpb24nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEFuaW1hdGlvblxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIHRyYW5zaXRpb25FbmRIYW5kbGVyXG4gICAgdmFyIHRyYW5zaXRpb25FbmRUaW1lb3V0SWQgPSAwXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEZpcmVmb3hcbiAgICAgICAgICA/ICd0cmFuc2l0aW9uZW5kJ1xuICAgICAgICAgIDogKHN0eWxlUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uRW5kSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRyYW5zaXRpb25FbmRIYW5kbGVyXG5cbiAgICAgICAgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dCh0cmFuc2l0aW9uRW5kVGltZW91dElkKVxuXG4gICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBoYW5kbGVyKGUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICB2YXIgcGFuRml4UmF0aW9cbiAgdmFyIGlzU2Nyb2xsaW5nXG4gIHZhciBpc0ZsaWNrU2Nyb2xsaW5nXG4gIHZhciBjYW5jZWxTY3JvbGxFbmRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzU2Nyb2xsaW5nJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhaXNTY3JvbGxpbmdcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gaXNFbmFibGVkKGUpIHtcbiAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlLmlzVmVydGljYWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0aGF0LmF4aXMgPT09ICd5JyAmJiBlLmlzVmVydGljYWxcbiAgICAgICAgICB8fCB0aGF0LmF4aXMgPT09ICd4JyAmJiAhZS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgIC8vIGdlc3R1cmUgaW4gc2FtZSBkaXJlY3Rpb24sIHN0b3AgYnViYmxpbmcgdXBcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2VzdHVyZSBpbiBkaWZmZXJlbnQgZGlyZWN0aW9uLCBidWJibGluZyB1cFxuICAgICAgICAvLyB0byB0aGUgdG9wLCB3aXRob3V0IGFueSBvdGhlciBwcm9jZXNzXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1Njcm9sbGluZykge1xuICAgICAgc2Nyb2xsRW5kKClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgc2Nyb2xsQW5pbWF0aW9uICYmIHNjcm9sbEFuaW1hdGlvbi5zdG9wKClcbiAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGF0KVxuICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgdHJhbnNmb3JtKVxuICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRoYXQsICcnLCAnJylcbiAgICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gbnVsbFxuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25FbmRUaW1lb3V0SWQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGUpIHtcbiAgICBpZiAoIWlzRW5hYmxlZChlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHMwID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpW3RoYXQuYXhpc11cbiAgICB2YXIgYm91bmRhcnlPZmZzZXQgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzMClcblxuICAgIGlmIChib3VuZGFyeU9mZnNldCkge1xuICAgICAgLy8gZHJhZ2dpbmcgb3V0IG9mIGJvdW5kcmF5LCBib3VuY2UgaXMgbmVlZGVkXG4gICAgICB2YXIgczEgPSB0b3VjaEJvdW5kYXJ5KHRoYXQsIHMwKVxuXG4gICAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAvLyBmcmFtZVxuICAgICAgICB2YXIgX3MgPSBzMSAtIHMwXG4gICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG5ldyBsaWIuYW5pbWF0aW9uKFxuICAgICAgICAgICAgNDAwLFxuICAgICAgICAgICAgbGliLmN1YmljYmV6aWVyLmVhc2UsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKS50b0ZpeGVkKDIpXG4gICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgfSlcbiAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLm9uZW5kKHNjcm9sbEVuZClcbiAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3NzXG4gICAgICAgIHZhciBvZmZzZXQgPSAgczEudG9GaXhlZCgwKVxuICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihzY3JvbGxFbmQsIDQwMClcbiAgICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRoYXQsICcwLjRzJywgJ2Vhc2UnKVxuICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG5cbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gZG9TY3JvbGwoKSB7XG4gICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIHRoYXQuZW5hYmxlZCkge1xuICAgICAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxpbmcnKVxuICAgICAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZG9TY3JvbGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnlPZmZzZXQgPiAwKSB7XG4gICAgICAgIGZpcmVFdmVudCh0aGF0LCB0aGF0LmF4aXMgPT09ICd5JyA/ICdwdWxsZG93bmVuZCcgOiAncHVsbHJpZ2h0ZW5kJylcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRhcnlPZmZzZXQgPCAwKSB7XG4gICAgICAgIGZpcmVFdmVudCh0aGF0LCB0aGF0LmF4aXMgPT09ICd5JyA/ICdwdWxsdXBlbmQnIDogJ3B1bGxsZWZ0ZW5kJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2Nyb2xsaW5nKSB7XG4gICAgICAvLyB3aXRob3V0IGV4Y2VlZGluZyB0aGUgYm91bmRhcnksIGp1c3QgZW5kIGl0XG4gICAgICBzY3JvbGxFbmQoKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0RGlzcGxhY2VtZW50XG4gIGZ1bmN0aW9uIHBhbnN0YXJ0SGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoYXQudHJhbnNmb3JtT2Zmc2V0ID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpXG4gICAgdGhhdC5taW5TY3JvbGxPZmZzZXQgPSBnZXRNaW5TY3JvbGxPZmZzZXQodGhhdClcbiAgICB0aGF0Lm1heFNjcm9sbE9mZnNldCA9IGdldE1heFNjcm9sbE9mZnNldCh0aGF0KVxuICAgIHBhbkZpeFJhdGlvID0gMi41XG4gICAgY2FuY2VsU2Nyb2xsRW5kID0gdHJ1ZVxuICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZVxuICAgIGlzRmxpY2tTY3JvbGxpbmcgPSBmYWxzZVxuICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsc3RhcnQnKVxuXG4gICAgbGFzdERpc3BsYWNlbWVudCA9IGVbJ2Rpc3BsYWNlbWVudCcgKyB0aGF0LmF4aXMudG9VcHBlckNhc2UoKV1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGFuSGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbmdlciBtb3ZlIGxlc3MgdGhhbiA1IHB4LiBqdXN0IGlnbm9yZSB0aGF0LlxuICAgIHZhciBkaXNwbGFjZW1lbnQgPSBlWydkaXNwbGFjZW1lbnQnICsgdGhhdC5heGlzLnRvVXBwZXJDYXNlKCldXG4gICAgaWYgKE1hdGguYWJzKGRpc3BsYWNlbWVudCAtIGxhc3REaXNwbGFjZW1lbnQpIDwgNSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxhc3REaXNwbGFjZW1lbnQgPSBkaXNwbGFjZW1lbnRcblxuICAgIHZhciBvZmZzZXQgPSB0aGF0LnRyYW5zZm9ybU9mZnNldFt0aGF0LmF4aXNdICsgZGlzcGxhY2VtZW50XG4gICAgaWYgKG9mZnNldCA+IHRoYXQubWluU2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSB0aGF0Lm1pblNjcm9sbE9mZnNldFxuICAgICAgICArIChvZmZzZXQgLSB0aGF0Lm1pblNjcm9sbE9mZnNldCkgLyBwYW5GaXhSYXRpb1xuICAgICAgcGFuRml4UmF0aW8gKj0gMS4wMDNcbiAgICB9IGVsc2UgaWYgKG9mZnNldCA8IHRoYXQubWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSB0aGF0Lm1heFNjcm9sbE9mZnNldFxuICAgICAgICAtICh0aGF0Lm1heFNjcm9sbE9mZnNldCAtIG9mZnNldCkgLyBwYW5GaXhSYXRpb1xuICAgICAgcGFuRml4UmF0aW8gKj0gMS4wMDNcbiAgICB9XG4gICAgaWYgKHBhbkZpeFJhdGlvID4gNCkge1xuICAgICAgcGFuRml4UmF0aW8gPSA0XG4gICAgfVxuXG4gICAgLy8gdGVsbCB3aGV0aGVyIG9yIG5vdCByZWFjaCB0aGUgZnJpbmdlXG4gICAgdmFyIGJvdW5kYXJ5T2Zmc2V0ID0gZ2V0Qm91bmRhcnlPZmZzZXQodGhhdCwgb2Zmc2V0KVxuICAgIGlmIChib3VuZGFyeU9mZnNldCkge1xuICAgICAgZmlyZUV2ZW50KFxuICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgYm91bmRhcnlPZmZzZXQgPiAwXG4gICAgICAgICAgPyAodGhhdC5heGlzID09PSAneScgPyAncHVsbGRvd24nIDogJ3B1bGxyaWdodCcpXG4gICAgICAgICAgOiAodGhhdC5heGlzID09PSAneScgPyAncHVsbHVwJyA6ICdwdWxsbGVmdCcpLCB7XG4gICAgICAgIGJvdW5kYXJ5T2Zmc2V0OiBNYXRoLmFicyhib3VuZGFyeU9mZnNldClcbiAgICAgIH0pXG4gICAgICBpZiAodGhhdC5vcHRpb25zLm5vQm91bmNlKSB7XG4gICAgICAgIG9mZnNldCA9IHRvdWNoQm91bmRhcnkodGhhdCwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhbmVuZEhhbmRsZXIoZSkge1xuICAgIGlmICghaXNFbmFibGVkKGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZS5pc1N3aXBlKSB7XG4gICAgICBmbGlja0hhbmRsZXIoZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbGlja0hhbmRsZXIoZSkge1xuICAgIGNhbmNlbFNjcm9sbEVuZCA9IHRydWVcblxuICAgIHZhciB2MCwgYTAsIHQwLCBzMCwgcywgbW90aW9uMFxuICAgIHZhciB2MSwgYTEsIHQxLCBzMSwgbW90aW9uMSxzaWduXG4gICAgdmFyIHYyLCBhMiwgdDIsIHMyLCBtb3Rpb24yLCBmdFxuXG4gICAgczAgPSBnZXRUcmFuc2Zvcm1PZmZzZXQodGhhdClbdGhhdC5heGlzXVxuICAgIHZhciBib3VuZGFyeU9mZnNldDAgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzMClcbiAgICBpZiAoIWJvdW5kYXJ5T2Zmc2V0MCkge1xuICAgICAgLy8gd2hlbiBmaW5nZXJzIGxlZnQgdGhlIHJhbmdlIG9mIHNjcmVlbiwgbGV0IHRvdWNoIGVuZCBoYW5kbGVyXG4gICAgICAvLyB0byBkZWFsIHdpdGggaXQuXG4gICAgICAvLyB3aGVuIGZpbmdlcnMgbGVmdCB0aGUgc2NyZWVuLCBidXQgc3RpbGwgaW4gdGhlIHJhbmdlIG9mXG4gICAgICAvLyBzY3JlZW4sIGNhbGN1bGF0ZSB0aGUgaW50ZXJ0aWEuXG4gICAgICB2MCA9IGVbJ3ZlbG9jaXR5JyArIHRoYXQuYXhpcy50b1VwcGVyQ2FzZSgpXVxuXG4gICAgICB2YXIgbWF4ViA9IDJcbiAgICAgIHZhciBmcmljdGlvbiA9IDAuMDAxNVxuICAgICAgaWYgKG9wdGlvbnMuaW5lcnRpYSAmJiBpbmVydGlhQ29lZmZpY2llbnRbb3B0aW9ucy5pbmVydGlhXSkge1xuICAgICAgICBtYXhWID0gaW5lcnRpYUNvZWZmaWNpZW50W29wdGlvbnMuaW5lcnRpYV1bMF1cbiAgICAgICAgZnJpY3Rpb24gPSBpbmVydGlhQ29lZmZpY2llbnRbb3B0aW9ucy5pbmVydGlhXVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAodjAgPiBtYXhWKSB7XG4gICAgICAgIHYwID0gbWF4VlxuICAgICAgfVxuICAgICAgaWYgKHYwIDwgLW1heFYpIHtcbiAgICAgICAgdjAgPSAtbWF4VlxuICAgICAgfVxuICAgICAgYTAgPSBmcmljdGlvbiAqICh2MCAvIE1hdGguYWJzKHYwKSlcbiAgICAgIG1vdGlvbjAgPSBuZXcgbGliLm1vdGlvbih7XG4gICAgICAgIHY6IHYwLFxuICAgICAgICBhOiAtYTBcbiAgICAgIH0pXG4gICAgICB0MCA9IG1vdGlvbjAudFxuICAgICAgcyA9IHMwICsgbW90aW9uMC5zXG5cbiAgICAgIHZhciBib3VuZGFyeU9mZnNldDEgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzKVxuICAgICAgaWYgKGJvdW5kYXJ5T2Zmc2V0MSkge1xuICAgICAgICBkZWJ1Z0xvZygnaW5lcnRpYWwgY2FsY3VsYXRpb24gaGFzIGV4Y2VlZGVkIHRoZSBib3VuZGFyeScsXG4gICAgICAgICAgYm91bmRhcnlPZmZzZXQxKVxuXG4gICAgICAgIHYxID0gdjBcbiAgICAgICAgYTEgPSBhMFxuICAgICAgICBpZiAoYm91bmRhcnlPZmZzZXQxID4gMCkge1xuICAgICAgICAgIHMxID0gdGhhdC5taW5TY3JvbGxPZmZzZXRcbiAgICAgICAgICBzaWduID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gdGhhdC5tYXhTY3JvbGxPZmZzZXRcbiAgICAgICAgICBzaWduID0gLTFcbiAgICAgICAgfVxuICAgICAgICBtb3Rpb24xID0gbmV3IGxpYi5tb3Rpb24oe1xuICAgICAgICAgIHY6IHNpZ24gKiB2MSxcbiAgICAgICAgICBhOiAtc2lnbiAqIGExLFxuICAgICAgICAgIHM6IE1hdGguYWJzKHMxIC0gczApXG4gICAgICAgIH0pXG4gICAgICAgIHQxID0gbW90aW9uMS50XG4gICAgICAgIHZhciB0aW1lRnVuY3Rpb24xID0gbW90aW9uMS5nZW5lcmF0ZUN1YmljQmV6aWVyKClcblxuICAgICAgICB2MiA9IHYxIC0gYTEgKiB0MVxuICAgICAgICBhMiA9IDAuMDMgKiAodjIgLyBNYXRoLmFicyh2MikpXG4gICAgICAgIG1vdGlvbjIgPSBuZXcgbGliLm1vdGlvbih7XG4gICAgICAgICAgdjogdjIsXG4gICAgICAgICAgYTogLWEyXG4gICAgICAgIH0pXG4gICAgICAgIHQyID0gbW90aW9uMi50XG4gICAgICAgIHMyID0gczEgKyBtb3Rpb24yLnNcbiAgICAgICAgdmFyIHRpbWVGdW5jdGlvbjIgPSBtb3Rpb24yLmdlbmVyYXRlQ3ViaWNCZXppZXIoKVxuXG4gICAgICAgIGlmIChvcHRpb25zLm5vQm91bmNlKSB7XG4gICAgICAgICAgZGVidWdMb2coJ25vIGJvdW5jZSBlZmZlY3QnKVxuXG4gICAgICAgICAgaWYgKHMwICE9PSBzMSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gZnJhbWVcbiAgICAgICAgICAgICAgdmFyIF9zID0gczEgLSBzMFxuICAgICAgICAgICAgICB2YXIgYmV6aWVyID0gbGliLmN1YmljYmV6aWVyKFxuICAgICAgICAgICAgICAgIHRpbWVGdW5jdGlvbjFbMF1bMF0sXG4gICAgICAgICAgICAgICAgdGltZUZ1bmN0aW9uMVswXVsxXSxcbiAgICAgICAgICAgICAgICB0aW1lRnVuY3Rpb24xWzFdWzBdLFxuICAgICAgICAgICAgICAgIHRpbWVGdW5jdGlvbjFbMV1bMV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgIHQxLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgICAgICBiZXppZXIsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKVxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybU9mZnNldCh0aGF0LCBvZmZzZXQudG9GaXhlZCgyKSlcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycsIHtcbiAgICAgICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG5cbiAgICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY3NzXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzMS50b0ZpeGVkKDApXG4gICAgICAgICAgICAgIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIHNjcm9sbEVuZCxcbiAgICAgICAgICAgICAgICAodDEgLyAxMDAwKS50b0ZpeGVkKDIpICogMTAwMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICh0MSAvIDEwMDApLnRvRml4ZWQoMikgKyAncycsXG4gICAgICAgICAgICAgICAgJ2N1YmljLWJlemllcignICsgdGltZUZ1bmN0aW9uMSArICcpJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoczAgIT09IHMyKSB7XG4gICAgICAgICAgZGVidWdMb2coXG4gICAgICAgICAgICAnc2Nyb2xsIGZvciBpbmVydGlhJyxcbiAgICAgICAgICAgICdzPScgKyBzMi50b0ZpeGVkKDApLFxuICAgICAgICAgICAgJ3Q9JyArICgodDEgKyB0MikgLyAxMDAwKS50b0ZpeGVkKDIpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfcyA9IHMyIC0gczBcbiAgICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIuZWFzZU91dFxuICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgICAgKHQxICsgdDIpLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgICAgYmV6aWVyLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gczAgKyBfcyAqIGkyXG4gICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycse1xuICAgICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX3MgPSBzMSAtIHMyXG4gICAgICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIuZWFzZVxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgIDQwMCxcbiAgICAgICAgICAgICAgICAgIGJlemllcixcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaTEsIGkyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMyICsgX3MgKiBpMlxuICAgICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgICAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJyx7XG4gICAgICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoc2Nyb2xsRW5kKVxuXG4gICAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMyLnRvRml4ZWQoMClcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWJ1Z0xvZygnaW5lcnRpYWwgYm91bmNlJyxcbiAgICAgICAgICAgICAgICAncz0nICsgczEudG9GaXhlZCgwKSxcbiAgICAgICAgICAgICAgICAndD00MDAnXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBpZiAoczIgIT09IHMxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMxLnRvRml4ZWQoMClcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJzAuNHMnLCAnZWFzZScpXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKHNjcm9sbEVuZCwgNDAwKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcm9sbEVuZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICgodDEgKyB0MikgLyAxMDAwKS50b0ZpeGVkKDIpICogMTAwMClcblxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKFxuICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAoKHQxICsgdDIpIC8gMTAwMCkudG9GaXhlZCgyKSArICdzJyxcbiAgICAgICAgICAgICAgJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxFbmQoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Z0xvZygnaW5lcnRpYWwgY2FsY3VsYXRpb24gaGFzblxcJ3QgZXhjZWVkZWQgdGhlIGJvdW5kYXJ5JylcbiAgICAgICAgdmFyIHRpbWVGdW5jdGlvbiA9IG1vdGlvbjAuZ2VuZXJhdGVDdWJpY0JlemllcigpXG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAvLyBmcmFtZVxuICAgICAgICAgIHZhciBfcyA9IHMgLSBzMFxuICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIoXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMF1bMF0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMF1bMV0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMV1bMF0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMV1bMV1cbiAgICAgICAgICApXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgIHQwLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgIGJlemllcixcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChzMCArIF9zICogaTIpLnRvRml4ZWQoMilcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJyx7XG4gICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG5cbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24ucGxheSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3NzXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHMudG9GaXhlZCgwKVxuICAgICAgICAgIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKHNjcm9sbEVuZCwgKHQwIC8gMTAwMCkudG9GaXhlZCgyKSAqIDEwMDApXG4gICAgICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICh0MCAvIDEwMDApLnRvRml4ZWQoMikgKyAncycsXG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKCcgKyB0aW1lRnVuY3Rpb24gKyAnKSdcbiAgICAgICAgICApXG4gICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgaXNGbGlja1Njcm9sbGluZyA9IHRydWVcbiAgICAgIGlmICghb3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShmdW5jdGlvbiBkb1Njcm9sbCgpIHtcbiAgICAgICAgICBpZiAoaXNTY3JvbGxpbmcgJiYgaXNGbGlja1Njcm9sbGluZyAmJiB0aGF0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJywge1xuICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZG9TY3JvbGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbEVuZCgpIHtcbiAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2FuY2VsU2Nyb2xsRW5kID0gZmFsc2VcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYW5jZWxTY3JvbGxFbmQgJiYgaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgaXNTY3JvbGxpbmcgPSBmYWxzZVxuICAgICAgICBpc0ZsaWNrU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgICAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiAmJiBzY3JvbGxBbmltYXRpb24uc3RvcCgpXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnJywgJycpXG4gICAgICAgIH1cbiAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxlbmQnKVxuICAgICAgfVxuICAgIH0sIDUwKVxuICB9XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgICB0aGlzLnNjcm9sbFRvKDApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudFxuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICBzY3JvbGxBbmltYXRpb24gJiYgc2Nyb2xsQW5pbWF0aW9uLnN0b3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgICAgICA9IGdldENvbXB1dGVkU3R5bGUoZWwpW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGdldFNjcm9sbFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkud2lkdGhcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkuaGVpZ2h0XG4gICAgfSxcblxuICAgIGdldFNjcm9sbExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAtZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoaXMpLnggLSB0aGlzLm9wdGlvbnMueFBhZGRpbmdUb3BcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLWdldFRyYW5zZm9ybU9mZnNldCh0aGlzKS55IC0gdGhpcy5vcHRpb25zLnlQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldE1heFNjcm9sbExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAtdGhhdC5tYXhTY3JvbGxPZmZzZXQgLSB0aGlzLm9wdGlvbnMueFBhZGRpbmdUb3BcbiAgICB9LFxuXG4gICAgZ2V0TWF4U2Nyb2xsVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLXRoYXQubWF4U2Nyb2xsT2Zmc2V0IC0gdGhpcy5vcHRpb25zLnlQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldEJvdW5kYXJ5T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoXG4gICAgICAgIGdldEJvdW5kYXJ5T2Zmc2V0KHRoaXMsIGdldFRyYW5zZm9ybU9mZnNldCh0aGlzKVt0aGlzLmF4aXNdKSB8fCAwXG4gICAgICApXG4gICAgfSxcblxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudFxuICAgICAgdmFyIGlzVmVydGljYWwgPSAodGhpcy5heGlzID09PSAneScpXG4gICAgICB2YXIgdHlwZSA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCdcbiAgICAgIHZhciBzaXplLCByZWN0LCBleHRyYVNpemVcblxuICAgICAgZnVuY3Rpb24gZ2V0RXh0cmFTaXplKGVsLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHZhciBleHRyYVR5cGUgPSBpc1ZlcnRpY2FsID8gWyd0b3AnLCAnYm90dG9tJ10gOiBbJ2xlZnQnLCAncmlnaHQnXVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChcbiAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGVsLmZpcnN0RWxlbWVudENoaWxkKVsnbWFyZ2luLScgKyBleHRyYVR5cGVbMF1dXG4gICAgICAgICkgKyBwYXJzZUZsb2F0KFxuICAgICAgICAgIGdldENvbXB1dGVkU3R5bGUoZWwubGFzdEVsZW1lbnRDaGlsZClbJ21hcmdpbi0nICsgZXh0cmFUeXBlWzFdXVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNbdHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAvLyB1c2Ugb3B0aW9uc1xuICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zW3R5cGVdXG4gICAgICB9IGVsc2UgaWYgKGVsLmNoaWxkRWxlbWVudENvdW50IDw9IDApIHtcbiAgICAgICAgZWwuc3R5bGVbdHlwZV0gPSAnYXV0bydcbiAgICAgICAgc2l6ZSA9IG51bGxcbiAgICAgIH0gZWxzZSBpZiAoISF0aGlzLm9wdGlvbnMudXNlRWxlbWVudFJlY3QpIHtcbiAgICAgICAgZWwuc3R5bGVbdHlwZV0gPSAnYXV0bydcbiAgICAgICAgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbClcbiAgICAgICAgc2l6ZSA9IHJlY3RbdHlwZV1cbiAgICAgICAgc2l6ZSArPSBnZXRFeHRyYVNpemUoZWwsIGlzVmVydGljYWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFuZ2UsIHJlY3RcbiAgICAgICAgdmFyIGZpcnN0RWwgPSBlbC5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgICB2YXIgbGFzdEVsID0gZWwubGFzdEVsZW1lbnRDaGlsZFxuXG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVSYW5nZSAmJiAhdGhpcy5vcHRpb25zLmlnbm9yZU92ZXJmbG93KSB7XG4gICAgICAgICAgLy8gdXNlIHJhbmdlXG4gICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpXG4gICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsKVxuICAgICAgICAgIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmFuZ2UpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIHNpemUgPSByZWN0W3R5cGVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNoaWxkIG9mZnNldHNcbiAgICAgICAgICB3aGlsZSAoZmlyc3RFbCkge1xuICAgICAgICAgICAgaWYgKGdldEJvdW5kaW5nQ2xpZW50UmVjdChmaXJzdEVsKVt0eXBlXSA9PT0gMFxuICAgICAgICAgICAgICAgICYmIGZpcnN0RWwubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGZpcnN0RWwgPSBmaXJzdEVsLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAobGFzdEVsICYmIGxhc3RFbCAhPT0gZmlyc3RFbCkge1xuICAgICAgICAgICAgaWYgKGdldEJvdW5kaW5nQ2xpZW50UmVjdChsYXN0RWwpW3R5cGVdID09PSAwXG4gICAgICAgICAgICAgICAgJiYgbGFzdEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgbGFzdEVsID0gbGFzdEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2l6ZSA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChsYXN0RWwpW1xuICAgICAgICAgICAgICBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnXVxuICAgICAgICAgICAgLSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZmlyc3RFbClbXG4gICAgICAgICAgICAgIGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0J11cbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgKz0gZ2V0RXh0cmFTaXplKGVsLCBpc1ZlcnRpY2FsKVxuXG4gICAgICB9XG5cbiAgICAgIGVsLnN0eWxlW3R5cGVdID0gc2l6ZSA/IHNpemUgKyAncHgnIDogJ2F1dG8nXG5cbiAgICAgIHRoaXMudHJhbnNmb3JtT2Zmc2V0ID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoaXMpXG4gICAgICB0aGlzLm1pblNjcm9sbE9mZnNldCA9IGdldE1pblNjcm9sbE9mZnNldCh0aGlzKVxuICAgICAgdGhpcy5tYXhTY3JvbGxPZmZzZXQgPSBnZXRNYXhTY3JvbGxPZmZzZXQodGhpcylcblxuICAgICAgdGhpcy5zY3JvbGxUbyhcbiAgICAgICAgLXRoaXMudHJhbnNmb3JtT2Zmc2V0W3RoaXMuYXhpc11cbiAgICAgICAgLSB0aGlzLm9wdGlvbnNbdGhpcy5heGlzICsgJ1BhZGRpbmdUb3AnXVxuICAgICAgKVxuICAgICAgZmlyZUV2ZW50KHRoaXMsICdjb250ZW50cmVmcmVzaCcpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIG9mZnNldDogZnVuY3Rpb24gKGNoaWxkRWwpIHtcbiAgICAgIHZhciBlbFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5lbGVtZW50KVxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZEVsKVxuICAgICAgaWYgKHRoaXMuYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgIHZhciBvZmZzZXRSZWN0ID0ge1xuICAgICAgICAgIHRvcDogY2hpbGRSZWN0LnRvcCAtIGVsUmVjdC50b3AgLSB0aGlzLm9wdGlvbnMueVBhZGRpbmdUb3AsXG4gICAgICAgICAgbGVmdDogY2hpbGRSZWN0LmxlZnQgLSBlbFJlY3QubGVmdCxcbiAgICAgICAgICByaWdodDogZWxSZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LnJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBjaGlsZFJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZFJlY3QuaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRSZWN0LmJvdHRvbSA9IG9mZnNldFJlY3QudG9wICsgb2Zmc2V0UmVjdC5oZWlnaHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvZmZzZXRSZWN0ID0ge1xuICAgICAgICAgIHRvcDogY2hpbGRSZWN0LnRvcCAtIGVsUmVjdC50b3AsXG4gICAgICAgICAgYm90dG9tOiBlbFJlY3QuYm90dG9tIC0gY2hpbGRSZWN0LmJvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBjaGlsZFJlY3QubGVmdCAtIGVsUmVjdC5sZWZ0IC0gdGhpcy5vcHRpb25zLnhQYWRkaW5nVG9wLFxuICAgICAgICAgIHdpZHRoOiBjaGlsZFJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZFJlY3QuaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRSZWN0LnJpZ2h0ID0gb2Zmc2V0UmVjdC5sZWZ0ICsgb2Zmc2V0UmVjdC53aWR0aFxuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldFJlY3RcbiAgICB9LFxuXG4gICAgZ2V0UmVjdDogZnVuY3Rpb24gKGNoaWxkRWwpIHtcbiAgICAgIHZhciB2aWV3UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnZpZXdwb3J0KVxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZEVsKVxuICAgICAgaWYgKHRoaXMuYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgIHZhciBvZmZzZXRSZWN0ID0ge1xuICAgICAgICAgIHRvcDogY2hpbGRSZWN0LnRvcCAtIHZpZXdSZWN0LnRvcCxcbiAgICAgICAgICBsZWZ0OiBjaGlsZFJlY3QubGVmdCAtIHZpZXdSZWN0LmxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHZpZXdSZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LnJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBjaGlsZFJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZFJlY3QuaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRSZWN0LmJvdHRvbSA9IG9mZnNldFJlY3QudG9wICsgb2Zmc2V0UmVjdC5oZWlnaHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvZmZzZXRSZWN0ID0ge1xuICAgICAgICAgIHRvcDogY2hpbGRSZWN0LnRvcCAtIHZpZXdSZWN0LnRvcCxcbiAgICAgICAgICBib3R0b206IHZpZXdSZWN0LmJvdHRvbSAtIGNoaWxkUmVjdC5ib3R0b20sXG4gICAgICAgICAgbGVmdDogY2hpbGRSZWN0LmxlZnQgLSB2aWV3UmVjdC5sZWZ0LFxuICAgICAgICAgIHdpZHRoOiBjaGlsZFJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjaGlsZFJlY3QuaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRSZWN0LnJpZ2h0ID0gb2Zmc2V0UmVjdC5sZWZ0ICsgb2Zmc2V0UmVjdC53aWR0aFxuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldFJlY3RcbiAgICB9LFxuXG4gICAgaXNJblZpZXc6IGZ1bmN0aW9uIChjaGlsZEVsKSB7XG4gICAgICB2YXIgdmlld1JlY3QgPSB0aGlzLmdldFJlY3QodGhpcy52aWV3cG9ydClcbiAgICAgIHZhciBjaGlsZFJlY3QgPSB0aGlzLmdldFJlY3QoY2hpbGRFbClcbiAgICAgIGlmICh0aGlzLmF4aXMgPT09ICd5Jykge1xuICAgICAgICByZXR1cm4gdmlld1JlY3QudG9wIDwgY2hpbGRSZWN0LmJvdHRvbVxuICAgICAgICAgICYmIHZpZXdSZWN0LmJvdHRvbSA+IGNoaWxkUmVjdC50b3BcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3UmVjdC5sZWZ0IDwgY2hpbGRSZWN0LnJpZ2h0XG4gICAgICAgICYmIHZpZXdSZWN0LnJpZ2h0ID4gY2hpbGRSZWN0LmxlZnRcbiAgICB9LFxuXG4gICAgc2Nyb2xsVG86IGZ1bmN0aW9uIChvZmZzZXQsIGlzU21vb3RoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50XG5cbiAgICAgIG9mZnNldCA9IC1vZmZzZXQgLSB0aGlzLm9wdGlvbnNbdGhpcy5heGlzICsgJ1BhZGRpbmdUb3AnXVxuICAgICAgb2Zmc2V0ID0gdG91Y2hCb3VuZGFyeSh0aGlzLCBvZmZzZXQpXG5cbiAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZVxuICAgICAgaWYgKGlzU21vb3RoID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICB2YXIgczAgPSBnZXRUcmFuc2Zvcm1PZmZzZXQodGhhdClbdGhpcy5heGlzXVxuICAgICAgICAgIHZhciBfcyA9IG9mZnNldCAtIHMwXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgIDQwMCxcbiAgICAgICAgICAgICAgbGliLmN1YmljYmV6aWVyLmVhc2VJbk91dCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChzMCArIF9zICogaTIpLnRvRml4ZWQoMilcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLm9uZW5kKHNjcm9sbEVuZClcblxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihzY3JvbGxFbmQsIDQwMClcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJzAuNHMnLCAnZWFzZS1pbi1vdXQnKVxuICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcblxuICAgICAgICAgIGZ1bmN0aW9uIF9jYW5jZWxTY3JvbGwoKSB7XG4gICAgICAgICAgICBpZiAoaXNTY3JvbGxpbmcgJiYgdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoX2NhbmNlbFNjcm9sbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShfY2FuY2VsU2Nyb2xsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnJywgJycpXG4gICAgICAgIH1cbiAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICBzY3JvbGxFbmQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBzY3JvbGxUb0VsZW1lbnQ6IGZ1bmN0aW9uIChjaGlsZEVsLCBpc1Ntb290aCwgdG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoY2hpbGRFbClcbiAgICAgIG9mZnNldCA9IG9mZnNldFt0aGlzLmF4aXMgPT09ICd5Jz8ndG9wJzonbGVmdCddXG4gICAgICB0b3BPZmZzZXQgJiYgKG9mZnNldCArPSB0b3BPZmZzZXQpXG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyhvZmZzZXQsIGlzU21vb3RoKVxuICAgIH0sXG5cbiAgICBnZXRWaWV3V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy52aWV3cG9ydCkud2lkdGhcbiAgICB9LFxuXG4gICAgZ2V0Vmlld0hlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnZpZXdwb3J0KS5oZWlnaHRcbiAgICB9LFxuXG4gICAgYWRkUHVsbGRvd25IYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHVsbGRvd25lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGF0LmRpc2FibGUoKVxuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuc2Nyb2xsVG8oMCwgdHJ1ZSlcbiAgICAgICAgICB0aGF0LnJlZnJlc2goKVxuICAgICAgICAgIHRoYXQuZW5hYmxlKClcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhZGRQdWxsdXBIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwdWxsdXBlbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGF0LmRpc2FibGUoKVxuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuc2Nyb2xsVG8odGhhdC5nZXRTY3JvbGxIZWlnaHQoKSwgdHJ1ZSlcbiAgICAgICAgICB0aGF0LnJlZnJlc2goKVxuICAgICAgICAgIHRoYXQuZW5hYmxlKClcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhZGRTY3JvbGxzdGFydEhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSwgZmFsc2UpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFkZFNjcm9sbGluZ0hhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxpbmcnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0sIGZhbHNlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhZGRTY3JvbGxlbmRIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9LCBmYWxzZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYWRkQ29udGVudHJlbmZyZXNoSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRlbnRyZWZyZXNoJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9LCBmYWxzZSlcbiAgICB9LFxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9LCAhIXVzZUNhcHR1cmUpXG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgZW5hYmxlUGx1Z2luOiBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbbmFtZV1cbiAgICAgIGlmIChwbHVnaW4gJiYgIXRoaXMucGx1Z2luc1tuYW1lXSkge1xuICAgICAgICB0aGlzLnBsdWdpbnNbbmFtZV0gPSB0cnVlXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgICAgIHBsdWdpbi5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGsgaW4gcHJvdG8pIHtcbiAgICB0aGlzW2tdID0gcHJvdG9ba11cbiAgfVxuICAvLyBkZWxldGUgcHJvdG9cbn1cblxubGliLnNjcm9sbCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAhKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF1cbiAgICBpZiAob3B0aW9ucy5zY3JvbGxFbGVtZW50KSB7XG4gICAgICBlbCA9IG9wdGlvbnMuc2Nyb2xsRWxlbWVudFxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zY3JvbGxXcmFwKSB7XG4gICAgICBlbCA9IG9wdGlvbnMuc2Nyb2xsV3JhcC5maXJzdEVsZW1lbnRDaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHNjcm9sbCBlbGVtZW50JylcbiAgICB9XG4gIH1cblxuICBpZiAoIWVsLnBhcmVudE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIGRvbSB0cmVlJylcbiAgfVxuICBpZiAob3B0aW9uc1xuICAgICAgJiYgb3B0aW9ucy5kaXJlY3Rpb25cbiAgICAgICYmIFsneCcsICd5J10uaW5kZXhPZihvcHRpb25zLmRpcmVjdGlvbikgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBkaXJlY3Rpb24nKVxuICB9XG5cbiAgdmFyIHNjcm9sbFxuICBpZiAob3B0aW9ucy5kb3duZ3JhZGUgPT09IHRydWVcbiAgICAgICYmIGxpYi5zY3JvbGwuZG93bmdyYWRlKSB7XG4gICAgc2Nyb2xsID0gbGliLnNjcm9sbC5kb3duZ3JhZGUoZWwsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsLnNjcm9sbElkKSB7XG4gICAgICBzY3JvbGwgPSBzY3JvbGxPYmpzW2VsLnNjcm9sbElkXVxuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGwgPSBuZXcgU2Nyb2xsKGVsLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2Nyb2xsXG59XG5cbmxpYi5zY3JvbGwucGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIGNvbnN0cnVjdG9yKSB7XG4gIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcsJylcbiAgICBuYW1lLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHBsdWdpbnNbbl0gPSBjb25zdHJ1Y3RvclxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBsdWdpbnNbbmFtZV1cbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsLmpzXG4gKiovIiwiLyogZ2xvYmFsIGxpYjogdHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiB0cmFuc2ZlciBRdWFkcmF0aWMgQmV6aWVyIEN1cnZlIHRvIEN1YmljIEJlemllciBDdXJ2ZVxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYSBhYnNjaXNzYSBvZiBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBiIG9yZGluYXRlIG9mIHAxXG4gKiBAcmV0dXJuIHtBcnJheX0gcGFyYW1ldGVyIG1hdHJpeCBmb3IgY3ViaWMgYmV6aWVyIGN1cnZlXG4gKiAgIGxpa2UgW1twMXgsIHAxeV0sIFtwMngsIHAyeV1dXG4gKi9cbmZ1bmN0aW9uIHF1YWRyYXRpYzJjdWJpY0JlemllciAoYSwgYikge1xuICByZXR1cm4gW1xuICAgIFtcbiAgICAgIChhIC8gMyArIChhICsgYikgLyAzIC0gYSkgLyAoYiAtIGEpLFxuICAgICAgKGEgKiBhIC8gMyArIGEgKiBiICogMiAvIDMgLSBhICogYSkgLyAoYiAqIGIgLSBhICogYSlcbiAgICBdLCBbXG4gICAgICAoYiAvIDMgKyAoYSArIGIpIC8gMyAtIGEpIC8gKGIgLSBhKSxcbiAgICAgIChiICogYiAvIDMgKyBhICogYiAqIDIgLyAzIC0gYSAqIGEpIC8gKGIgKiBiIC0gYSAqIGEpXG4gICAgXVxuICBdXG59XG5cbi8qKlxuICogZGVyaXZlIHBvc2l0aW9uIGRhdGEgZnJvbSBrbm93aW5nIG1vdGlvbiBwYXJhbWV0ZXJzXG4gKiBiYXNlIG9uIE5ld3RvbidzIHNlY29uZCBsYXc6IHMgPSB2dCArIGF0XjIvMlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgb2JqZWN0IG9mIHsgdiwgYSwgcywgdCB9XG4gKiAgIC0gdjogaW5pdGlhbCB2ZWxvY2l0eVxuICogICAtIGE6IGFjY2VsZXJhdGUgc3BlZWRcbiAqICAgLSB0OiB0aW1lXG4gKiAgIC0gczogc2hpZnRpbmdcbiAqL1xuZnVuY3Rpb24gTW90aW9uIChjb25maWcpIHtcbiAgdGhpcy52ID0gY29uZmlnLnYgfHwgMFxuICB0aGlzLmEgPSBjb25maWcuYSB8fCAwXG5cbiAgaWYgKHR5cGVvZiBjb25maWcudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnQgPSBjb25maWcudFxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnMgPSBjb25maWcuc1xuICB9XG5cbiAgLy8gZGVyaXZlIHRpbWUgZnJvbSBzaGlmdGluZ1xuICBpZiAodHlwZW9mIHRoaXMudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudCA9IC10aGlzLnYgLyB0aGlzLmFcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB0MSA9IChNYXRoLnNxcnQodGhpcy52ICogdGhpcy52ICsgMiAqIHRoaXMuYSAqIHRoaXMucykgLSB0aGlzLnYpXG4gICAgICAgIC8gdGhpcy5hXG4gICAgICBjb25zdCB0MiA9ICgtTWF0aC5zcXJ0KHRoaXMudiAqIHRoaXMudiArIDIgKiB0aGlzLmEgKiB0aGlzLnMpIC0gdGhpcy52KVxuICAgICAgICAvIHRoaXMuYVxuICAgICAgdGhpcy50ID0gTWF0aC5taW4odDEsIHQyKVxuICAgIH1cbiAgfVxuXG4gIC8vIGRlcml2ZSBzaGlmdGluZyBmcm9tIHRpbWVcbiAgaWYgKHR5cGVvZiB0aGlzLnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zID0gdGhpcy5hICogdGhpcy50ICogdGhpcy50IC8gMiArIHRoaXMudiAqIHRoaXMudFxuICB9XG59XG5cbi8qKlxuICogZGVyaXZlIGN1YmljIGJlemllciBwYXJhbWV0ZXJzIGZyb20gbW90aW9uIHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0FycmF5fSBwYXJhbWV0ZXIgbWF0cml4IGZvciBjdWJpYyBiZXppZXIgY3VydmVcbiAqICAgbGlrZSBbW3AxeCwgcDF5XSwgW3AyeCwgcDJ5XV1cbiAqL1xuTW90aW9uLnByb3RvdHlwZS5nZW5lcmF0ZUN1YmljQmV6aWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcXVhZHJhdGljMmN1YmljQmV6aWVyKFxuICAgIHRoaXMudiAvIHRoaXMuYSwgdGhpcy50ICsgdGhpcy52IC8gdGhpcy5hXG4gIClcbn1cblxuIWxpYiAmJiAobGliID0ge30pXG5saWIubW90aW9uID0gTW90aW9uXG5cbm1vZHVsZS5leHBvcnRzID0gTW90aW9uXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9tb3Rpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGxpc3RNb2R1bGUgZnJvbSAnLi9saXN0J1xuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IExpc3QgPSBsaXN0TW9kdWxlLmluaXQoV2VleClcblxuICBmdW5jdGlvbiBIbGlzdCAoZGF0YSwgbm9kZVR5cGUpIHtcbiAgICBkYXRhLmF0dHIuZGlyZWN0aW9uID0gJ2gnXG4gICAgTGlzdC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG5cbiAgSGxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaXN0LnByb3RvdHlwZSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdobGlzdCcsIEhsaXN0KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9obGlzdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgc2Nyb2xsYWJsZU1vZHVsZSBmcm9tICcuLi9zY3JvbGxhYmxlJ1xuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IFNjcm9sbGFibGUgPSBzY3JvbGxhYmxlTW9kdWxlLmluaXQoV2VleClcbiAgZnVuY3Rpb24gU2Nyb2xsZXIgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgU2Nyb2xsYWJsZS5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgU2Nyb2xsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY3JvbGxhYmxlLnByb3RvdHlwZSlcbiAgZXh0ZW5kKFNjcm9sbGVyLnByb3RvdHlwZSwge1xuICAgIGNyZWF0ZSAoKSB7XG4gICAgICBjb25zdCBub2RlID0gU2Nyb2xsYWJsZS5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcylcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnc2Nyb2xsZXItd3JhcCcpXG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2Nyb2xsZXItZWxlbWVudCcpXG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzY3JvbGxlcicsIFNjcm9sbGVyKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsZXIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0ICcuL3JlZnJlc2guY3NzJ1xuXG5jb25zdCBwYXJlbnRzID0gWydzY3JvbGxlcicsICdsaXN0JywgJ3ZsaXN0J11cblxuLy8gT25seSBpZiBwdWxsZG93biBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZSBjYW4gdGhpc1xuLy8gY29tcG9uZW50IHRyaWdnZXIgdGhlICdyZWZyZXNoJyBldmVudCwgb3RoZXJ3aXNlIGp1c3QgcmVjb3ZlclxuLy8gdG8gdGhlIHN0YXJ0IHBvaW50LlxuY29uc3QgREVGQVVMVF9DTEFNUCA9IDEzMFxuY29uc3QgREVGQVVMVF9BTElHTl9JVEVNUyA9ICdjZW50ZXInXG5jb25zdCBERUZBVUxUX0pVU1RJRllfQ09OVEVOVCA9ICdjZW50ZXInXG5cbmZ1bmN0aW9uIGFkanVzdEhlaWdodCAocmVmcmVzaCwgdmFsKSB7XG4gIHJlZnJlc2gubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG59XG5cbi8vIGZ1bmN0aW9uIGFkSnVzdFBvc2l0aW9uIChyZWZyZXNoLCB2YWwpIHtcbi8vICAgcmVmcmVzaC5ub2RlLnN0eWxlLnRvcCA9IC12YWwgKyAncHgnXG4vLyB9XG5cbmZ1bmN0aW9uIGhhbmRsZVJlZnJlc2ggKHJlZnJlc2gsIGUpIHtcbiAgcmVmcmVzaC5ub2RlLnN0eWxlLmhlaWdodCA9IHJlZnJlc2guY2xhbXAgKyAncHgnXG4gIHJlZnJlc2guZGlzcGF0Y2hFdmVudCgncmVmcmVzaCcpXG4gIHJlZnJlc2guaXNSZWZyZXNoaW5nID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzaG93IChyZWZyZXNoKSB7XG4gIHJlZnJlc2guZGlzcGxheSA9IHRydWVcbiAgcmVmcmVzaC5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1ib3gnXG4gIHJlZnJlc2gubm9kZS5zdHlsZS5kaXNwbGF5ID0gJy13ZWJraXQtZmxleCdcbiAgcmVmcmVzaC5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbn1cblxuZnVuY3Rpb24gaGlkZSAocmVmcmVzaCkge1xuICByZWZyZXNoLmRpc3BsYXkgPSBmYWxzZVxuICByZWZyZXNoLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICByZWZyZXNoLmlzUmVmcmVzaGluZyA9IGZhbHNlXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnd2VleC1yZWZyZXNoJylcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIG9uQXBwZW5kICgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpXG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBpZiAocGFyZW50cy5pbmRleE9mKHBhcmVudC5kYXRhLnR5cGUpID09PSAtMSkge1xuICAgICAgLy8gbm90IGluIGEgc2Nyb2xsZXIgb3IgYSBsaXN0XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoUGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMucmVmcmVzaFBsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3dlZXgtcmVmcmVzaC1wbGFjZWhvbGRlcicpXG4gICAgdGhpcy5yZWZyZXNoUGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIHRoaXMucmVmcmVzaFBsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gJzBweCdcbiAgICB0aGlzLnJlZnJlc2hQbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSBwYXJlbnQuc2Nyb2xsRWxlbWVudCB8fCBwYXJlbnQubGlzdEVsZW1lbnRcbiAgICBzY3JvbGxFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLnJlZnJlc2hQbGFjZWhvbGRlciwgdGhpcy5ub2RlKVxuICAgIHBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICBwYXJlbnQuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcigncHVsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHNlbGYuaXNSZWZyZXNoaW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgYWRqdXN0SGVpZ2h0KHNlbGYsIE1hdGguYWJzKGUuc2Nyb2xsT2JqLmdldFNjcm9sbFRvcCgpKSlcbiAgICAgIGlmICghc2VsZi5kaXNwbGF5KSB7XG4gICAgICAgIHNob3coc2VsZilcbiAgICAgIH1cbiAgICB9KVxuICAgIHBhcmVudC5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKCdwdWxsZG93bmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoc2VsZi5pc1JlZnJlc2hpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCB0b3AgPSBNYXRoLmFicyhlLnNjcm9sbE9iai5nZXRTY3JvbGxUb3AoKSlcbiAgICAgIGlmICh0b3AgPiBzZWxmLmNsYW1wKSB7XG4gICAgICAgIGhhbmRsZVJlZnJlc2goc2VsZiwgZSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBoaWRlKHNlbGYpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBkaXNwbGF5OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gJ3Nob3cnKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2hvdyh0aGlzKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPT09ICdoaWRlJykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGUodGhpcylcbiAgICAgIH0uYmluZCh0aGlzKSwgMClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBhdHRyIFxcJ2Rpc3BsYXlcXCcgb2YgPHJlZnJlc2g+XFwnOiB2YWx1ZSAnXG4gICAgICAgICsgdmFsXG4gICAgICAgICsgJyBpcyBpbnZhbGlkLiBTaG91bGQgYmUgXFwnc2hvd1xcJyBvciBcXCdoaWRlXFwnJylcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIGhlaWdodDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA8IDApIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIDxyZWZyZXNoPlxcJ3MgaGVpZ2h0ICgnICsgdmFsICsgJykgaXMgaW52YWxpZC4nKVxuICAgIH1cbiAgICB0aGlzLmNsYW1wID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBDb21wb25lbnQgPSBXZWV4LkNvbXBvbmVudFxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIGZ1bmN0aW9uIFJlZnJlc2ggKGRhdGEpIHtcbiAgICB0aGlzLmlzUmVmcmVzaGluZyA9IGZhbHNlXG4gICAgdGhpcy5jbGFtcCA9IChkYXRhLnN0eWxlLmhlaWdodCB8fCBERUZBVUxUX0NMQU1QKSAqIGRhdGEuc2NhbGVcbiAgICAhZGF0YS5zdHlsZS5hbGlnbkl0ZW1zICYmIChkYXRhLnN0eWxlLmFsaWduSXRlbXMgPSBERUZBVUxUX0FMSUdOX0lURU1TKVxuICAgICFkYXRhLnN0eWxlLmp1c3RpZnlDb250ZW50XG4gICAgICAmJiAoZGF0YS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IERFRkFVTFRfSlVTVElGWV9DT05URU5UKVxuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgUmVmcmVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChSZWZyZXNoLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChSZWZyZXNoLnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIGV4dGVuZChSZWZyZXNoLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgncmVmcmVzaCcsIFJlZnJlc2gpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2gvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlZnJlc2guY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlZnJlc2guY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVmcmVzaC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvcmVmcmVzaC9yZWZyZXNoLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud2VleC1yZWZyZXNoIHtcXG4gIC8vIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAvLyBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIC8vIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMDtcXG4gIHotaW5kZXg6IDk5OTk5OTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM2NjY7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvcmVmcmVzaC9yZWZyZXNoLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAnLi9sb2FkaW5nLmNzcydcblxuY29uc3QgcGFyZW50cyA9IFsnc2Nyb2xsZXInLCAnbGlzdCcsICd2bGlzdCddXG5cbmNvbnN0IERFRkFVTFRfQ0xBTVAgPSAxMzBcbmNvbnN0IERFRkFVTFRfQUxJR05fSVRFTVMgPSAnY2VudGVyJ1xuY29uc3QgREVGQVVMVF9KVVNUSUZZX0NPTlRFTlQgPSAnY2VudGVyJ1xuXG5mdW5jdGlvbiBhZGp1c3RIZWlnaHQgKGxvYWRpbmcsIHZhbCkge1xuICBsb2FkaW5nLm5vZGUuc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xufVxuXG5mdW5jdGlvbiBoYW5kbGVMb2FkaW5nIChsb2FkaW5nLCBlKSB7XG4gIGxvYWRpbmcubm9kZS5zdHlsZS5oZWlnaHQgPSBsb2FkaW5nLmNsYW1wICsgJ3B4J1xuICBsb2FkaW5nLmRpc3BhdGNoRXZlbnQoJ2xvYWRpbmcnKVxuICBsb2FkaW5nLmlzTG9hZGluZyA9IHRydWVcbn1cblxuZnVuY3Rpb24gc2hvdyAobG9hZGluZykge1xuICBsb2FkaW5nLmRpc3BsYXkgPSB0cnVlXG4gIGxvYWRpbmcubm9kZS5zdHlsZS5kaXNwbGF5ID0gJy13ZWJraXQtYm94J1xuICBsb2FkaW5nLm5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWZsZXgnXG4gIGxvYWRpbmcubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG59XG5cbmZ1bmN0aW9uIGhpZGUgKGxvYWRpbmcpIHtcbiAgbG9hZGluZy5kaXNwbGF5ID0gZmFsc2VcbiAgbG9hZGluZy5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgbG9hZGluZy5pc0xvYWRpbmcgPSBmYWxzZVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJywgJ3dlZXgtbG9hZGluZycpXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBvbkFwcGVuZCAoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3Qgc2Nyb2xsV3JhcEhlaWdodCA9IHBhcmVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgIGlmIChwYXJlbnRzLmluZGV4T2YocGFyZW50LmRhdGEudHlwZSkgPT09IC0xKSB7XG4gICAgICAvLyBub3QgaW4gYSBzY3JvbGxlciBvciBhIGxpc3RcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmxvYWRpbmdQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5sb2FkaW5nUGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCgnd2VleC1sb2FkaW5nLXBsYWNlaG9sZGVyJylcbiAgICB0aGlzLmxvYWRpbmdQbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgdGhpcy5sb2FkaW5nUGxhY2Vob2xkZXIuc3R5bGUud2lkdGggPSAnMHB4J1xuICAgIHRoaXMubG9hZGluZ1BsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9ICcwcHgnXG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHBhcmVudC5zY3JvbGxFbGVtZW50IHx8IHBhcmVudC5saXN0RWxlbWVudFxuICAgIHNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMubG9hZGluZ1BsYWNlaG9sZGVyLCB0aGlzLm5vZGUpXG4gICAgcGFyZW50Lm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICAgIHBhcmVudC5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKCdwdWxsdXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHNlbGYuaXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3Qgb2JqID0gZS5zY3JvbGxPYmpcbiAgICAgIGFkanVzdEhlaWdodChzZWxmLCBNYXRoLmFicyhcbiAgICAgICAgb2JqLmdldFNjcm9sbEhlaWdodCgpIC0gb2JqLmdldFNjcm9sbFRvcCgpIC0gc2Nyb2xsV3JhcEhlaWdodCkpXG4gICAgICBpZiAoIXNlbGYuZGlzcGxheSkge1xuICAgICAgICBzaG93KHNlbGYpXG4gICAgICB9XG4gICAgfSlcbiAgICBwYXJlbnQuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcigncHVsbHVwZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChzZWxmLmlzTG9hZGluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGhhbmRsZUxvYWRpbmcoc2VsZiwgZSlcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIGRpc3BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSAnc2hvdycpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzaG93KHRoaXMpXG4gICAgICB9LmJpbmQodGhpcyksIDApXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbCA9PT0gJ2hpZGUnKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGlkZSh0aGlzKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIGF0dHIgXFwnZGlzcGxheVxcJyBvZiA8cmVmcmVzaD5cXCc6IHZhbHVlICdcbiAgICAgICAgKyB2YWxcbiAgICAgICAgKyAnIGlzIGludmFsaWQuIFNob3VsZCBiZSBcXCdzaG93XFwnIG9yIFxcJ2hpZGVcXCcnKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzdHlsZSA9IHtcbiAgaGVpZ2h0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpXG4gICAgaWYgKE51bWJlci5pc05hTih2YWwpIHx8IHZhbCA8IDApIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIDxsb2FkaW5nPlxcJ3MgaGVpZ2h0ICgnICsgdmFsICsgJykgaXMgaW52YWxpZC4nKVxuICAgIH1cbiAgICB0aGlzLmNsYW1wID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBDb21wb25lbnQgPSBXZWV4LkNvbXBvbmVudFxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIGZ1bmN0aW9uIExvYWRpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmNsYW1wID0gKGRhdGEuc3R5bGUuaGVpZ2h0IHx8IERFRkFVTFRfQ0xBTVApICogZGF0YS5zY2FsZVxuICAgICFkYXRhLnN0eWxlLmFsaWduSXRlbXMgJiYgKGRhdGEuc3R5bGUuYWxpZ25JdGVtcyA9IERFRkFVTFRfQUxJR05fSVRFTVMpXG4gICAgIWRhdGEuc3R5bGUuanVzdGlmeUNvbnRlbnRcbiAgICAgICYmIChkYXRhLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gREVGQVVMVF9KVVNUSUZZX0NPTlRFTlQpXG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBMb2FkaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcbiAgZXh0ZW5kKExvYWRpbmcucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKExvYWRpbmcucHJvdG90eXBlLCB7IGF0dHIgfSlcbiAgZXh0ZW5kKExvYWRpbmcucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdsb2FkaW5nJywgTG9hZGluZylcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2xvYWRpbmcuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2xvYWRpbmcuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbG9hZGluZy5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbG9hZGluZy9sb2FkaW5nLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud2VleC1sb2FkaW5nIHtcXG4gIC8vIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAvLyBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIC8vIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM2NjY7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbG9hZGluZy9sb2FkaW5nLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIGxpYiAqL1xuXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0ICcuL2NhcnJvdXNlbCdcbmltcG9ydCAnLi9zbGlkZXIuY3NzJ1xuXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMzAwMFxuXG5sZXQgZXh0ZW5kLCBDb21wb25lbnRcblxuZnVuY3Rpb24gaWRsZVdoZW5QYWdlRGlzYXBwZWFyIChzbGlkZXIpIHtcbiAgZnVuY3Rpb24gaGFuZGxlUGFnZVNob3cgKCkge1xuICAgIHNsaWRlci5pc1BhZ2VTaG93ID0gdHJ1ZVxuICAgIHNsaWRlci5hdXRvUGxheSAmJiAhc2xpZGVyLmlzRG9tUmVuZGVyaW5nICYmIHNsaWRlci5wbGF5KClcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQYWdlSGlkZSAoKSB7XG4gICAgc2xpZGVyLmlzUGFnZVNob3cgPSBmYWxzZVxuICAgIHNsaWRlci5zdG9wKClcbiAgfVxuICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcbiAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgaGFuZGxlUGFnZUhpZGUpXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICBoYW5kbGVQYWdlU2hvdygpXG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIGhhbmRsZVBhZ2VIaWRlKClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlkbGVXaGVuRG9tUmVuZGVyaW5nIChzbGlkZXIpIHtcbiAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlcmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzbGlkZXIuaXNEb21SZW5kZXJpbmcgPSBmYWxzZVxuICAgIHNsaWRlci5hdXRvUGxheSAmJiBzbGlkZXIuaXNQYWdlU2hvdyAmJiBzbGlkZXIucGxheSgpXG4gIH0pXG4gIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXJiZWdpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzbGlkZXIuaXNEb21SZW5kZXJpbmcgPSB0cnVlXG4gICAgc2xpZGVyLnN0b3AoKVxuICB9KVxufVxuXG5mdW5jdGlvbiB1cGRhdGVJbmRpY2F0b3JzIChzbGlkZXIpIHtcbiAgc2xpZGVyLmluZGljYXRvciAmJiBzbGlkZXIuaW5kaWNhdG9yLnNldEluZGV4KHNsaWRlci5jdXJyZW50SW5kZXgpXG59XG5cbmZ1bmN0aW9uIGdldFNsaWRlckNoYW5nZUhhbmRsZXIgKHNsaWRlcikge1xuICBpZiAoIXNsaWRlci5fc2xpZGVyQ2hhbmdlSGFuZGxlcikge1xuICAgIHNsaWRlci5fc2xpZGVyQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2Fycm91c2VsLml0ZW1zLmluZGV4XG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4XG4gICAgICB1cGRhdGVJbmRpY2F0b3JzKHRoaXMpXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2NoYW5nZScsIHsgaW5kZXg6IGluZGV4IH0pXG4gICAgfS5iaW5kKHNsaWRlcilcbiAgfVxuICByZXR1cm4gc2xpZGVyLl9zbGlkZXJDaGFuZ2VIYW5kbGVyXG59XG5cbmZ1bmN0aW9uIGRvUmVuZGVyIChzbGlkZXIpIHtcbiAgc2xpZGVyLmNyZWF0ZUNoaWxkcmVuKClcbiAgc2xpZGVyLm9uQXBwZW5kKClcbn1cblxuY29uc3QgcHJvdG8gPSB7XG4gIGNyZWF0ZSAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdzbGlkZXInKVxuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBjcmVhdGVDaGlsZHJlbiAoKSB7XG4gICAgY29uc3QgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG5cbiAgICAvLyByZWNyZWF0ZSBzbGlkZXIgY29udGFpbmVyLlxuICAgIGlmICh0aGlzLnNsaWRlckNvbnRhaW5lcikge1xuICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMuc2xpZGVyQ29udGFpbmVyKVxuICAgIH1cbiAgICBpZiAodGhpcy5pbmRpY2F0b3IpIHtcbiAgICAgIHRoaXMuaW5kaWNhdG9yLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmluZGljYXRvci5ub2RlKVxuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuID0gW11cblxuICAgIGNvbnN0IHNsaWRlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJylcbiAgICBzbGlkZXJDb250YWluZXIuc3R5bGUubGlzdFN0eWxlID0gJ25vbmUnXG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHNsaWRlckNvbnRhaW5lcilcbiAgICB0aGlzLnNsaWRlckNvbnRhaW5lciA9IHNsaWRlckNvbnRhaW5lclxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZGF0YS5zY2FsZVxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgbGV0IGluZGljYXRvckRhdGEsIHdpZHRoLCBoZWlnaHRcbiAgICBsZXQgY2hpbGRXaWR0aCA9IDBcbiAgICBsZXQgY2hpbGRIZWlnaHQgPSAwXG5cbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZFxuICAgICAgICBjaGlsZHJlbltpXS5zY2FsZSA9IHRoaXMuZGF0YS5zY2FsZVxuICAgICAgICBjaGlsZHJlbltpXS5pbnN0YW5jZUlkID0gdGhpcy5kYXRhLmluc3RhbmNlSWRcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09ICdpbmRpY2F0b3InKSB7XG4gICAgICAgICAgaW5kaWNhdG9yRGF0YSA9IGV4dGVuZChjaGlsZHJlbltpXSwge1xuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgYW1vdW50OiBjaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2hpbGQgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoY2hpbGRyZW5baV0sICdsaScpXG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICAgICAgd2lkdGggPSBjaGlsZC5kYXRhLnN0eWxlLndpZHRoIHx8IDBcbiAgICAgICAgICBoZWlnaHQgPSBjaGlsZC5kYXRhLnN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgICAgd2lkdGggPiBjaGlsZFdpZHRoICYmIChjaGlsZFdpZHRoID0gd2lkdGgpXG4gICAgICAgICAgaGVpZ2h0ID4gY2hpbGRIZWlnaHQgJiYgKGNoaWxkSGVpZ2h0ID0gaGVpZ2h0KVxuICAgICAgICAgIGNoaWxkLnBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIGluZGljYXRvclxuICAgICAgaWYgKGluZGljYXRvckRhdGEpIHtcbiAgICAgICAgaW5kaWNhdG9yRGF0YS5leHRyYS53aWR0aCA9IHRoaXMuZGF0YS5zdHlsZS53aWR0aCB8fCBjaGlsZFdpZHRoXG4gICAgICAgIGluZGljYXRvckRhdGEuZXh0cmEuaGVpZ2h0ID0gdGhpcy5kYXRhLnN0eWxlLmhlaWdodCB8fCBjaGlsZEhlaWdodFxuICAgICAgICB0aGlzLmluZGljYXRvciA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChpbmRpY2F0b3JEYXRhKVxuICAgICAgICB0aGlzLmluZGljYXRvci5wYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gICAgICAgIHRoaXMuaW5kaWNhdG9yLnNsaWRlciA9IHRoaXNcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuaW5kaWNhdG9yLm5vZGUpXG4gICAgICB9XG5cbiAgICAgIHNsaWRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzY2FsZSAqIHRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgnXG4gICAgICBzbGlkZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpXG4gICAgfVxuICB9LFxuXG4gIGFwcGVuZENoaWxkIChkYXRhKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW4gfHwgKHRoaXMuZGF0YS5jaGlsZHJlbiA9IFtdKVxuICAgIGNoaWxkcmVuLnB1c2goZGF0YSlcbiAgICBkb1JlbmRlcih0aGlzKVxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0QmVmb3JlIChjaGlsZCwgYmVmb3JlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBsZXQgY2hpbGRJbmRleCA9IC0xXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGJlZm9yZS5kYXRhLnJlZikge1xuICAgICAgICBjaGlsZEluZGV4ID0gaVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGQuZGF0YSlcbiAgICBkb1JlbmRlcih0aGlzKVxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQ2hpbGQgKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEucmVmID09PSBjaGlsZHJlbltpXS5yZWYpIHtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvUmVuZGVyKHRoaXMpXG4gIH0sXG5cbiAgb25BcHBlbmQgKCkge1xuICAgIGlmICh0aGlzLmNhcnJvdXNlbCkge1xuICAgICAgdGhpcy5jYXJyb3VzZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZ2V0U2xpZGVyQ2hhbmdlSGFuZGxlcih0aGlzKSlcbiAgICAgIHRoaXMuY2Fycm91c2VsLnN0b3AoKVxuICAgICAgdGhpcy5jYXJyb3VzZWwgPSBudWxsXG4gICAgfVxuICAgIGNvbnN0IENhcnJvdXNlbCA9IGxpYi5jYXJyb3VzZWxcbiAgICB0aGlzLmNhcnJvdXNlbCA9IG5ldyBDYXJyb3VzZWwodGhpcy5zbGlkZXJDb250YWluZXIsIHtcbiAgICAgIGF1dG9wbGF5OiB0aGlzLmF1dG9QbGF5LFxuICAgICAgdXNlR2VzdHVyZTogdHJ1ZVxuICAgIH0pXG5cbiAgICB0aGlzLmNhcnJvdXNlbC5wbGF5SW50ZXJ2YWwgPSB0aGlzLmludGVydmFsXG4gICAgdGhpcy5jYXJyb3VzZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZ2V0U2xpZGVyQ2hhbmdlSGFuZGxlcih0aGlzKSlcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDBcblxuICAgIC8vIHByZWxvYWQgYWxsIGltYWdlcyBmb3Igc2xpZGVyXG4gICAgLy8gYmVjYXVzZTpcbiAgICAvLyAxLiBsaWItaW1nIGRvZXNuJ3QgbGlzdGVuIHRvIGV2ZW50IHRyYW5zaXRpb25lbmRcbiAgICAvLyAyLiBldmVuIGlmIHdlIGZpcmUgbGF6eSBsb2FkIGluIHNsaWRlcidzIGNoYW5nZSBldmVudCBoYW5kbGVyLFxuICAgIC8vICAgIHRoZSBuZXh0IGltYWdlIHN0aWxsIHdvbid0IGJlIHByZWxvYWRlZCB1dGlsbCB0aGUgbW9tZW50IGl0XG4gICAgLy8gICAgc2xpZGVzIGludG8gdGhlIHZpZXcsIHdoaWNoIGlzIHRvbyBsYXRlLlxuICAgIGlmICh0aGlzLnByZWxvYWRJbWdzVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnByZWxvYWRJbWdzVGltZXIpXG4gICAgfVxuICAgIC8vIFRoZSB0aW1lIGp1c3QgYmVmb3JlIHRoZSBzZWNvbmQgc2xpZGUgYXBwZWFyIGFuZCBlbm91Z2hcbiAgICAvLyBmb3IgYWxsIGNoaWxkIGVsZW1lbnRzIHRvIGFwcGVuZCBpcyBvay5cbiAgICBjb25zdCBwcmVsb2FkVGltZSA9IDAuOFxuICAgIHRoaXMucHJlbG9hZEltZ3NUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgaW1ncyA9IHRoaXMuY2Fycm91c2VsLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLndlZXgtaW1nJylcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gaW1ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW1nID0gaW1nc1tpXVxuICAgICAgICBjb25zdCBpTGF6eVNyYyA9IGltZy5nZXRBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICAgICAgICBjb25zdCBpbWdTcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdpbWctc3JjJylcbiAgICAgICAgaWYgKGlMYXp5U3JjKSB7XG4gICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIGlMYXp5U3JjICsgJyknXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1nU3JjKSB7XG4gICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIGltZ1NyYyArICcpJ1xuICAgICAgICB9XG4gICAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdpbWctc3JjJylcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyksIHByZWxvYWRUaW1lICogMTAwMClcblxuICAgIC8vIGF2b2lkIHBhZ2Ugc2Nyb2xsIHdoZW4gcGFubmluZ1xuICAgIGxldCBwYW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLmNhcnJvdXNlbC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgIHBhbm5pbmcgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmNhcnJvdXNlbC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgICBwYW5uaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwYW5uaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcblxuICAgIENvbXBvbmVudC5wcm90b3R5cGUub25BcHBlbmQuY2FsbCh0aGlzKVxuICB9LFxuXG4gIHBsYXkgKCkge1xuICAgIHRoaXMuY2Fycm91c2VsLnBsYXkoKVxuICB9LFxuXG4gIHN0b3AgKCkge1xuICAgIHRoaXMuY2Fycm91c2VsLnN0b3AoKVxuICB9LFxuXG4gIHNsaWRlVG8gKGluZGV4KSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggLSB0aGlzLmN1cnJlbnRJbmRleFxuICAgIHRoaXMuY2Fycm91c2VsLml0ZW1zLnNsaWRlKG9mZnNldClcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBpbnRlcnZhbDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBwYXJzZUludCh2YWwpIHx8IERFRkFVTFRfSU5URVJWQUxcbiAgICBpZiAodGhpcy5jYXJyb3VzZWwpIHtcbiAgICAgIHRoaXMuY2Fycm91c2VsLnBsYXlJbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWxcbiAgICB9XG4gIH0sXG5cbiAgaW5kZXg6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXNcbiAgICBmdW5jdGlvbiBkb1NsaWRlIChpbmRleCkge1xuICAgICAgaW5kZXggPSBwYXJzZUludChpbmRleClcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGluZGV4ICcsIGluZGV4KVxuICAgICAgfVxuICAgICAgX3RoaXMuc2xpZGVUbyhpbmRleClcbiAgICAgIGlmIChfdGhpcy5fdXBkYXRlSW5kZXgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbmRlcmVuZCcsIF90aGlzLl91cGRhdGVJbmRleClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEb21SZW5kZXJpbmcpIHtcbiAgICAgIGNvbnN0IHByZSA9ICEhdGhpcy5fdXBkYXRlSW5kZXhcbiAgICAgIHRoaXMuX3VwZGF0ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hdXRvUGxheSAmJiBfdGhpcy5pc1BhZ2VTaG93ICYmIF90aGlzLnBsYXkoKVxuICAgICAgICBkb1NsaWRlKHZhbClcbiAgICAgIH1cbiAgICAgICFwcmUgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlcmVuZCcsIHRoaXMuX3VwZGF0ZUluZGV4KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRvU2xpZGUodmFsKVxuICAgIH1cbiAgfSxcblxuICBwbGF5c3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5wbGF5c3RhdHVzID0gdmFsICYmIHZhbCAhPT0gJ2ZhbHNlJ1xuICAgIHRoaXMuYXV0b1BsYXkgPSB0aGlzLnBsYXlzdGF0dXNcbiAgICBpZiAodGhpcy5jYXJyb3VzZWwpIHtcbiAgICAgIGlmICh0aGlzLnBsYXlzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBzdXBwb3J0IHBsYXlzdGF0dXMnIGFsaWFzIGF1dG8tcGxheSBmb3IgY29tcGF0aWJpbGl0eVxuICBhdXRvUGxheTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuYXR0ci5wbGF5c3RhdHVzLmNhbGwodGhpcywgdmFsKVxuICB9XG59XG5cbmNvbnN0IGV2ZW50ID0ge1xuICBjaGFuZ2U6IHtcbiAgICB1cGRhdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGluZGV4OiB0aGlzLmN1cnJlbnRJbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcbiAgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICBmdW5jdGlvbiBTbGlkZXIgKGRhdGEpIHtcbiAgICB0aGlzLmF1dG9QbGF5ID0gZmFsc2UgIC8vIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG4gICAgdGhpcy5pbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUxcbiAgICB0aGlzLmRpcmVjdGlvbiA9ICdyb3cnIC8vICdjb2x1bW4nIGlzIG5vdCB0ZW1wb3JhcmlseSBzdXBwb3J0ZWQuXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdXG4gICAgdGhpcy5pc1BhZ2VTaG93ID0gdHJ1ZVxuICAgIHRoaXMuaXNEb21SZW5kZXJpbmcgPSB0cnVlXG5cbiAgICAvLyBiaW5kIGV2ZW50ICdwYWdlc2hvdycsICdwYWdlaGlkZScgYW5kICd2aXNpYmlsaXR5Y2hhbmdlJyBvbiB3aW5kb3cuXG4gICAgaWRsZVdoZW5QYWdlRGlzYXBwZWFyKHRoaXMpXG4gICAgLy8gYmluZCBldmVudCAncmVuZGVyQmVnaW4nIGFuZCAncmVuZGVyRW5kJyBvbiB3aW5kb3cuXG4gICAgaWRsZVdoZW5Eb21SZW5kZXJpbmcodGhpcylcblxuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgU2xpZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcbiAgZXh0ZW5kKFNsaWRlci5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoU2xpZGVyLnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIGV4dGVuZChTbGlkZXIucHJvdG90eXBlLCB7IGV2ZW50IH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc2xpZGVyJywgU2xpZGVyKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyByZXF1aXJlKCcuL2dlc3R1cmUnKVxucmVxdWlyZSgnY3ViaWNiZXppZXInKVxucmVxdWlyZSgnYW5pbWF0aW9uanMnKVxucmVxdWlyZSgnLi9jYXJyb3VzZWwuY3NzJylcblxudmFyIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxudmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbnZhciBGaXJlZm94ID0gISF1YS5tYXRjaCgvRmlyZWZveC9pKVxudmFyIElFTW9iaWxlID0gISF1YS5tYXRjaCgvSUVNb2JpbGUvaSlcbnZhciBjc3NQcmVmaXggPSBGaXJlZm94ID8gJy1tb3otJyA6IElFTW9iaWxlID8gJy1tcy0nIDogJy13ZWJraXQtJ1xudmFyIHN0eWxlUHJlZml4ID0gRmlyZWZveCA/ICdNb3onIDogSUVNb2JpbGUgPyAnbXMnIDogJ3dlYmtpdCdcblxudmFyIHRpbWVyID0gcmVxdWlyZSgnLi90aW1lcicpXG52YXIgc2V0VGltZW91dCA9IHRpbWVyLnNldFRpbWVvdXRcbnZhciBjbGVhclRpbWVvdXQgPSB0aW1lci5jbGVhclRpbWVvdXRcblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT2Zmc2V0KGVsZW1lbnQpIHtcbiAgdmFyIG9mZnNldCA9IHsgeDogMCwgeTogMCB9XG4gIHZhciB0cmFuc2Zvcm0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gIHZhciByZWdNYXRyaXgzZCA9IG5ldyBSZWdFeHAoJ15tYXRyaXgzZFxcXFwoKD86Wy1cXFxcZC5dKyxcXFxccyopezEyfShbLVxcXFxkLl0rKSwnXG4gICAgKyAnXFxcXHMqKFstXFxcXGQuXSspKD86LFxcXFxzKlstXFxcXGQuXSspezJ9XFxcXCknKVxuICB2YXIgcmVnTWF0cml4ID0gL15tYXRyaXhcXCgoPzpbLVxcZC5dKyxcXHMqKXs0fShbLVxcZC5dKyksXFxzKihbLVxcZC5dKylcXCkkL1xuICB2YXIgbWF0Y2hlZFxuXG4gIGlmICh0cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgIGlmICgobWF0Y2hlZCA9IHRyYW5zZm9ybS5tYXRjaChyZWdNYXRyaXgzZClcbiAgICAgIHx8IHRyYW5zZm9ybS5tYXRjaChyZWdNYXRyaXgpKSkge1xuICAgICAgb2Zmc2V0LnggPSBwYXJzZUZsb2F0KG1hdGNoZWRbMV0pIHx8IDBcbiAgICAgIG9mZnNldC55ID0gcGFyc2VGbG9hdChtYXRjaGVkWzJdKSB8fCAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldFxufVxuXG52YXIgQ1NTTWF0cml4ID0gSUVNb2JpbGUgPyAnTVNDU1NNYXRyaXgnIDogJ1dlYktpdENTU01hdHJpeCdcbnZhciBoYXMzZCA9ICEhRmlyZWZveCB8fCBDU1NNYXRyaXggaW4gd2luZG93ICYmICdtMTEnIGluIG5ldyB3aW5kb3dbQ1NTTWF0cml4XSgpXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoeCwgeSkge1xuICB4ID0gcGFyc2VGbG9hdCh4KVxuICB5ID0gcGFyc2VGbG9hdCh5KVxuXG4gIGlmICh4ICE9IDApIHtcbiAgICB4ICs9ICdweCdcbiAgfVxuXG4gIGlmICh5ICE9IDApIHtcbiAgICB5ICs9ICdweCdcbiAgfVxuXG4gIGlmIChoYXMzZCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoJyArIHggKyAnLCAnICsgeSArICcsIDApJ1xuICB9XG5cbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJ1xufVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbmZ1bmN0aW9uIEFycmF5RnJvbShhKSB7XG4gIHJldHVybiBzbGljZS5jYWxsKGEpXG59XG5cbnZhciBpbmNJZCA9IDBcbmZ1bmN0aW9uIENhcnJvdXNlbChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgdmlld3MgPSBbXVxuICB2YXIgcGFnZXMgPSB7fVxuICB2YXIgaWQgPSBEYXRlLm5vdygpICsgJy0nICsgKCsraW5jSWQpXG4gIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIShhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdXG4gICAgZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpXG4gICAgcm9vdC5hcHBlbmRDaGlsZChlbGVtZW50KVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3RybC1uYW1lJywgJ2NhcnJvdXNlbCcpXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWN0cmwtaWQnLCBpZClcblxuICBmdW5jdGlvbiBmaXJlRXZlbnQobmFtZSwgZXh0cmEpIHtcbiAgICB2YXIgZXYgPSBkb2MuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICAgIGV2LmluaXRFdmVudChuYW1lLCBmYWxzZSwgZmFsc2UpXG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpIHtcbiAgICAgICAgZXZba2V5XSA9IGV4dHJhW2tleV1cbiAgICAgIH1cbiAgICB9XG4gICAgcm9vdC5kaXNwYXRjaEV2ZW50KGV2KVxuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSdcbiAgZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXSA9IGdldFRyYW5zbGF0ZSgwLCAwKVxuXG4gIHZhciB0cmFuc2Zvcm1PZmZzZXQgPSAwXG4gIHZhciBpdGVtcyA9IHt9XG4gIHZhciBpdGVtTGVuZ3RoID0gMFxuICB2YXIgaXRlbVN0ZXAgPSBvcHRpb25zLnN0ZXAgfHwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICB2YXIgaXRlbUluZGV4ID0gMFxuXG4gIGl0ZW1zLmFkZCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKVxuICAgIGxpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICBsaS5zdHlsZS5mbG9hdCA9ICdsZWZ0J1xuICAgIGxpLmluZGV4ID0gaXRlbUxlbmd0aFxuICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxpLmlubmVySFRNTCA9IGh0bWxcbiAgICB9IGVsc2UgaWYgKGh0bWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbGkuYXBwZW5kQ2hpbGQoaHRtbClcbiAgICB9XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChsaSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtcywgaXRlbUxlbmd0aCArICcnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGl0ZW1MZW5ndGgrK1xuICAgIHJldHVybiBsaVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCArPSBpdGVtTGVuZ3RoXG4gICAgfVxuXG4gICAgd2hpbGUgKGluZGV4ID49IGl0ZW1MZW5ndGgpIHtcbiAgICAgIGluZGV4IC09IGl0ZW1MZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhcbiAgfVxuXG4gIGl0ZW1zLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpdGVtc1tub3JtYWxpemVJbmRleChpbmRleCldXG4gIH1cblxuICBpdGVtcy5nZXRDbG9uZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBub3JtYWxpemVJbmRleChpbmRleClcbiAgICB2YXIgaXRlbSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignW2Nsb25lZD1cImNsb25lZC0nICsgaW5kZXggKyAnXCJdJylcbiAgICB2YXIgb3JpZ2luYWxJdGVtID0gaXRlbXNbaW5kZXhdXG5cbiAgICAvLyBJZiB0aGVyZSBhIF9saXN0ZW5lcnMgYXR0cmlidXRlIG9uIHRoZSBkb20gZWxlbWVudFxuICAgIC8vIHRoZW4gY2xvbmUgdGhlIF9saXN0ZW5lcnMgYXMgd2VsbCBmb3IgdGhlIGV2ZW50cycgYmluZGluZ1xuICAgIGZ1bmN0aW9uIGNsb25lRXZlbnRzKG9yaWdpbiwgY2xvbmUsIGRlZXApIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBvcmlnaW4uX2xpc3RlbmVyc1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBjbG9uZS5fbGlzdGVuZXJzID0gbGlzdGVuZXJzXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgY2xvbmUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbdHlwZV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWVwICYmIG9yaWdpbi5jaGlsZHJlbiAmJiBvcmlnaW4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3JpZ2luLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNsb25lRXZlbnRzKG9yaWdpbi5jaGlsZHJlbltpXSwgY2xvbmUuY2hpbGRyZW5baV0sIGRlZXApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGl0ZW0gPSBvcmlnaW5hbEl0ZW0uY2xvbmVOb2RlKHRydWUpXG4gICAgICBjbG9uZUV2ZW50cyhvcmlnaW5hbEl0ZW0sIGl0ZW0sIHRydWUpXG5cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbSlcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdjbG9uZWQnLCAnY2xvbmVkLScgKyBpbmRleClcbiAgICAgIGl0ZW0uaW5kZXggPSBpbmRleFxuICAgIH1cblxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZShpbmRleCkge1xuICAgIGlmIChpdGVtTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VySXRlbSA9IGl0ZW1zLmdldChpbmRleClcbiAgICB2YXIgcHJldkl0ZW1cbiAgICB2YXIgbmV4dEl0ZW1cblxuICAgIGlmIChpdGVtTGVuZ3RoID4gMSkge1xuICAgICAgcHJldkl0ZW0gPSBpdGVtcy5nZXQoaW5kZXggLSAxKVxuXG4gICAgICBpZiAoaXRlbUxlbmd0aCA9PT0gMikge1xuICAgICAgICBuZXh0SXRlbSA9IGl0ZW1zLmdldENsb25lZChpbmRleCArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SXRlbSA9IGl0ZW1zLmdldChpbmRleCArIDEpXG4gICAgICB9XG5cbiAgICAgIGN1ckl0ZW0uc3R5bGUubGVmdCA9IC10cmFuc2Zvcm1PZmZzZXQgKyAncHgnXG4gICAgICBwcmV2SXRlbS5zdHlsZS5sZWZ0ID0gKC10cmFuc2Zvcm1PZmZzZXQgLSBpdGVtU3RlcCkgKyAncHgnXG4gICAgICBuZXh0SXRlbS5zdHlsZS5sZWZ0ID0gKC10cmFuc2Zvcm1PZmZzZXQgKyBpdGVtU3RlcCkgKyAncHgnXG4gICAgfVxuXG4gICAgaXRlbUluZGV4ID0gY3VySXRlbS5pbmRleFxuXG4gICAgZmlyZUV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICBwcmV2SXRlbTogcHJldkl0ZW0sXG4gICAgICBjdXJJdGVtOiBjdXJJdGVtLFxuICAgICAgbmV4dEl0ZW06IG5leHRJdGVtXG4gICAgfSlcbiAgfVxuXG4gIGl0ZW1zLnNsaWRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGl0ZW1MZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpdGVtTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbmRleCA9IDBcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBnZXRUcmFuc2Zvcm1PZmZzZXQoZWxlbWVudCkueFxuICAgIHZhciBlbmRPZmZzZXQgPSB0cmFuc2Zvcm1PZmZzZXQgKyBpdGVtU3RlcCAqICgtaW5kZXgpXG4gICAgdmFyIGludGVyT2Zmc2V0ID0gZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXRcblxuICAgIGlmIChpbnRlck9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGFuaW0gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgIDQwMCxcbiAgICAgIGxpYi5jdWJpY2Jlemllci5lYXNlLFxuICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgICAgPSBnZXRUcmFuc2xhdGUoc3RhcnRPZmZzZXQgKyBpbnRlck9mZnNldCAqIGkyLCAwKVxuICAgICAgfSkucGxheSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFuc2Zvcm1PZmZzZXQgPSBlbmRPZmZzZXRcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXSA9IGdldFRyYW5zbGF0ZShlbmRPZmZzZXQsIDApXG4gICAgICAgIGluZGV4ICYmIGFjdGl2YXRlKGl0ZW1JbmRleCArIGluZGV4KVxuICAgICAgfSlcbiAgfVxuXG4gIGl0ZW1zLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaXRlbXMuc2xpZGUoMSlcbiAgfVxuXG4gIGl0ZW1zLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaXRlbXMuc2xpZGUoLTEpXG4gIH1cblxuICBBcnJheUZyb20oZWxlbWVudC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICBlbC5zdHlsZS50b3AgPSAnMCdcbiAgICBlbC5zdHlsZS5sZWZ0ID0gaXRlbUxlbmd0aCAqIGl0ZW1TdGVwICsgJ3B4J1xuICAgIGVsLnN0eWxlLmZsb2F0ID0gJ2xlZnQnXG4gICAgZWwuaW5kZXggPSBpdGVtTGVuZ3RoXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW1zLCBpdGVtTGVuZ3RoICsgJycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZWxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaXRlbUxlbmd0aCsrXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpdGVtcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH1cbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXRlbXMsICdsZW5ndGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlbUxlbmd0aFxuICAgIH1cbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXRlbXMsICdpbmRleCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVtSW5kZXhcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW1zLCAnc3RlcCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVtU3RlcFxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICBpdGVtU3RlcCA9IHZcbiAgICB9XG4gIH0pXG5cbiAgdmFyIHN0YXJ0aW5nID0gZmFsc2VcbiAgdmFyIHBsYXlpbmcgPSBmYWxzZVxuICB2YXIgaXNTbGlkaW5nID0gZmFsc2VcbiAgdGhpcy5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3RhcnRpbmcpIHtcbiAgICAgIHN0YXJ0aW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIGFjdGl2YXRlKDApXG4gICAgfVxuXG4gICAgaWYgKCEhcGxheWluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcGxheWluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIGlzU2xpZGluZyA9IHRydWVcbiAgICAgIGl0ZW1zLm5leHQoKVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzU2xpZGluZyA9IGZhbHNlXG4gICAgICB9LCA1MDApXG4gICAgICBwbGF5aW5nID0gc2V0VGltZW91dChwbGF5LCA0MDAgKyBwbGF5SW50ZXJ2YWwpXG4gICAgfSwgNDAwICsgcGxheUludGVydmFsKVxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGxheWluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNsZWFyVGltZW91dChwbGF5aW5nKVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcGxheWluZyA9IGZhbHNlXG4gICAgfSwgNTAwKVxuICB9XG5cbiAgdmFyIGF1dG9wbGF5ID0gZmFsc2VcbiAgdmFyIHJlYWR5VG9QbGF5ID0gZmFsc2VcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhdXRvcGxheScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhdXRvcGxheVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgYXV0b3BsYXkgPSAhIXZcbiAgICAgIGlmIChyZWFkeVRvUGxheSkge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVhZHlUb1BsYXkpXG4gICAgICAgIHJlYWR5VG9QbGF5ID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgICByZWFkeVRvUGxheSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQucGxheSgpXG4gICAgICAgIH0sIDIwMDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LnN0b3AoKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgdGhpcy5hdXRvcGxheSA9ICEhb3B0aW9ucy5hdXRvcGxheVxuXG4gIHZhciBwbGF5SW50ZXJ2YWwgPSAxNTAwXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGxheUludGVydmFsJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBsYXlJbnRlcnZhbFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAobikge1xuICAgICAgcGxheUludGVydmFsID0gblxuICAgIH1cbiAgfSlcbiAgdGhpcy5wbGF5SW50ZXJ2YWwgPSAhIW9wdGlvbnMucGxheUludGVydmFsIHx8IDE1MDBcblxuICBpZiAob3B0aW9ucy51c2VHZXN0dXJlKSB7XG4gICAgdmFyIHBhbm5pbmcgPSBmYWxzZVxuICAgIHZhciBkaXNwbGFjZW1lbnRcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1ZlcnRpY2FsICYmICEocGFubmluZyAmJiBpc1NsaWRpbmcpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgaWYgKGF1dG9wbGF5KSB7XG4gICAgICAgICAgdGhhdC5zdG9wKClcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYWNlbWVudCA9IDBcbiAgICAgICAgcGFubmluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYW5tb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1ZlcnRpY2FsICYmIHBhbm5pbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgZGlzcGxhY2VtZW50ID0gZS5kaXNwbGFjZW1lbnRYXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNmb3JtJ11cbiAgICAgICAgICA9IGdldFRyYW5zbGF0ZSh0cmFuc2Zvcm1PZmZzZXQgKyBkaXNwbGFjZW1lbnQsIDApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFuZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1ZlcnRpY2FsICYmIHBhbm5pbmcpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgcGFubmluZyA9IGZhbHNlXG4gICAgICAgIGlmIChlLmlzU3dpcGUpIHtcbiAgICAgICAgICBpZiAoZGlzcGxhY2VtZW50IDwgMCkge1xuICAgICAgICAgICAgaXRlbXMubmV4dCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1zLnByZXYoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzcGxhY2VtZW50KSA8IGl0ZW1TdGVwIC8gMikge1xuICAgICAgICAgICAgaXRlbXMuc2xpZGUoMClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXMuc2xpZGUoZGlzcGxhY2VtZW50IDwgMD8xOi0xKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5wbGF5KClcbiAgICAgICAgICB9LCAyMDAwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZmFsc2UpXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXBlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgZmFsc2UpXG4gIH1cblxuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIGZhbHNlKVxuICB9XG5cbiAgdGhpcy5yb290ID0gcm9vdFxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG59XG5cbiFsaWIgJiYgKGxpYiA9IHt9KVxubGliLmNhcnJvdXNlbCA9IENhcnJvdXNlbFxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL2NhcnJvdXNlbC5qc1xuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyxkKXtmdW5jdGlvbiBlKGEpe3JldHVybigzKmsqYSsyKmwpKmErbX1mdW5jdGlvbiBmKGEpe3JldHVybigoayphK2wpKmErbSkqYX1mdW5jdGlvbiBnKGEpe3JldHVybigobiphK28pKmErcCkqYX1mdW5jdGlvbiBoKGEpe2Zvcih2YXIgYixjLGQ9YSxnPTA7OD5nO2crKyl7aWYoYz1mKGQpLWEsTWF0aC5hYnMoYyk8ailyZXR1cm4gZDtpZihiPWUoZCksTWF0aC5hYnMoYik8ailicmVhaztkLT1jL2J9dmFyIGg9MSxpPTA7Zm9yKGQ9YTtoPmk7KXtpZihjPWYoZCktYSxNYXRoLmFicyhjKTxqKXJldHVybiBkO2M+MD9oPWQ6aT1kLGQ9KGgraSkvMn1yZXR1cm4gZH1mdW5jdGlvbiBpKGEpe3JldHVybiBnKGgoYSkpfXZhciBqPTFlLTYsaz0zKmEtMypjKzEsbD0zKmMtNiphLG09MyphLG49MypiLTMqZCsxLG89MypkLTYqYixwPTMqYjtyZXR1cm4gaX1iLmN1YmljYmV6aWVyPWMsYi5jdWJpY2Jlemllci5saW5lYXI9YygwLDAsMSwxKSxiLmN1YmljYmV6aWVyLmVhc2U9YyguMjUsLjEsLjI1LDEpLGIuY3ViaWNiZXppZXIuZWFzZUluPWMoLjQyLDAsMSwxKSxiLmN1YmljYmV6aWVyLmVhc2VPdXQ9YygwLDAsLjU4LDEpLGIuY3ViaWNiZXppZXIuZWFzZUluT3V0PWMoLjQyLDAsLjU4LDEpfSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWydjdWJpY2JlemllciddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2N1YmljYmV6aWVyL2J1aWxkL2N1YmljYmV6aWVyLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBzZXRUaW1lb3V0KGEsbCl9ZnVuY3Rpb24gZChhKXtjbGVhclRpbWVvdXQoYSl9ZnVuY3Rpb24gZSgpe3ZhciBhPXt9LGI9bmV3IG0oZnVuY3Rpb24oYixjKXthLnJlc29sdmU9YixhLnJlamVjdD1jfSk7cmV0dXJuIGEucHJvbWlzZT1iLGF9ZnVuY3Rpb24gZihhLGIpe3JldHVybltcInRoZW5cIixcImNhdGNoXCJdLmZvckVhY2goZnVuY3Rpb24oYyl7YltjXT1mdW5jdGlvbigpe3JldHVybiBhW2NdLmFwcGx5KGEsYXJndW1lbnRzKX19KSxifWZ1bmN0aW9uIGcoYil7dmFyIGMsZCxoPSExO3RoaXMucmVxdWVzdD1mdW5jdGlvbigpe2g9ITE7dmFyIGc9YXJndW1lbnRzO3JldHVybiBjPWUoKSxmKGMucHJvbWlzZSx0aGlzKSxkPW4oZnVuY3Rpb24oKXtofHxjJiZjLnJlc29sdmUoYi5hcHBseShhLGcpKX0pLHRoaXN9LHRoaXMuY2FuY2VsPWZ1bmN0aW9uKCl7cmV0dXJuIGQmJihoPSEwLG8oZCksYyYmYy5yZWplY3QoXCJDQU5DRUxcIikpLHRoaXN9LHRoaXMuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcoYil9fWZ1bmN0aW9uIGgoYSxiKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoYj17MDpifSk7Zm9yKHZhciBjPWEvbCxkPTEvYyxlPVtdLGY9T2JqZWN0LmtleXMoYikubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBwYXJzZUludChhKX0pLGg9MDtjPmg7aCsrKXt2YXIgaT1mWzBdLGo9ZCpoO2lmKG51bGwhPWkmJjEwMCpqPj1pKXt2YXIgaz1iW1wiXCIraV07ayBpbnN0YW5jZW9mIGd8fChrPW5ldyBnKGspKSxlLnB1c2goayksZi5zaGlmdCgpfWVsc2UgZS5sZW5ndGgmJmUucHVzaChlW2UubGVuZ3RoLTFdLmNsb25lKCkpfXJldHVybiBlfWZ1bmN0aW9uIGkoYSl7dmFyIGM7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF8fGEgaW5zdGFuY2VvZiBBcnJheT9iLmN1YmljYmV6aWVyP1wic3RyaW5nXCI9PXR5cGVvZiBhP2IuY3ViaWNiZXppZXJbYV0mJihjPWIuY3ViaWNiZXppZXJbYV0pOmEgaW5zdGFuY2VvZiBBcnJheSYmND09PWEubGVuZ3RoJiYoYz1iLmN1YmljYmV6aWVyLmFwcGx5KGIuY3ViaWNiZXppZXIsYSkpOmNvbnNvbGUuZXJyb3IoXCJyZXF1aXJlIGxpYi5jdWJpY2JlemllclwiKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYoYz1hKSxjfWZ1bmN0aW9uIGooYSxiLGMpe3ZhciBkLGc9aChhLGMpLGo9MS8oYS9sKSxrPTAsbT1pKGIpO2lmKCFtKXRocm93IG5ldyBFcnJvcihcInVuZXhjZXB0IHRpbWluZyBmdW5jdGlvblwiKTt2YXIgbj0hMTt0aGlzLnBsYXk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGM9aiooaysxKS50b0ZpeGVkKDEwKSxlPWdba107ZS5yZXF1ZXN0KGMudG9GaXhlZCgxMCksYihjKS50b0ZpeGVkKDEwKSkudGhlbihmdW5jdGlvbigpe24mJihrPT09Zy5sZW5ndGgtMT8obj0hMSxkJiZkLnJlc29sdmUoXCJGSU5JU0hcIiksZD1udWxsKTooaysrLGEoKSkpfSxmdW5jdGlvbigpe30pfWlmKCFuKXJldHVybiBuPSEwLGR8fChkPWUoKSxmKGQucHJvbWlzZSx0aGlzKSksYSgpLHRoaXN9LHRoaXMuc3RvcD1mdW5jdGlvbigpe3JldHVybiBuPyhuPSExLGdba10mJmdba10uY2FuY2VsKCksdGhpcyk6dm9pZCAwfX12YXIgaz02MCxsPTFlMy9rLG09YS5Qcm9taXNlfHxiLnByb21pc2UmJmIucHJvbWlzZS5FUzZQcm9taXNlLG49d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxjLG89d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fGQ7KG49PT1jfHxvPT09ZCkmJihuPWMsbz1kKSxiLmFuaW1hdGlvbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBqKGEsYixjKX0sYi5hbmltYXRpb24uZnJhbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBnKGEpfSxiLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWU9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGcoYSk7cmV0dXJuIGIucmVxdWVzdCgpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnYW5pbWF0aW9uJ107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYW5pbWF0aW9uanMvYnVpbGQvYW5pbWF0aW9uLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jYXJyb3VzZWwuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NhcnJvdXNlbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jYXJyb3VzZWwuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zbGlkZXIvY2Fycm91c2VsLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJbZGF0YS1jdHJsLW5hbWU9XFxcImNhcnJvdXNlbFxcXCJdIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDFweCk7XFxuICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDFweCk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMXB4KTtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL2NhcnJvdXNlbC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgX2ZhbGxiYWNrID0gZmFsc2VcblxudmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuaWYgKCFyYWYpIHtcbiAgX2ZhbGxiYWNrID0gdHJ1ZVxuICByYWYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMTYpXG4gIH1cbn1cbnZhciBjYWYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lXG5pZiAoIWNhZiAmJiBfZmFsbGJhY2spIHtcbiAgY2FmID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZClcbiAgfVxufSBlbHNlIGlmICghY2FmKSB7XG4gIGNhZiA9IGZ1bmN0aW9uKCkge31cbn1cblxudmFyIE1BWCA9IChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxKSAtIDFcblxudmFyIF9pZE1hcCA9IHt9XG52YXIgX2dsb2JhbElkID0gMFxuXG5mdW5jdGlvbiBfZ2V0R2xvYmFsSWQoKSB7XG4gIF9nbG9iYWxJZCA9IChfZ2xvYmFsSWQgKyAxKSAlIE1BWFxuICBpZiAoX2lkTWFwW19nbG9iYWxJZF0pIHtcbiAgICByZXR1cm4gX2dldEdsb2JhbElkKClcbiAgfVxuICByZXR1cm4gX2dsb2JhbElkXG59XG5cbnZhciB0aW1lciA9IHtcblxuICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoY2IsIG1zKSB7XG4gICAgdmFyIGlkID0gX2dldEdsb2JhbElkKClcbiAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgX2lkTWFwW2lkXSA9IHJhZihmdW5jdGlvbiBsb29wKCkge1xuICAgICAgaWYgKCFfaWRNYXBbaWRdICYmIF9pZE1hcFtpZF0gIT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgaW5kID0gRGF0ZS5ub3coKSAtIHN0YXJ0XG4gICAgICBpZiAoaW5kIDwgbXMpIHtcbiAgICAgICAgX2lkTWFwW2lkXSA9IHJhZihsb29wKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIF9pZE1hcFtpZF1cbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH0sXG5cbiAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgdGlkID0gX2lkTWFwW2lkXVxuICAgIHRpZCAmJiBjYWYodGlkKVxuICAgIGRlbGV0ZSBfaWRNYXBbaWRdXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3RpbWVyLmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NsaWRlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zbGlkZXIvc2xpZGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2xpZGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgYm94LXBhY2s6IGNlbnRlcjtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMDtcXG59XFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lciAuaW5kaWNhdG9yIHtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lci5yb3cge1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcbiAgYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIuY29sdW1uIHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICBib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9pbmRpY2F0b3IuY3NzJylcblxuY29uc3QgREVGQVVMVF9JVEVNX0NPTE9SID0gJyM5OTknXG5jb25zdCBERUZBVUxUX0lURU1fU0VMRUNURURfQ09MT1IgPSAnIzAwMDBmZidcbmNvbnN0IERFRkFVTFRfSVRFTV9TSVpFID0gMjBcbmNvbnN0IERFRkFVTFRfTUFSR0lOX1NJWkUgPSAxMFxuXG5mdW5jdGlvbiByZXNldENvbG9yIChpbmRpY2F0b3IpIHtcbiAgY29uc3QgbGVuID0gaW5kaWNhdG9yLml0ZW1zLmxlbmd0aFxuICBpZiAodHlwZW9mIGluZGljYXRvci5pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgbGVuID4gaW5kaWNhdG9yLmluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGluZGljYXRvci5pdGVtc1tpXVxuICAgICAgaWYgKGluZGljYXRvci5pbmRleCA9PT0gaSkge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaW5kaWNhdG9yLml0ZW1TZWxlY3RlZENvbG9yXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaXRlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBpbmRpY2F0b3IuaXRlbUNvbG9yXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrIChpbmRpY2F0b3IsIGlkeCwgZSkge1xuICBpbmRpY2F0b3Iuc2xpZGVyLnNsaWRlVG8oaWR4KVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtaW5kaWNhdG9ycycpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWVsZW1lbnQnKVxuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgdGhpcy5ub2RlID0gbm9kZVxuICAgIHRoaXMuc3R5bGUuaXRlbVNpemUuY2FsbCh0aGlzLCAwKVxuICAgIHRoaXMudXBkYXRlU3R5bGUoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGl0ZW1TaXplOiAwXG4gICAgfSlcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIGNyZWF0ZUNoaWxkcmVuICgpIHtcbiAgICBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgaW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ3dlZXgtaW5kaWNhdG9yJylcbiAgICAgIGluZGljYXRvci5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCdcbiAgICAgIGluZGljYXRvci5zdHlsZS5tYXJnaW4gPSAnMCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChERUZBVUxUX01BUkdJTl9TSVpFICogdGhpcy5kYXRhLnNjYWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAncHgnXG4gICAgICBpbmRpY2F0b3Iuc3R5bGUud2lkdGggPSB0aGlzLml0ZW1TaXplICsgJ3B4J1xuICAgICAgaW5kaWNhdG9yLnN0eWxlLmhlaWdodCA9IHRoaXMuaXRlbVNpemUgKyAncHgnXG4gICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdpbmRleCcsIGkpXG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gaSkge1xuICAgICAgICBpbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJylcbiAgICAgICAgaW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbVNlbGVjdGVkQ29sb3JcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpbmRpY2F0b3Iuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5pdGVtQ29sb3JcbiAgICAgIH1cbiAgICAgIGluZGljYXRvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLmJpbmQobnVsbCwgdGhpcywgaSkpXG4gICAgICB0aGlzLml0ZW1zW2ldID0gaW5kaWNhdG9yXG4gICAgICByb290LmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICB9XG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHJvb3QpXG4gIH0sXG5cbiAgc2V0SW5kZXggKGlkeCkge1xuICAgIGlmIChpZHggPj0gdGhpcy5hbW91bnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBwcmV2ID0gdGhpcy5pdGVtc1t0aGlzLmluZGV4XVxuICAgIGNvbnN0IGN1ciA9IHRoaXMuaXRlbXNbaWR4XVxuICAgIHByZXYuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICBwcmV2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbUNvbG9yXG4gICAgY3VyLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgY3VyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbVNlbGVjdGVkQ29sb3JcbiAgICB0aGlzLmluZGV4ID0gaWR4XG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIGl0ZW1Db2xvciAodmFsKSB7XG4gICAgdGhpcy5pdGVtQ29sb3IgPSB2YWwgfHwgREVGQVVMVF9JVEVNX0NPTE9SXG4gICAgcmVzZXRDb2xvcih0aGlzKVxuICB9LFxuXG4gIGl0ZW1TZWxlY3RlZENvbG9yICh2YWwpIHtcbiAgICB0aGlzLml0ZW1TZWxlY3RlZENvbG9yID0gdmFsIHx8IERFRkFVTFRfSVRFTV9TRUxFQ1RFRF9DT0xPUlxuICAgIHJlc2V0Q29sb3IodGhpcylcbiAgfSxcblxuICBpdGVtU2l6ZSAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKSAqIHRoaXMuZGF0YS5zY2FsZVxuICAgICAgICAgIHx8IERFRkFVTFRfSVRFTV9TSVpFICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5pdGVtU2l6ZSA9IHZhbFxuICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5zdHlsZS53aWR0aCA9IHZhbCArICdweCdcbiAgICAgIHRoaXMuaXRlbXNbaV0uc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xuICAgIH1cbiAgfSxcblxuICB3aWR0aCAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKSAqIHRoaXMuZGF0YS5zY2FsZSB8fCBwYXJzZUludCh0aGlzLnNsaWRlcldpZHRoKVxuICAgIHRoaXMudmlydHVhbFdyYXBwZXJXaWR0aCA9IHZhbFxuICB9LFxuXG4gIGhlaWdodCAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKSAqIHRoaXMuZGF0YS5zY2FsZSB8fCBwYXJzZUludCh0aGlzLnNsaWRlckhlaWdodClcbiAgICB0aGlzLnZpcnR1YWxXcmFwcGVySGVpZ2h0ID0gdmFsXG4gIH0sXG5cbiAgdG9wICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVySGVpZ2h0IC8gMiAtIHRoaXMuaXRlbVNpemUgLyAyXG4gICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLmJvdHRvbSA9ICcnXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IHZhbCArICdweCdcbiAgfSxcblxuICBib3R0b20gKHZhbCkge1xuICAgIHZhbCA9IHRoaXMudmlydHVhbFdyYXBwZXJIZWlnaHQgLyAyIC0gdGhpcy5pdGVtU2l6ZSAvIDJcbiAgICAgICAgKyB2YWwgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICB0aGlzLm5vZGUuc3R5bGUudG9wID0gJydcbiAgICB0aGlzLm5vZGUuc3R5bGUuYm90dG9tID0gdmFsICsgJ3B4J1xuICB9LFxuXG4gIGxlZnQgKHZhbCkge1xuICAgIHZhbCA9IHRoaXMudmlydHVhbFdyYXBwZXJXaWR0aCAvIDJcbiAgICAgICAgICAtICh0aGlzLml0ZW1TaXplICsgMiAqIERFRkFVTFRfTUFSR0lOX1NJWkUgKiB0aGlzLmRhdGEuc2NhbGUpXG4gICAgICAgICAgICAgICogdGhpcy5hbW91bnQgLyAyXG4gICAgICAgICAgKyB2YWwgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICB0aGlzLm5vZGUuc3R5bGUucmlnaHQgPSAnJ1xuICAgIHRoaXMubm9kZS5zdHlsZS5sZWZ0ID0gdmFsICsgJ3B4J1xuICB9LFxuXG4gIHJpZ2h0ICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVyV2lkdGggLyAyXG4gICAgICAgICAgLSAodGhpcy5pdGVtU2l6ZSArIDIgKiBERUZBVUxUX01BUkdJTl9TSVpFICogdGhpcy5kYXRhLnNjYWxlKVxuICAgICAgICAgICAgICAqIHRoaXMuYW1vdW50IC8gMlxuICAgICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLmxlZnQgPSAnJ1xuICAgIHRoaXMubm9kZS5zdHlsZS5yaWdodCA9IHZhbCArICdweCdcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgLy8gU3R5bGUgc3VwcG9ydGVkOlxuICAvLyAgIHBvc2l0aW9uOiAoZGVmYXVsdCAtIGFic29sdXRlKVxuICAvLyAgIGl0ZW1Db2xvcjogY29sb3Igb2YgaW5kaWNhdG9yIGRvdHNcbiAgLy8gICBpdGVtU2VsZWN0ZWRDb2xvcjogY29sb3Igb2YgdGhlIHNlbGVjdGVkIGluZGljYXRvciBkb3RcbiAgLy8gICBpdGVtU2l6ZTogc2l6ZSBvZiBpbmRpY2F0b3JzXG4gIC8vICAgb3RoZXIgbGF5b3V0IHN0eWxlc1xuICBmdW5jdGlvbiBJbmRpY2F0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmRpcmVjdGlvbiA9ICdyb3cnIC8vICdjb2x1bW4nIGlzIG5vdCB0ZW1wb3JhcmlseSBzdXBwb3J0ZWQuXG4gICAgdGhpcy5hbW91bnQgPSBkYXRhLmV4dHJhLmFtb3VudFxuICAgIHRoaXMuaW5kZXggPSBkYXRhLmV4dHJhLmluZGV4XG4gICAgdGhpcy5zbGlkZXJXaWR0aCA9IGRhdGEuZXh0cmEud2lkdGhcbiAgICB0aGlzLnNsaWRlckhlaWdodCA9IGRhdGEuZXh0cmEuaGVpZ2h0XG4gICAgY29uc3Qgc3R5bGVzID0gZGF0YS5zdHlsZSB8fCB7fVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLnN0eWxlLndpZHRoLmNhbGwodGhpcywgc3R5bGVzLndpZHRoKVxuICAgIHRoaXMuc3R5bGUuaGVpZ2h0LmNhbGwodGhpcywgc3R5bGVzLmhlaWdodClcbiAgICB0aGlzLml0ZW1Db2xvciA9IHN0eWxlcy5pdGVtQ29sb3IgfHwgREVGQVVMVF9JVEVNX0NPTE9SXG4gICAgdGhpcy5pdGVtU2VsZWN0ZWRDb2xvciA9IHN0eWxlcy5pdGVtU2VsZWN0ZWRDb2xvclxuICAgICAgfHwgREVGQVVMVF9JVEVNX1NFTEVDVEVEX0NPTE9SXG4gICAgdGhpcy5pdGVtcyA9IFtdXG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBJbmRpY2F0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoSW5kaWNhdG9yLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChJbmRpY2F0b3IucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdpbmRpY2F0b3InLCBJbmRpY2F0b3IpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRpY2F0b3IuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2luZGljYXRvci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRpY2F0b3IuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbmRpY2F0b3IvaW5kaWNhdG9yLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud2VleC1pbmRpY2F0b3JzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi53ZWV4LWluZGljYXRvcnMgLndlZXgtaW5kaWNhdG9yIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbmRpY2F0b3IvaW5kaWNhdG9yLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIFRPRE86IHJlZmFjdG9yIHRoaXMgc2NzcyBjb2RlIHNpbmNlIHRoaXMgaXMgc3Ryb25nbHlcbi8vIGRlcGVuZGVudCBvbiBsaWIuZmxleGlibGUgb3RoZXIgdGhhbiB0aGUgdmFsdWUgb2Zcbi8vIHNjYWxlLlxucmVxdWlyZSgnLi90YWJoZWFkZXIuY3NzJylcblxuZnVuY3Rpb24gaW5pdEZvbGRCdG4gKHRhYmhlYWRlcikge1xuICBjb25zdCBub2RlID0gdGFiaGVhZGVyLm5vZGVcbiAgY29uc3QgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGJ0bi5jbGFzc05hbWUgPSAnZm9sZC10b2dnbGUgaWNvbmZvbnQnXG4gIGJ0bi5pbm5lckhUTUwgPSAnJiN4ZTY2MTsnXG4gIG5vZGUuYXBwZW5kQ2hpbGQoYnRuKVxuXG4gIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFiaGVhZGVyLnVuZm9sZGluZykge1xuICAgICAgZm9sZGluZyh0YWJoZWFkZXIpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdW5mb2xkaW5nKHRhYmhlYWRlcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGluaXRNYXNrICh0YWJoZWFkZXIpIHtcbiAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG1hc2suY2xhc3NOYW1lID0gJ3RhYmhlYWRlci1tYXNrJ1xuICB0YWJoZWFkZXIubWFzayA9IG1hc2tcbiAgLy8gc3RvcCBkZWZhdWx0IGJlaGF2aW9yOiBwYWdlIG1vdmluZy5cbiAgbWFzay5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgfSlcbiAgLy8gY2xpY2sgdG8gdW5mb2xkLlxuICBtYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGZvbGRpbmcodGFiaGVhZGVyKVxuICB9KVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWFzaylcbn1cblxuZnVuY3Rpb24gdW5mb2xkaW5nICh0YWJoZWFkZXIpIHtcbiAgLy8gbWFyayB0aGUgaW5pdGlhbCBwb3NpaXRvbiBvZiB0YWJoZWFkZXJcbiAgaWYgKCF0YWJoZWFkZXIuZmxhZykge1xuICAgIGNvbnN0IGZsYWcgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd0YWJoZWFkZXInKVxuICAgIHRhYmhlYWRlci5mbGFnID0gZmxhZ1xuICAgIHRhYmhlYWRlci5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZsYWcsIHRhYmhlYWRlci5ub2RlKVxuICB9XG4gIGlmICghdGFiaGVhZGVyLm1hc2spIHtcbiAgICBpbml0TWFzayh0YWJoZWFkZXIpXG4gIH1cblxuICAvLyByZWNvcmQgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgdGFiaGVhZGVyLl9zY3JvbGxWYWwgPSB0YWJoZWFkZXIuX2JvZHkuc2Nyb2xsTGVmdFxuICAvLyByZWNvcmQgdGhlIHBvc2l0aW9uIGluIGRvY3VtZW50LlxuICB0YWJoZWFkZXIuX3RvcFZhbCA9IHRhYmhlYWRlci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICB0YWJoZWFkZXIuX3N0eWxlVG9wID0gdGFiaGVhZGVyLm5vZGUuc3R5bGUudG9wXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0YWJoZWFkZXIubm9kZSlcbiAgdGFiaGVhZGVyLm5vZGUuY2xhc3NMaXN0LmFkZCgndW5mb2xkLWhlYWRlcicpXG4gIHRhYmhlYWRlci5ub2RlLnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAvLyByZWNhbGMgdGhlIHBvc2l0aW9uIHdoZW4gaXQgaXMgdW5mb2xkZWQuXG4gIGNvbnN0IHRoSGVpZ2h0ID0gdGFiaGVhZGVyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIGlmICh0aEhlaWdodCArIHRhYmhlYWRlci5fdG9wVmFsID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgdGFiaGVhZGVyLl90b3BWYWwgPSB0YWJoZWFkZXIuX3RvcFZhbFxuICAgICAgICArICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aEhlaWdodCAtIHRhYmhlYWRlci5fdG9wVmFsKVxuICB9XG5cbiAgdGFiaGVhZGVyLm5vZGUuc3R5bGUudG9wID0gdGFiaGVhZGVyLl90b3BWYWwgKyAncHgnXG4gIC8vIHByb2Nlc3MgbWFzayBzdHlsZVxuICB0YWJoZWFkZXIubWFzay5jbGFzc0xpc3QuYWRkKCd1bmZvbGQtaGVhZGVyJylcbiAgdGFiaGVhZGVyLm1hc2suc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICsgJ3B4J1xuICB0YWJoZWFkZXIudW5mb2xkaW5nID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmb2xkaW5nICh0YWJoZWFkZXIpIHtcbiAgaWYgKHRhYmhlYWRlci51bmZvbGRpbmcgIT09IHRydWUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRhYmhlYWRlci5tYXNrLmNsYXNzTGlzdC5yZW1vdmUoJ3VuZm9sZC1oZWFkZXInKVxuICB0YWJoZWFkZXIubm9kZS5jbGFzc0xpc3QucmVtb3ZlKCd1bmZvbGQtaGVhZGVyJylcblxuICB0YWJoZWFkZXIubm9kZS5zdHlsZS5oZWlnaHQgPSAnJ1xuICB0YWJoZWFkZXIubm9kZS5zdHlsZS50b3AgPSB0YWJoZWFkZXIuX3N0eWxlVG9wXG5cbiAgLy8gcmVjb3ZlciB0aGUgcG9zaXRpb24gb2YgdGFiaGVhZGVyLlxuICB0YWJoZWFkZXIuZmxhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YWJoZWFkZXIubm9kZSwgdGFiaGVhZGVyLmZsYWcpXG4gIC8vIHJlY292ZXIgdGhlIHBvc2l0aW9uIG9mIHNjb2xsZXIuXG4gIHRhYmhlYWRlci5fYm9keS5zY3JvbGxMZWZ0ID0gdGFiaGVhZGVyLl9zY3JvbGxWYWxcblxuICBzY3JvbGxUb1ZpZXcodGFiaGVhZGVyKVxuICB0YWJoZWFkZXIudW5mb2xkaW5nID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50ICh0YWJoZWFkZXIpIHtcbiAgaW5pdENsaWNrRXZlbnQodGFiaGVhZGVyKVxuICBpbml0U2VsZWN0RXZlbnQodGFiaGVhZGVyKVxufVxuXG4vLyBpbml0IGV2ZW50cy5cbmZ1bmN0aW9uIGluaXRDbGlja0V2ZW50ICh0YWJoZWFkZXIpIHtcbiAgY29uc3QgYm94ID0gdGFiaGVhZGVyLmJveFxuXG4gIGJveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZ0LnRhcmdldFxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdVTCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ0xJJykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGVcbiAgICB9XG5cbiAgICBjb25zdCBmbG9vciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmxvb3InKVxuICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgIGlmICh0YWJoZWFkZXIuZGF0YS5hdHRyLnNlbGVjdGVkSW5kZXggPT0gZmxvb3IpIHtcbiAgICAgIC8vIER1cGxpY2F0ZWQgY2xpY2tpbmcsIG5vdCB0byB0cmlnZ2VyIHNlbGVjdCBldmVudC5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXG4gICAgZmlyZUV2ZW50KHRhcmdldCwgJ3NlbGVjdCcsIHsgaW5kZXg6IGZsb29yIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGluaXRTZWxlY3RFdmVudCAodGFiaGVhZGVyKSB7XG4gIGNvbnN0IG5vZGUgPSB0YWJoZWFkZXIubm9kZVxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdCcsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBsZXQgaW5kZXhcbiAgICBpZiAoZXZ0LmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gZXZ0LmluZGV4XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2dC5kYXRhICYmIGV2dC5kYXRhLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gZXZ0LmRhdGEuaW5kZXhcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGFiaGVhZGVyLmF0dHIuc2VsZWN0ZWRJbmRleC5jYWxsKHRhYmhlYWRlciwgaW5kZXgpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvVmlldyAodGFiaGVhZGVyLCBub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIGNvbnN0IGF0dHIgPSB0YWJoZWFkZXIuZGF0YS5hdHRyXG4gICAgbm9kZSA9IHRhYmhlYWRlci5ub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZsb29yPVwiJyArIGF0dHIuc2VsZWN0ZWRJbmRleCArICdcIl0nKVxuICB9XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY29uc3QgZGVmYXVsdFZhbCA9IHRhYmhlYWRlci5fYm9keS5zY3JvbGxMZWZ0XG4gIC8vIGNvbnN0IGxlZnRWYWwgPSBkZWZhdWx0VmFsIC0gbm9kZS5vZmZzZXRMZWZ0ICsgMzAwXG5cbiAgY29uc3Qgc2Nyb2xsVmFsID0gZ2V0U2Nyb2xsVmFsKHRhYmhlYWRlci5fYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbm9kZSlcbiAgZG9TY3JvbGwodGFiaGVhZGVyLl9ib2R5LCBzY3JvbGxWYWwpXG59XG5cbi8vIHNjcm9sbCB0aGUgdGFiaGVhZGVyLlxuLy8gcG9zaXRpdmUgdmFsIG1lYW5zIHRvIHNjcm9sbCByaWdodC5cbi8vIG5lZ2F0aXZlIHZhbCBtZWFucyB0byBzY3JvbGwgbGVmdC5cbmZ1bmN0aW9uIGRvU2Nyb2xsIChub2RlLCB2YWwsIGZpbmlzaCkge1xuICBpZiAoIXZhbCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChmaW5pc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbmlzaCA9IE1hdGguYWJzKHZhbClcbiAgfVxuXG4gIGlmIChmaW5pc2ggPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZhbCA+IDApIHtcbiAgICAgIG5vZGUuc2Nyb2xsTGVmdCArPSAyXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5zY3JvbGxMZWZ0IC09IDJcbiAgICB9XG4gICAgZmluaXNoIC09IDJcblxuICAgIGRvU2Nyb2xsKG5vZGUsIHZhbCwgZmluaXNoKVxuICB9KVxufVxuXG4vLyBnZXQgc2Nyb2xsIGRpc3RhbmNlLlxuZnVuY3Rpb24gZ2V0U2Nyb2xsVmFsIChyZWN0LCBub2RlKSB7XG4gIGNvbnN0IGxlZnQgPSBub2RlLnByZXZpb3VzU2libGluZ1xuICBjb25zdCByaWdodCA9IG5vZGUubmV4dFNpYmxpbmdcbiAgbGV0IHNjcm9sbFZhbFxuXG4gIC8vIHByb2Nlc3MgbGVmdC1zaWRlIGVsZW1lbnQgZmlyc3QuXG4gIGlmIChsZWZ0KSB7XG4gICAgY29uc3QgbGVmdFJlY3QgPSBsZWZ0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgLy8gb25seSBuZWVkIHRvIGNvbXBhcmUgdGhlIHZhbHVlIG9mIGxlZnQuXG4gICAgaWYgKGxlZnRSZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcbiAgICAgIHNjcm9sbFZhbCA9IGxlZnRSZWN0LmxlZnRcbiAgICAgIHJldHVybiBzY3JvbGxWYWxcbiAgICB9XG4gIH1cblxuICBpZiAocmlnaHQpIHtcbiAgICBjb25zdCByaWdodFJlY3QgPSByaWdodC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIC8vIGNvbXBhcmUgdGhlIHZhbHVlIG9mIHJpZ2h0LlxuICAgIGlmIChyaWdodFJlY3QucmlnaHQgPiByZWN0LnJpZ2h0KSB7XG4gICAgICBzY3JvbGxWYWwgPSByaWdodFJlY3QucmlnaHQgLSByZWN0LnJpZ2h0XG4gICAgICByZXR1cm4gc2Nyb2xsVmFsXG4gICAgfVxuICB9XG5cbiAgLy8gcHJvY2VzcyBjdXJyZW50IG5vZGUsIGZyb20gbGVmdCB0byByaWdodC5cbiAgY29uc3Qgbm9kZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGlmIChub2RlUmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgc2Nyb2xsVmFsID0gbm9kZVJlY3QubGVmdFxuICB9XG4gIGVsc2UgaWYgKG5vZGVSZWN0LnJpZ2h0ID4gcmVjdC5yaWdodCkge1xuICAgIHNjcm9sbFZhbCA9IG5vZGVSZWN0LnJpZ2h0IC0gcmVjdC5yaWdodFxuICB9XG5cbiAgcmV0dXJuIHNjcm9sbFZhbFxufVxuXG4vLyB0cmlnZ2VyIGFuZCBicm9hZGNhc3QgZXZlbnRzLlxuZnVuY3Rpb24gZmlyZUV2ZW50IChlbGVtZW50LCB0eXBlLCBkYXRhKSB7XG4gIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gIGV2dC5kYXRhID0gZGF0YVxuICBmb3IgKGNvbnN0IGsgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBldnRba10gPSBkYXRhW2tdXG4gICAgfVxuICB9XG4gIC8vIG5lZWQgYnViYmxlLlxuICBldnQuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpXG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0SWNvbiAoY29kZSkge1xuICBjb25zdCBodG1sID0gJzxpIGNsYXNzPVwiaGwtaWNvbiBpY29uZm9udFwiPicgKyAnJiN4ZTY1MCcgKyAnPC9pPidcbiAgcmV0dXJuIGh0bWxcbn1cblxuZnVuY3Rpb24gaXNWYWxpZENvbG9yIChjb2xvcikge1xuICBpZiAoIWNvbG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoY29sb3IuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChjb2xvci5sZW5ndGggIT09IDcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIC8vIG91dHNpZGUgY29udGFpbmVyLlxuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuY2xhc3NOYW1lID0gJ3RhYi1oZWFkZXInXG4gICAgLy8gdGlwIG9uIHRoZSB0b3AuXG4gICAgY29uc3QgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBiYXIuY2xhc3NOYW1lID0gJ2hlYWRlci1iYXInXG4gICAgYmFyLnRleHRDb250ZW50ID0gJ0NIQU5HRSBGTE9PUidcbiAgICAvLyBtaWRkbGUgbGF5ZXIuXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgYm9keS5jbGFzc05hbWUgPSAnaGVhZGVyLWJvZHknXG4gICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICAgIGJveC5jbGFzc05hbWUgPSAndGFiaGVhZGVyJ1xuXG4gICAgYm9keS5hcHBlbmRDaGlsZChib3gpXG4gICAgbm9kZS5hcHBlbmRDaGlsZChiYXIpXG4gICAgbm9kZS5hcHBlbmRDaGlsZChib2R5KVxuICAgIHRoaXMuX2JhciA9IGJhclxuICAgIHRoaXMuX2JvZHkgPSBib2R5XG4gICAgdGhpcy5ib3ggPSBib3hcbiAgICB0aGlzLm5vZGUgPSBub2RlXG4gICAgLy8gaW5pdCBldmVudHMuXG4gICAgaW5pdEZvbGRCdG4odGhpcylcbiAgICBpbml0RXZlbnQodGhpcylcbiAgICByZXR1cm4gbm9kZVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIGhpZ2hsaWdodEljb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVIaWdobGlnaHRJY29uKClcbiAgfSxcblxuICBkYXRhICgpIHtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5kYXRhLmF0dHJcbiAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBkZWZhdWx0IHNlbGVjdGVkIHZhbHVlLlxuICAgIGlmIChhdHRyLnNlbGVjdGVkSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0ci5zZWxlY3RlZEluZGV4ID0gMFxuICAgIH1cblxuICAgIGNvbnN0IGxpc3QgPSBhdHRyLmRhdGEgfHwgW11cbiAgICBjb25zdCBjdXJJdGVtID0gYXR0ci5zZWxlY3RlZEluZGV4XG5cbiAgICBjb25zdCByZXQgPSBbXVxuICAgIGNvbnN0IGl0ZW1UbXBsID0gJzxsaSBjbGFzcz1cInRoLWl0ZW1cIiBkYXRhLWZsb29yPVwie3tmbG9vcn19XCI+J1xuICAgICAgICArICd7e2hsSWNvbn19e3tmbG9vck5hbWV9fTwvbGk+J1xuXG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgIGxldCBodG1sID0gaXRlbVRtcGwucmVwbGFjZSgne3tmbG9vcn19JywgaWR4KVxuICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICBpZiAoY3VySXRlbSA9PSBpZHgpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgne3tobEljb259fScsIGNyZWF0ZUhpZ2hsaWdodEljb24oKSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKCd7e2hsSWNvbn19JywgJycpXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXG4gICAgICBodG1sID0gaHRtbC5yZXBsYWNlKCd7e2Zsb29yTmFtZX19JywgaXRlbSlcblxuICAgICAgcmV0LnB1c2goaHRtbClcbiAgICB9LCB0aGlzKVxuXG4gICAgdGhpcy5ib3guaW5uZXJIVE1MID0gcmV0LmpvaW4oJycpXG4gIH0sXG5cbiAgc2VsZWN0ZWRJbmRleCAodmFsKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZGF0YS5hdHRyXG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbCA9IDBcbiAgICB9XG5cbiAgICAvLyBpZiAodmFsID09IGF0dHIuc2VsZWN0ZWRJbmRleCkge1xuICAgIC8vICAgcmV0dXJuXG4gICAgLy8gfVxuXG4gICAgYXR0ci5zZWxlY3RlZEluZGV4ID0gdmFsXG5cbiAgICB0aGlzLmF0dHIuZGF0YS5jYWxsKHRoaXMpXG5cbiAgICBmb2xkaW5nKHRoaXMpXG4gICAgdGhpcy5zdHlsZS50ZXh0SGlnaGxpZ2h0Q29sb3IuY2FsbCh0aGlzLCB0aGlzLnRleHRIaWdobGlnaHRDb2xvcilcbiAgfVxufVxuXG5jb25zdCBzdHlsZSA9IHtcbiAgb3BhY2l0eSAodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA8IDAgfHwgdmFsID4gMSkge1xuICAgICAgdmFsID0gMVxuICAgIH1cblxuICAgIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gdmFsXG4gIH0sXG5cbiAgdGV4dENvbG9yICh2YWwpIHtcbiAgICBpZiAoIWlzVmFsaWRDb2xvcih2YWwpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLm5vZGUuc3R5bGUuY29sb3IgPSB2YWxcbiAgfSxcblxuICB0ZXh0SGlnaGxpZ2h0Q29sb3IgKHZhbCkge1xuICAgIGlmICghaXNWYWxpZENvbG9yKHZhbCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnRleHRIaWdobGlnaHRDb2xvciA9IHZhbFxuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmRhdGEuYXR0clxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1mbG9vcj1cIidcbiAgICAgICAgKyBhdHRyLnNlbGVjdGVkSW5kZXggKyAnXCJdJylcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5zdHlsZS5jb2xvciA9IHZhbFxuICAgICAgc2Nyb2xsVG9WaWV3KHRoaXMsIG5vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICBmdW5jdGlvbiBUYWJIZWFkZXIgKGRhdGEpIHtcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFRhYkhlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG4gIGV4dGVuZChUYWJIZWFkZXIucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKFRhYkhlYWRlci5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoVGFiSGVhZGVyLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgndGFiSGVhZGVyJywgVGFiSGVhZGVyKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3RhYmhlYWRlci9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi90YWJoZWFkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL3RhYmhlYWRlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRhYi1oZWFkZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwcmVtO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi50YWItaGVhZGVyIC5oZWFkZXItYmFyIHtcXG4gIGhlaWdodDogMS4xN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE3cmVtO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGNvbG9yOiAjOTk5O1xcbiAgcGFkZGluZy1sZWZ0OiAwLjRyZW07XFxufVxcbi50YWItaGVhZGVyIC5oZWFkZXItYm9keSB7XFxuICBtYXJnaW4tcmlnaHQ6IDEuMDdyZW07XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbn1cXG4udGFiLWhlYWRlciAuaGVhZGVyLWJvZHk6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLnRhYi1oZWFkZXIgLmZvbGQtdG9nZ2xlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMC41OXJlbTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgcmlnaHQ6IDAuMjlyZW07XFxuICB3aWR0aDogMC40OHJlbTtcXG4gIGhlaWdodDogMC40OHJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQ4cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgei1pbmRleDogOTk7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi50YWItaGVhZGVyLnVuZm9sZC1oZWFkZXIge1xcbiAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnRhYmhlYWRlciB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGhlaWdodDogMS4xN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE3cmVtO1xcbn1cXG4udGFiaGVhZGVyIC50aC1pdGVtIHtcXG4gIHBhZGRpbmctbGVmdDogMC43MnJlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLnRhYmhlYWRlciAuaGwtaWNvbiB7XFxuICB3aWR0aDogMC40cmVtO1xcbiAgaGVpZ2h0OiAwLjRyZW07XFxuICBsaW5lLWhlaWdodDogMC40cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGxlZnQ6IDAuMjRyZW07XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi51bmZvbGQtaGVhZGVyIC5oZWFkZXItYmFyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4udW5mb2xkLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDE4MGRlZyk7XFxufVxcbi51bmZvbGQtaGVhZGVyIC5oZWFkZXItYm9keSB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBwYWRkaW5nOiAwLjI0cmVtO1xcbn1cXG4udW5mb2xkLWhlYWRlciAudGFiaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4udW5mb2xkLWhlYWRlciAudGgtaXRlbSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogMzMuMzMzMyU7XFxuICBoZWlnaHQ6IDEuMDFyZW07XFxuICBsaW5lLWhlaWdodDogMS4wMXJlbTtcXG59XFxuLnVuZm9sZC1oZWFkZXIgLmhsLWljb24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4udW5mb2xkLWhlYWRlci50YWJoZWFkZXItbWFzayB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbn1cXG5cXG4udGFiaGVhZGVyLW1hc2sge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJpY29uZm9udFxcXCI7XFxuICBzcmM6IHVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFQQUlBQUF3QndSa1pVVFhCRDk4VUFBQUQ4QUFBQUhFOVRMekpYTDF6SUFBQUJHQUFBQUdCamJXRndzNklIYmdBQUFYZ0FBQUZhWTNaMElBeVYvc3dBQUFwUUFBQUFKR1p3WjIwdzk1NlZBQUFLZEFBQUNaWm5ZWE53QUFBQUVBQUFDa2dBQUFBSVoyeDVadXhvUEZJQUFBTFVBQUFFV0dobFlXUUhBNWgzQUFBSExBQUFBRFpvYUdWaEJ6SURjZ0FBQjJRQUFBQWthRzEwZUFzMkFXMEFBQWVJQUFBQUdHeHZZMkVEY0FRZUFBQUhvQUFBQUJCdFlYaHdBU2tLS3dBQUI3QUFBQUFnYm1GdFpRbC8zaGdBQUFmUUFBQUNMbkJ2YzNUbTdmMGJBQUFLQUFBQUFFaHdjbVZ3cGJtK1pnQUFGQXdBQUFDVkFBQUFBUUFBQUFETVBhTFBBQUFBQU5JREtub0FBQUFBMGdNcWV3QUVBL29COUFBRkFBQUNtUUxNQUFBQWp3S1pBc3dBQUFIckFETUJDUUFBQWdBR0F3QUFBQUFBQUFBQUFBRVFBQUFBQUFBQUFBQUFBQUJRWmtWa0FNQUFlT2JlQXl6L0xBQmNBeGdBbEFBQUFBRUFBQUFBQXhnQUFBQUFBQ0FBQVFBQUFBTUFBQUFEQUFBQUhBQUJBQUFBQUFCVUFBTUFBUUFBQUJ3QUJBQTRBQUFBQ2dBSUFBSUFBZ0I0NWxEbVllYmUvLzhBQUFCNDVsRG1ZZWJlLy8vL2l4bTBHYVFaS0FBQkFBQUFBQUFBQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUNJQUFBRXlBcW9BQXdBSEFDbEFKZ0FBQUFNQ0FBTlhBQUlCQVFKTEFBSUNBVThFQVFFQ0FVTUFBQWNHQlFRQUF3QURFUVVQS3pNUklSRW5NeEVqSWdFUTdzek1BcXI5VmlJQ1pnQUFBQVVBTFAvaEE3d0RHQUFXQURBQU9nQlNBRjRCZDB1d0UxQllRRW9DQVFBTkRnMEFEbVlBQXc0QkRnTmVBQUVJQ0FGY0VBRUpDQW9HQ1Y0UkFRd0dCQVlNWGdBTEJBdHBEd0VJQUFZTUNBWllBQW9IQlFJRUN3b0VXUklCRGc0TlVRQU5EUW9PUWh0THNCZFFXRUJMQWdFQURRNE5BQTVtQUFNT0FRNERYZ0FCQ0FnQlhCQUJDUWdLQ0FrS1poRUJEQVlFQmd4ZUFBc0VDMmtQQVFnQUJnd0lCbGdBQ2djRkFnUUxDZ1JaRWdFT0RnMVJBQTBOQ2c1Q0cwdXdHRkJZUUV3Q0FRQU5EZzBBRG1ZQUF3NEJEZ05lQUFFSUNBRmNFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNHMEJPQWdFQURRNE5BQTVtQUFNT0FRNERBV1lBQVFnT0FRaGtFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNXVmxaUUNoVFV6czdNakVYRjFOZVUxNWJXRHRTTzFKTFF6YzFNVG95T2hjd0Z6QlJFVEVZRVNnVlFCTVdLd0VHS3dFaURnSWRBU0UxTkNZMU5DNENLd0VWSVFVVkZCWVVEZ0lqQmlZckFTY2hCeXNCSWljaUxnSTlBUmNpQmhRV016STJOQ1lYQmdjT0F4NEJPd1l5TmljdUFTY21Kd0UxTkQ0Q093RXlGaDBCQVJrYkdsTVNKUndTQTVBQkNoZ25Ib1grU2dLaUFSVWZJdzRPSHc0Z0xmNUpMQjBpRkJrWklCTUlkd3dTRWd3TkVoS01DQVlGQ3dRQ0JBOE9KVU5SVUVBa0Z4WUpCUWtGQlFiK3BBVVBHaFc4SHlrQ0h3RU1HU2NhVENrUUhBUU5JQnNTWVlnMEZ6bzZKUmNKQVFHQWdBRVRHeUFPcHo4UkdoRVJHaEY4R2hZVEpBNFFEUWdZR2cwakVSTVVBWGZrQ3hnVERCMG00d0FBQWdDZy8yd0RZQUxzQUJJQUdnQWhRQjRBQUFBREFnQURXUUFDQVFFQ1RRQUNBZ0ZSQUFFQ0FVVVRGamtRQkJJckFDQUdGUlFlQXhjV093RXlQd0VTTlRRQUlpWTBOaklXRkFLUy90ek9SRlZ2TVJBSkRnRU9DVzNiL3VLRVhsNkVYZ0xzenBJMWxYeUpOaEVLQzMwQkRJeVMvczVlaEY1ZWhBQUFBQUVBZ2dCSkE0UUI2QUFkQUJ0QUdCSVJBZ0VBQVVBRkFRQStBQUFCQUdnQUFRRmZFeDhDRUNzQkpnY0dCd2tCTGdFR0J3WVVGd0V3TXhjVkZqSTNBVDRETGdJRGVoRVdBd1ArdVA2MEJoRVFCZ29LQVdFQkFRb2FDUUZlQXdRQ0FRRUNCQUhoRWcwREF2NjFBVWtIQkFVR0NSc0ovcUlCQVFrSkFXSUNCd1lIQ0FZR0FBRUFmd0NMQTRFQ0p3QWhBQjFBR2hZUEFnRUFBVUFGQVFBK0FBQUJBR2dDQVFFQlh5UXVFd01SS3lVQk1DY2pOU1lIQmdjQkRnRVVGaGNlQWpNeU53a0JGak15TmpjK0FpNEJBM2YrbndFQkVoVUVBdjZpQlFVRkJRTUhDQVFPQ1FGSUFVd0tEUVlNQlFNRkFRRUZ3d0ZlQVFFUkRRSUQvcDhGREF3TUJBTUVBZ2tCUy82MkNRVUZBd29KQ2drQUFBRUFBQUFCQUFBTEl5bm9Ydzg4OVFBTEJBQUFBQUFBMGdNcWV3QUFBQURTQXlwN0FDTC9iQU84QXhnQUFBQUlBQUlBQUFBQUFBQUFBUUFBQXhqL2JBQmNCQUFBQUFBQUE3d0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBVUJkZ0FpQUFBQUFBRlZBQUFENlFBc0JBQUFvQUNDQUg4QUFBQW9BQ2dBS0FGa0FhSUI1QUlzQUFFQUFBQUhBRjhBQlFBQUFBQUFBZ0FtQURRQWJBQUFBSW9KbGdBQUFBQUFBQUFNQUpZQUFRQUFBQUFBQVFBSUFBQUFBUUFBQUFBQUFnQUdBQWdBQVFBQUFBQUFBd0FrQUE0QUFRQUFBQUFBQkFBSUFESUFBUUFBQUFBQUJRQkdBRG9BQVFBQUFBQUFCZ0FJQUlBQUF3QUJCQWtBQVFBUUFJZ0FBd0FCQkFrQUFnQU1BSmdBQXdBQkJBa0FBd0JJQUtRQUF3QUJCQWtBQkFBUUFPd0FBd0FCQkFrQUJRQ01BUHdBQXdBQkJBa0FCZ0FRQVlocFkyOXVabTl1ZEUxbFpHbDFiVVp2Ym5SR2IzSm5aU0F5TGpBZ09pQnBZMjl1Wm05dWRDQTZJREkyTFRndE1qQXhOV2xqYjI1bWIyNTBWbVZ5YzJsdmJpQXhMakFnT3lCMGRHWmhkWFJ2YUdsdWRDQW9kakF1T1RRcElDMXNJRGdnTFhJZ05UQWdMVWNnTWpBd0lDMTRJREUwSUMxM0lDSkhJaUF0WmlBdGMybGpiMjVtYjI1MEFHa0FZd0J2QUc0QVpnQnZBRzRBZEFCTkFHVUFaQUJwQUhVQWJRQkdBRzhBYmdCMEFFWUFid0J5QUdjQVpRQWdBRElBTGdBd0FDQUFPZ0FnQUdrQVl3QnZBRzRBWmdCdkFHNEFkQUFnQURvQUlBQXlBRFlBTFFBNEFDMEFNZ0F3QURFQU5RQnBBR01BYndCdUFHWUFid0J1QUhRQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBQ0FBT3dBZ0FIUUFkQUJtQUdFQWRRQjBBRzhBYUFCcEFHNEFkQUFnQUNnQWRnQXdBQzRBT1FBMEFDa0FJQUF0QUd3QUlBQTRBQ0FBTFFCeUFDQUFOUUF3QUNBQUxRQkhBQ0FBTWdBd0FEQUFJQUF0QUhnQUlBQXhBRFFBSUFBdEFIY0FJQUFpQUVjQUlnQWdBQzBBWmdBZ0FDMEFjd0JwQUdNQWJ3QnVBR1lBYndCdUFIUUFBQUFDQUFBQUFBQUEvNE1BTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0FBQUFCQUFJQVd3RUNBUU1CQkFkMWJtbEZOalV3QjNWdWFVVTJOakVIZFc1cFJUWkVSUUFCQUFILy93QVBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXlBRElER1AvaEF4ai9iQU1ZLytFREdQOXNzQUFzc0NCZ1ppMndBU3dnWkNDd3dGQ3dCQ1phc0FSRlcxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3dDa1ZoWkxBb1VGZ2hzQXBGSUxBd1VGZ2hzREJaR3lDd3dGQllJR1lnaW9waElMQUtVRmhnR3lDd0lGQllJYkFLWUJzZ3NEWlFXQ0d3Tm1BYllGbFpXUnV3QUN0WldTT3dBRkJZWlZsWkxiQUNMQ0JGSUxBRUpXRmtJTEFGUTFCWXNBVWpRckFHSTBJYklTRlpzQUZnTGJBRExDTWhJeUVnWkxFRllrSWdzQVlqUXJJS0FBSXFJU0N3QmtNZ2lpQ0tzQUFyc1RBRkpZcFJXR0JRRzJGU1dWZ2pXU0Vnc0VCVFdMQUFLeHNoc0VCWkk3QUFVRmhsV1Myd0JDeXdDQ05Dc0FjalFyQUFJMEt3QUVPd0IwTlJXTEFJUXl1eUFBRUFRMkJDc0JabEhGa3RzQVVzc0FCRElFVWdzQUpGWTdBQlJXSmdSQzJ3Qml5d0FFTWdSU0N3QUNzanNRUUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJDMndCeXl4QlFWRnNBRmhSQzJ3Q0N5d0FXQWdJTEFLUTBxd0FGQllJTEFLSTBKWnNBdERTckFBVWxnZ3NBc2pRbGt0c0Frc0lMZ0VBR0lndUFRQVk0b2pZYkFNUTJBZ2ltQWdzQXdqUWlNdHNBb3NTMVJZc1FjQlJGa2tzQTFsSTNndHNBc3NTMUZZUzFOWXNRY0JSRmtiSVZra3NCTmxJM2d0c0F3c3NRQU5RMVZZc1EwTlE3QUJZVUt3Q1N0WnNBQkRzQUlsUXJJQUFRQkRZRUt4Q2dJbFFyRUxBaVZDc0FFV0l5Q3dBeVZRV0xBQVE3QUVKVUtLaWlDS0kyR3dDQ29oSTdBQllTQ0tJMkd3Q0NvaEc3QUFRN0FDSlVLd0FpVmhzQWdxSVZtd0NrTkhzQXREUjJDd2dHSWdzQUpGWTdBQlJXSmdzUUFBRXlORXNBRkRzQUErc2dFQkFVTmdRaTJ3RFN5eEFBVkZWRmdBc0EwalFpQmdzQUZodFE0T0FRQU1BRUpDaW1DeERBUXJzR3NyR3lKWkxiQU9MTEVBRFNzdHNBOHNzUUVOS3kyd0VDeXhBZzByTGJBUkxMRUREU3N0c0JJc3NRUU5LeTJ3RXl5eEJRMHJMYkFVTExFR0RTc3RzQlVzc1FjTkt5MndGaXl4Q0EwckxiQVhMTEVKRFNzdHNCZ3NzQWNyc1FBRlJWUllBTEFOSTBJZ1lMQUJZYlVPRGdFQURBQkNRb3Bnc1F3RUs3QnJLeHNpV1Myd0dTeXhBQmdyTGJBYUxMRUJHQ3N0c0Jzc3NRSVlLeTJ3SEN5eEF4Z3JMYkFkTExFRUdDc3RzQjRzc1FVWUt5MndIeXl4QmhnckxiQWdMTEVIR0NzdHNDRXNzUWdZS3kyd0lpeXhDUmdyTGJBakxDQmdzQTVnSUVNanNBRmdRN0FDSmJBQ0pWRllJeUE4c0FGZ0k3QVNaUndiSVNGWkxiQWtMTEFqSzdBaktpMndKU3dnSUVjZ0lMQUNSV093QVVWaVlDTmhPQ01naWxWWUlFY2dJTEFDUldPd0FVVmlZQ05oT0JzaFdTMndKaXl4QUFWRlZGZ0FzQUVXc0NVcXNBRVZNQnNpV1Myd0p5eXdCeXV4QUFWRlZGZ0FzQUVXc0NVcXNBRVZNQnNpV1Myd0tDd2dOYkFCWUMyd0tTd0FzQU5GWTdBQlJXS3dBQ3V3QWtWanNBRkZZckFBSzdBQUZyUUFBQUFBQUVRK0l6aXhLQUVWS2kyd0tpd2dQQ0JISUxBQ1JXT3dBVVZpWUxBQVEyRTRMYkFyTEM0WFBDMndMQ3dnUENCSElMQUNSV093QVVWaVlMQUFRMkd3QVVOak9DMndMU3l4QWdBV0pTQXVJRWV3QUNOQ3NBSWxTWXFLUnlOSEkyRWdXR0liSVZtd0FTTkNzaXdCQVJVVUtpMndMaXl3QUJhd0JDV3dCQ1ZISTBjalliQUdSU3RsaWk0aklDQThpamd0c0M4c3NBQVdzQVFsc0FRbElDNUhJMGNqWVNDd0JDTkNzQVpGS3lDd1lGQllJTEJBVVZpekFpQURJQnV6QWlZREdsbENRaU1nc0FsRElJb2pSeU5ISTJFalJtQ3dCRU93Z0dKZ0lMQUFLeUNLaW1FZ3NBSkRZR1Fqc0FORFlXUlFXTEFDUTJFYnNBTkRZRm13QXlXd2dHSmhJeUFnc0FRbUkwWmhPQnNqc0FsRFJyQUNKYkFKUTBjalJ5TmhZQ0N3QkVPd2dHSmdJeUN3QUNzanNBUkRZTEFBSzdBRkpXR3dCU1d3Z0dLd0JDWmhJTEFFSldCa0k3QURKV0JrVUZnaEd5TWhXU01nSUxBRUppTkdZVGhaTGJBd0xMQUFGaUFnSUxBRkppQXVSeU5ISTJFalBEZ3RzREVzc0FBV0lMQUpJMElnSUNCR0kwZXdBQ3NqWVRndHNESXNzQUFXc0FNbHNBSWxSeU5ISTJHd0FGUllMaUE4SXlFYnNBSWxzQUlsUnlOSEkyRWdzQVVsc0FRbFJ5TkhJMkd3QmlXd0JTVkpzQUlsWWJBQlJXTWpJRmhpR3lGWlk3QUJSV0pnSXk0aklDQThpamdqSVZrdHNETXNzQUFXSUxBSlF5QXVSeU5ISTJFZ1lMQWdZR2F3Z0dJaklDQThpamd0c0RRc0l5QXVSckFDSlVaU1dDQThXUzZ4SkFFVUt5MndOU3dqSUM1R3NBSWxSbEJZSUR4WkxyRWtBUlFyTGJBMkxDTWdMa2F3QWlWR1VsZ2dQRmtqSUM1R3NBSWxSbEJZSUR4WkxyRWtBUlFyTGJBM0xMQXVLeU1nTGthd0FpVkdVbGdnUEZrdXNTUUJGQ3N0c0Rnc3NDOHJpaUFnUExBRUkwS0tPQ01nTGthd0FpVkdVbGdnUEZrdXNTUUJGQ3V3QkVNdXNDUXJMYkE1TExBQUZyQUVKYkFFSmlBdVJ5TkhJMkd3QmtVckl5QThJQzRqT0xFa0FSUXJMYkE2TExFSkJDVkNzQUFXc0FRbHNBUWxJQzVISTBjallTQ3dCQ05Dc0FaRkt5Q3dZRkJZSUxCQVVWaXpBaUFESUJ1ekFpWURHbGxDUWlNZ1I3QUVRN0NBWW1BZ3NBQXJJSXFLWVNDd0FrTmdaQ093QTBOaFpGQllzQUpEWVJ1d0EwTmdXYkFESmJDQVltR3dBaVZHWVRnaklEd2pPQnNoSUNCR0kwZXdBQ3NqWVRnaFdiRWtBUlFyTGJBN0xMQXVLeTZ4SkFFVUt5MndQQ3l3THlzaEl5QWdQTEFFSTBJak9MRWtBUlFyc0FSRExyQWtLeTJ3UFN5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBcUtpMndQaXl3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckFxS2kyd1B5eXhBQUVVRTdBcktpMndRQ3l3TFNvdHNFRXNzQUFXUlNNZ0xpQkdpaU5oT0xFa0FSUXJMYkJDTExBSkkwS3dRU3N0c0VNc3NnQUFPaXN0c0VRc3NnQUJPaXN0c0VVc3NnRUFPaXN0c0VZc3NnRUJPaXN0c0Vjc3NnQUFPeXN0c0Vnc3NnQUJPeXN0c0Vrc3NnRUFPeXN0c0Vvc3NnRUJPeXN0c0Vzc3NnQUFOeXN0c0V3c3NnQUJOeXN0c0Uwc3NnRUFOeXN0c0U0c3NnRUJOeXN0c0U4c3NnQUFPU3N0c0ZBc3NnQUJPU3N0c0ZFc3NnRUFPU3N0c0ZJc3NnRUJPU3N0c0ZNc3NnQUFQQ3N0c0ZRc3NnQUJQQ3N0c0ZVc3NnRUFQQ3N0c0ZZc3NnRUJQQ3N0c0Zjc3NnQUFPQ3N0c0Znc3NnQUJPQ3N0c0Zrc3NnRUFPQ3N0c0Zvc3NnRUJPQ3N0c0Zzc3NEQXJMckVrQVJRckxiQmNMTEF3SzdBMEt5MndYU3l3TUN1d05Tc3RzRjRzc0FBV3NEQXJzRFlyTGJCZkxMQXhLeTZ4SkFFVUt5MndZQ3l3TVN1d05Dc3RzR0Vzc0RFcnNEVXJMYkJpTExBeEs3QTJLeTJ3WXl5d01pc3VzU1FCRkNzdHNHUXNzRElyc0RRckxiQmxMTEF5SzdBMUt5MndaaXl3TWl1d05pc3RzR2Nzc0RNckxyRWtBUlFyTGJCb0xMQXpLN0EwS3kyd2FTeXdNeXV3TlNzdHNHb3NzRE1yc0RZckxiQnJMQ3V3Q0dXd0F5UlFlTEFCRlRBdEFBQkx1QURJVWxpeEFRR09XYmtJQUFnQVl5Q3dBU05FSUxBREkzQ3dEa1VnSUV1NEFBNVJTN0FHVTFwWXNEUWJzQ2haWUdZZ2lsVllzQUlsWWJBQlJXTWpZckFDSTBTekNna0ZCQ3V6Q2dzRkJDdXpEZzhGQkN0WnNnUW9DVVZTUkxNS0RRWUVLN0VHQVVTeEpBR0lVVml3UUloWXNRWURSTEVtQVloUldMZ0VBSWhZc1FZQlJGbFpXVm00QWYrRnNBU05zUVVBUkFBQUFBPT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIik7XFxufVxcbi5pY29uZm9udCB7XFxuICBmb250LWZhbWlseTogaWNvbmZvbnQgIWltcG9ydGFudDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aDogMC4ycHg7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjJcXFwiXSAudGFiLWhlYWRlciB7XFxuICBmb250LXNpemU6IDI4cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC50YWItaGVhZGVyIHtcXG4gIGZvbnQtc2l6ZTogNDJweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnRhYmhlYWRlciAuaGwtaWNvbiB7XFxuICBmb250LXNpemU6IDI4cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC50YWJoZWFkZXIgLmhsLWljb24ge1xcbiAgZm9udC1zaXplOiA0MnB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjJcXFwiXSAudGFiLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgZm9udC1zaXplOiAyOHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAudGFiLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgZm9udC1zaXplOiA0MnB4O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy90YWJoZWFkZXIvdGFiaGVhZGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBhcHBlbmRTdHlsZVxuXG5jb25zdCBhdmFpbGFibGVUeXBlcyA9IFsndGV4dCcsICdwYXNzd29yZCcsICd0ZWwnLCAnZW1haWwnLCAndXJsJ11cbmNvbnN0IERFRkFVTFRfVFlQRSA9ICd0ZXh0J1xuXG5mdW5jdGlvbiBzZXRQbGFjZWhvbGRlckNvbG9yIChpbnB1dCwgcGxhY2Vob2xkZXJDb2xvcikge1xuICBpZiAoIXBsYWNlaG9sZGVyQ29sb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB2ZW5kb3JzID0gW1xuICAgICc6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXInLFxuICAgICc6LW1vei1wbGFjZWhvbGRlcicsXG4gICAgJzo6LW1vei1wbGFjZWhvbGRlcicsXG4gICAgJzotbXMtaW5wdXQtcGxhY2Vob2xkZXInLFxuICAgICc6cGxhY2Vob2xkZXItc2hvd24nXG4gIF1cbiAgbGV0IGNzcyA9ICcnXG4gIGNvbnN0IGNzc1J1bGUgPSAnY29sb3I6ICcgKyBwbGFjZWhvbGRlckNvbG9yICsgJzsnXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdmVuZG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjc3MgKz0gJy4nICsgaW5wdXQuY2xhc3NOYW1lICsgdmVuZG9yc1tpXSArICd7J1xuICAgICAgICAgICArIGNzc1J1bGUgKyAnfSdcbiAgfVxuICBhcHBlbmRTdHlsZShjc3MsIGlucHV0LnN0eWxlSWQsIHRydWUpXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgY29uc3QgdXVpZCA9IE1hdGguZmxvb3IoMTAwMDAwMDAwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKSArIERhdGUubm93KClcbiAgICB0aGlzLmNsYXNzTmFtZSA9ICd3ZWV4LWlwdC0nICsgdXVpZFxuICAgIHRoaXMuc3R5bGVJZCA9ICd3ZWV4LXN0eWxlLScgKyB1dWlkXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JylcbiAgICB0aGlzLnBsYWNlaG9sZGVyICYmIChub2RlLnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcilcbiAgICByZXR1cm4gbm9kZVxuICB9XG59XG5cbi8vIHVwZGF0YWJsZSBhdHRyaWJ1dGVzXG5jb25zdCBhdHRyID0ge1xuICBkaXNhYmxlZCAodmFsKSB7XG4gICAgdGhpcy5ub2RlLmRpc2FibGVkID0gISF2YWxcbiAgfSxcblxuICBwbGFjZWhvbGRlciAodmFsKSB7XG4gICAgdGhpcy5ub2RlLnBsYWNlaG9sZGVyID0gdmFsIHx8ICcnXG4gIH0sXG5cbiAgdmFsdWUgKHZhbCkge1xuICAgIHRoaXMubm9kZS52YWx1ZSA9IHZhbCB8fCAnJ1xuICB9LFxuXG4gIGF1dG9mb2N1cyAodmFsKSB7XG4gICAgdGhpcy5ub2RlLmF1dG9mb2N1cyA9ICEhdmFsXG4gIH0sXG5cbiAgdHlwZSAodmFsKSB7XG4gICAgdGhpcy5ub2RlLnR5cGUgPSBhdmFpbGFibGVUeXBlcy5pbmRleE9mKHZhbCkgIT09IC0xXG4gICAgICA/IHZhbFxuICAgICAgOiBERUZBVUxUX1RZUEVcbiAgfVxufVxuXG4vLyB1cGRhdGFibGUgc3R5bGVzXG5jb25zdCBzdHlsZSA9IHtcbiAgcGxhY2Vob2xkZXJDb2xvcjogZnVuY3Rpb24gKHZhbCkge1xuICAgIHNldFBsYWNlaG9sZGVyQ29sb3IodGhpcywgdmFsKVxuICB9XG59XG5cbi8vIGV2ZW50cyBjb25maWd1cmF0aW9uc1xuY29uc3QgZXZlbnQgPSB7XG4gIGlucHV0OiB7XG4gICAgdXBkYXRvciAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLm5vZGUudmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmEgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHRoaXMubm9kZS52YWx1ZSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNoYW5nZToge1xuICAgIHVwZGF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMubm9kZS52YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHRoaXMubm9kZS52YWx1ZSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcbiAgYXBwZW5kU3R5bGUgPSBXZWV4LnV0aWxzLmFwcGVuZFN0eWxlXG5cbiAgLy8gYXR0cnM6XG4gIC8vICAgLSB0eXBlOiB0ZXh0fHBhc3N3b3JkfHRlbHxlbWFpbHx1cmxcbiAgLy8gICAtIHZhbHVlXG4gIC8vICAgLSBwbGFjZWhvbGRlclxuICAvLyAgIC0gZGlzYWJsZWRcbiAgLy8gICAtIGF1dG9mb2N1c1xuICBmdW5jdGlvbiBJbnB1dCAoZGF0YSkge1xuICAgIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgSW5wdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoSW5wdXQucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKElucHV0LnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIGV4dGVuZChJbnB1dC5wcm90b3R5cGUsIHtcbiAgICBzdHlsZTogZXh0ZW5kKE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSksIHN0eWxlKVxuICB9KVxuICBleHRlbmQoSW5wdXQucHJvdG90eXBlLCB7IGV2ZW50IH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW5wdXQnLCBJbnB1dClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbnB1dC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuL3ZpZGVvLmNzcycpXG5cbmZ1bmN0aW9uIGdldFByb3RvIChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIHJldHVybiB7XG4gICAgY3JlYXRlICgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtdmlkZW8nLCAnd2VleC1lbGVtZW50JylcbiAgICAgIG5vZGUuY29udHJvbHMgPSB0cnVlXG4gICAgICBub2RlLmF1dG9wbGF5ID0gdGhpcy5hdXRvUGxheVxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3BsYXktc3RhdHVzJywgdGhpcy5wbGF5U3RhdHVzKVxuICAgICAgdGhpcy5ub2RlID0gbm9kZVxuICAgICAgaWYgKHRoaXMuYXV0b1BsYXkgJiYgdGhpcy5wbGF5U3RhdHVzID09PSAncGxheScpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlXG4gICAgfSxcblxuICAgIGJpbmRFdmVudHMgKGV2dHMpIHtcbiAgICAgIEF0b21pYy5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMsIGV2dHMpXG5cbiAgICAgIC8vIGNvbnZlcnQgdzNjLXZpZGVvIGV2ZW50cyB0byB3ZWV4LXZpZGVvIGV2ZW50cy5cbiAgICAgIGNvbnN0IGV2dHNNYXAgPSB7XG4gICAgICAgIHN0YXJ0OiAncGxheScsXG4gICAgICAgIGZpbmlzaDogJ2VuZGVkJyxcbiAgICAgICAgZmFpbDogJ2Vycm9yJ1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBldnROYW1lIGluIGV2dHNNYXApIHtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0c01hcFtldnROYW1lXSwgZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodHlwZSwgZS5kYXRhKVxuICAgICAgICB9LmJpbmQodGhpcywgZXZ0TmFtZSkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHBsYXkgKCkge1xuICAgICAgbGV0IHNyYyA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICBpZiAoIXNyYykge1xuICAgICAgICBzcmMgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpXG4gICAgICAgIHNyYyAmJiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpXG4gICAgICB9XG4gICAgICB0aGlzLm5vZGUucGxheSgpXG4gICAgfSxcblxuICAgIHBhdXNlICgpIHtcbiAgICAgIHRoaXMubm9kZS5wYXVzZSgpXG4gICAgfSxcblxuICAgIHN0b3AgKCkge1xuICAgICAgdGhpcy5ub2RlLnBhdXNlKClcbiAgICAgIHRoaXMubm9kZS5hdXRvcGxheSA9IGZhbHNlXG4gICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXNyYycsIHRoaXMubm9kZS5zcmMpXG4gICAgICB0aGlzLm5vZGUuc3JjID0gJydcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgcGxheVN0YXR1cyAodmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gJ3BsYXknICYmIHZhbCAhPT0gJ3N0b3AnICYmIHZhbCAhPT0gJ3BhdXNlJykge1xuICAgICAgdmFsID0gJ3BhdXNlJ1xuICAgIH1cbiAgICBpZiAodGhpcy5wbGF5U3RhdHVzID09PSB2YWwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnBsYXlTdGF0dXMgPSB2YWxcbiAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdwbGF5LXN0YXR1cycsIHZhbClcbiAgICB0aGlzW3RoaXMucGxheVN0YXR1c10oKVxuICB9LFxuXG4gIGF1dG9QbGF5ICh2YWwpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIC8vIGF0dHJzOlxuICAvLyAgIC0gYXV0b1BsYXk6IHRydWUgfCBmYWxzZSAoZGVmYXVsdDogZmFsc2UpXG4gIC8vICAgLSBwbGF5U3RhdHVzOiBwbGF5IHwgcGF1c2UgfCBzdG9wXG4gIC8vICAgLSBzcmM6IHtzdHJpbmd9XG4gIC8vICAgLSBwb3N0ZXI6IHtzdHJpbmd9XG4gIC8vICAgLSBsb29wOiB0cnVlIHwgZmFsc2UgKGRlZmF1bHQ6IGZhbHNlKVxuICAvLyAgIC0gbXV0ZWQ6IHRydWUgfCBmYWxzZSAoZGVmYXVsdDogZmFsc2UpXG4gIC8vIGV2ZW50czpcbiAgLy8gICAtIHN0YXJ0XG4gIC8vICAgLSBwYXVzZVxuICAvLyAgIC0gZmluaXNoXG4gIC8vICAgLSBmYWlsXG4gIGZ1bmN0aW9uIFZpZGVvIChkYXRhKSB7XG4gICAgY29uc3QgYXV0b1BsYXkgPSBkYXRhLmF0dHIuYXV0b1BsYXlcbiAgICBjb25zdCBwbGF5U3RhdHVzID0gZGF0YS5hdHRyLnBsYXlTdGF0dXNcbiAgICB0aGlzLmF1dG9QbGF5ID0gYXV0b1BsYXkgPT09IHRydWUgfHwgYXV0b1BsYXkgPT09ICd0cnVlJ1xuICAgIGlmIChwbGF5U3RhdHVzICE9PSAncGxheSdcbiAgICAgICAgJiYgcGxheVN0YXR1cyAhPT0gJ3N0b3AnXG4gICAgICAgICYmIHBsYXlTdGF0dXMgIT09ICdwYXVzZScpIHtcbiAgICAgIHRoaXMucGxheVN0YXR1cyA9ICdwYXVzZSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnBsYXlTdGF0dXMgPSBwbGF5U3RhdHVzXG4gICAgfVxuICAgIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgVmlkZW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoVmlkZW8ucHJvdG90eXBlLCBnZXRQcm90byhXZWV4KSlcbiAgZXh0ZW5kKFZpZGVvLnByb3RvdHlwZSwgeyBhdHRyIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgndmlkZW8nLCBWaWRlbylcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3ZpZGVvL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi92aWRlby5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdmlkZW8uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdmlkZW8uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy92aWRlby92aWRlby5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtdmlkZW8ge1xcblxcdGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3ZpZGVvL3ZpZGVvLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4vc3dpdGNoLmNzcycpXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBjb2xvcjogJyM2NGJkNjMnLFxuICBzZWNvbmRhcnlDb2xvcjogJyNkZmRmZGYnLFxuICBqYWNrQ29sb3I6ICcjZmZmJyxcbiAgamFja1NlY29uZGFyeUNvbG9yOiBudWxsLFxuICBjbGFzc05hbWU6ICd3ZWV4LXN3aXRjaCcsXG4gIGRpc2FibGVkT3BhY2l0eTogMC41LFxuICBzcGVlZDogJzAuNHMnLFxuICB3aWR0aDogMTAwLFxuICBoZWlnaHQ6IDYwLFxuICAvLyBpcyB3aWR0aCBhbmQgaGVpZ2h0IHNjYWxhYmxlID9cbiAgc2NhbGFibGU6IGZhbHNlXG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25pemUgKGVsZW1lbnQsIHByb3BzKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gW11cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICB0cmFuc2l0aW9ucy5wdXNoKGtleSArICcgJyArIHByb3BzW2tleV0pXG4gIH1cbiAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCAnKVxuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucy5qb2luKCcsICcpXG59XG5cbmZ1bmN0aW9uIHNldFNpemUgKGNvbXApIHtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oY29tcC53aWR0aCwgY29tcC5oZWlnaHQpXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KGNvbXAud2lkdGgsIGNvbXAuaGVpZ2h0KVxuICBjb21wLm5vZGUuc3R5bGUud2lkdGggPSBtYXggKyAncHgnXG4gIGNvbXAubm9kZS5zdHlsZS5oZWlnaHQgPSBtaW4gKyAncHgnXG4gIGNvbXAubm9kZS5zdHlsZS5ib3JkZXJSYWRpdXMgPSBtaW4gLyAyICsgJ3B4J1xuICBjb21wLmphY2suc3R5bGUud2lkdGhcbiAgICAgID0gY29tcC5qYWNrLnN0eWxlLmhlaWdodFxuICAgICAgPSBtaW4gKyAncHgnXG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aW9uIChjb21wLCBjbGlja2VkKSB7XG4gIGxldCBjaGVja2VkID0gY29tcC5jaGVja2VkXG4gIGNvbnN0IG5vZGUgPSBjb21wLm5vZGVcbiAgY29uc3QgamFjayA9IGNvbXAuamFja1xuXG4gIGlmIChjbGlja2VkICYmIGNoZWNrZWQpIHtcbiAgICBjaGVja2VkID0gZmFsc2VcbiAgfVxuICBlbHNlIGlmIChjbGlja2VkICYmICFjaGVja2VkKSB7XG4gICAgY2hlY2tlZCA9IHRydWVcbiAgfVxuXG4gIGlmIChjaGVja2VkID09PSB0cnVlKSB7XG4gICAgY29tcC5jaGVja2VkID0gdHJ1ZVxuXG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICBqYWNrLnN0eWxlLmxlZnQgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoamFjaykud2lkdGgpICsgJ3B4J1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGphY2suc3R5bGUubGVmdCA9IHBhcnNlSW50KG5vZGUuY3VycmVudFN0eWxlWyd3aWR0aCddKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludChqYWNrLmN1cnJlbnRTdHlsZVsnd2lkdGgnXSkgKyAncHgnXG4gICAgfVxuXG4gICAgY29tcC5vcHRpb25zLmNvbG9yICYmIGNvbG9yaXplKGNvbXApXG4gICAgc2V0U3BlZWQoY29tcClcbiAgfVxuICBlbHNlIHtcbiAgICBjb21wLmNoZWNrZWQgPSBmYWxzZVxuICAgIGphY2suc3R5bGUubGVmdCA9IDBcbiAgICBub2RlLnN0eWxlLmJveFNoYWRvdyA9ICdpbnNldCAwIDAgMCAwICcgKyBjb21wLm9wdGlvbnMuc2Vjb25kYXJ5Q29sb3JcbiAgICBub2RlLnN0eWxlLmJvcmRlckNvbG9yID0gY29tcC5vcHRpb25zLnNlY29uZGFyeUNvbG9yXG4gICAgbm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgPSAoY29tcC5vcHRpb25zLnNlY29uZGFyeUNvbG9yICE9PSBkZWZhdWx0cy5zZWNvbmRhcnlDb2xvcilcbiAgICAgICAgICA/IGNvbXAub3B0aW9ucy5zZWNvbmRhcnlDb2xvclxuICAgICAgICAgIDogJyNmZmYnXG4gICAgamFjay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgPSAoY29tcC5vcHRpb25zLmphY2tTZWNvbmRhcnlDb2xvciAhPT0gY29tcC5vcHRpb25zLmphY2tDb2xvcilcbiAgICAgICAgICA/IGNvbXAub3B0aW9ucy5qYWNrU2Vjb25kYXJ5Q29sb3JcbiAgICAgICAgICA6IGNvbXAub3B0aW9ucy5qYWNrQ29sb3JcbiAgICBzZXRTcGVlZChjb21wKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFNwZWVkIChjb21wKSB7XG4gIGxldCBzd2l0Y2hlclByb3AgPSB7fVxuICBjb25zdCBqYWNrUHJvcCA9IHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNvbXAub3B0aW9ucy5zcGVlZCxcbiAgICBsZWZ0OiBjb21wLm9wdGlvbnMuc3BlZWQucmVwbGFjZSgvW2Etel0vLCAnJykgLyAyICsgJ3MnXG4gIH1cblxuICBpZiAoY29tcC5jaGVja2VkKSB7XG4gICAgc3dpdGNoZXJQcm9wID0ge1xuICAgICAgYm9yZGVyOiBjb21wLm9wdGlvbnMuc3BlZWQsXG4gICAgICAnYm94LXNoYWRvdyc6IGNvbXAub3B0aW9ucy5zcGVlZCxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogY29tcC5vcHRpb25zLnNwZWVkLnJlcGxhY2UoL1thLXpdLywgJycpICogMyArICdzJ1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzd2l0Y2hlclByb3AgPSB7XG4gICAgICBib3JkZXI6IGNvbXAub3B0aW9ucy5zcGVlZCxcbiAgICAgICdib3gtc2hhZG93JzogY29tcC5vcHRpb25zLnNwZWVkXG4gICAgfVxuICB9XG5cbiAgdHJhbnNpdGlvbml6ZShjb21wLm5vZGUsIHN3aXRjaGVyUHJvcClcbiAgdHJhbnNpdGlvbml6ZShjb21wLmphY2ssIGphY2tQcm9wKVxufVxuXG5mdW5jdGlvbiBjb2xvcml6ZSAoY29tcCkge1xuICBjb25zdCBub2RlSGVpZ2h0ID0gY29tcC5ub2RlLm9mZnNldEhlaWdodCAvIDJcblxuICBjb21wLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29tcC5vcHRpb25zLmNvbG9yXG4gIGNvbXAubm9kZS5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbXAub3B0aW9ucy5jb2xvclxuICBjb21wLm5vZGUuc3R5bGUuYm94U2hhZG93ID0gJ2luc2V0IDAgMCAwICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgbm9kZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAncHggJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21wLm9wdGlvbnMuY29sb3JcbiAgY29tcC5qYWNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbXAub3B0aW9ucy5qYWNrQ29sb3Jcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpY2tIYW5kbGVyIChjb21wKSB7XG4gIGlmICghY29tcC5fY2xpY2tIYW5kbGVyKSB7XG4gICAgY29tcC5fY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UG9zaXRpb24oY29tcCwgdHJ1ZSlcbiAgICAgIGNvbXAuZGlzcGF0Y2hFdmVudCgnY2hhbmdlJywge1xuICAgICAgICB2YWx1ZTogY29tcC5jaGVja2VkXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcC5fY2xpY2tIYW5kbGVyXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICB0aGlzLmphY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbWFsbCcpXG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmphY2spXG4gICAgbm9kZS5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lXG4gICAgdGhpcy5ub2RlID0gbm9kZVxuICAgIHRoaXMuYXR0ci5kaXNhYmxlZC5jYWxsKHRoaXMsIHRoaXMuZGF0YS5hdHRyLmRpc2FibGVkKVxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgb25BcHBlbmQgKCkge1xuICAgIHNldFNpemUodGhpcylcbiAgICBzZXRQb3NpdGlvbih0aGlzKVxuICB9LFxuXG4gIGVuYWJsZSAoKSB7XG4gICAgdGhpcy5kaXNhYmxlZCAmJiAodGhpcy5kaXNhYmxlZCA9IGZhbHNlKVxuICAgIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gMVxuICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGdldENsaWNrSGFuZGxlcih0aGlzKSlcbiAgfSxcblxuICBkaXNhYmxlICgpIHtcbiAgICAhdGhpcy5kaXNhYmxlZCAmJiAodGhpcy5kaXNhYmxlZCA9IHRydWUpXG4gICAgdGhpcy5ub2RlLnN0eWxlLm9wYWNpdHkgPSBkZWZhdWx0cy5kaXNhYmxlZE9wYWNpdHlcbiAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZXRDbGlja0hhbmRsZXIodGhpcykpXG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgZGlzYWJsZWQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gdmFsICYmIHZhbCAhPT0gJ2ZhbHNlJ1xuICAgIHRoaXMuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoKSA6IHRoaXMuZW5hYmxlKClcbiAgfVxufVxuXG5jb25zdCBzdHlsZSA9IHtcbiAgd2lkdGg6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA8IDApIHtcbiAgICAgIHZhbCA9IHRoaXMub3B0aW9ucy53aWR0aFxuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5zZXRTaXplKClcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA8IDApIHtcbiAgICAgIHZhbCA9IHRoaXMub3B0aW9ucy5oZWlnaHRcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSB2YWwgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICB0aGlzLnNldFNpemUoKVxuICB9XG59XG5cbmNvbnN0IGV2ZW50ID0ge1xuICBjaGFuZ2U6IHtcbiAgICB1cGRhdG9yICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgY2hlY2tlZDogdGhpcy5jaGVja2VkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmNoZWNrZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIC8vIGF0dHJzOlxuICAvLyAgIC0gY2hlY2tlZDogaWYgaXMgY2hlY2tlZC5cbiAgLy8gICAtIGRpc2FibGVkOiBpZiB0cnVlLCB0aGlzIGNvbXBvbmVudCBpcyBub3QgYXZhaWxhYmxlIGZvciBpbnRlcmFjdGlvbi5cbiAgZnVuY3Rpb24gU3dpdGNoIChkYXRhKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cylcbiAgICB0aGlzLmNoZWNrZWQgPSBkYXRhLmF0dHIuY2hlY2tlZFxuICAgICAgICAmJiBkYXRhLmF0dHIuY2hlY2tlZCAhPT0gJ2ZhbHNlJ1xuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLndpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoICogZGF0YS5zY2FsZVxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodCAqIGRhdGEuc2NhbGVcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFN3aXRjaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG4gIGV4dGVuZChTd2l0Y2gucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKFN3aXRjaC5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoU3dpdGNoLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG4gIGV4dGVuZChTd2l0Y2gucHJvdG90eXBlLCB7IGV2ZW50IH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc3dpdGNoJywgU3dpdGNoKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zd2l0Y2guY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3dpdGNoL3N3aXRjaC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogc3dpdGNoIGRlZmF1bHRzLiAqL1xcbi53ZWV4LXN3aXRjaCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RmZGZkZjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xcbn1cXG5cXG4ud2VleC1zd2l0Y2ggPiBzbWFsbCB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3N3aXRjaC9zd2l0Y2guY3NzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gZ2V0UHJvdG8gKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUgKCkge1xuICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicpXG4gICAgICBub2RlLnN0eWxlLnRleHREZWNvcmF0aW9uID0gJ25vbmUnXG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0sXG5cbiAgICBiaW5kRXZlbnRzIChldnRzKSB7XG4gICAgICAvLyBldmVudCBoYW5kbGVyIGZvciBjbGljayBldmVudCB3aWxsIGJlIHByb2Nlc3NlZFxuICAgICAgLy8gYmVmb3JlIHRoZSB1cmwgcmVkaXJlY3Rpb24uXG4gICAgICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzLCBldnRzKVxuICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0Ll9hbHJlYWR5RmlyZWQgJiYgZXZ0LnRhcmdldCAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGV2ZW50IHRhcmdldCBpcyB0aGlzLm5vZGUsIHRoZW4gdGhpcyBpc1xuICAgICAgICAgIC8vIGp1c3QgYW5vdGhlciBjbGljayBldmVudCBoYW5kbGVyIGZvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIHRhcmdldCwgbm90IGEgaGFuZGxlciBmb3IgYSBidWJibGluZyB1cCBldmVudCxcbiAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgYSBidWJibGluZyB1cCBldmVudCwgYW5kIGl0XG4gICAgICAgICAgLy8gc2hvdWxkIGJlIGRpc3JlZ2FyZGVkLlxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGV2dC5fYWxyZWFkeUZpcmVkID0gdHJ1ZVxuICAgICAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5ocmVmXG4gICAgICB9LmJpbmQodGhpcykpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIGhyZWY6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignW3dlYi1yZW5kZXJdIGhyZWYgb2YgPGE+IHNob3VsZCBub3QgYmUgYSBudWxsIHZhbHVlLicpXG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IHZhbFxuICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicsIHZhbClcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgLy8gYXR0cnM6XG4gIC8vICAgLSBocmVmXG4gIGZ1bmN0aW9uIEEgKGRhdGEpIHtcbiAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG5cbiAgQS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChBLnByb3RvdHlwZSwgZ2V0UHJvdG8oV2VleCkpXG4gIGV4dGVuZChBLnByb3RvdHlwZSwgeyBhdHRyIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnYScsIEEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9hLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IElEX1BSRUZJWCA9ICd3ZWV4X2VtYmVkXydcblxubGV0IGdldFJhbmRvbVxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZCAoKSB7XG4gIHJldHVybiBJRF9QUkVGSVggKyBnZXRSYW5kb20oMTApXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuaWQgPSB0aGlzLmlkXG4gICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBpbml0V2VleCAoKSB7XG4gICAgdGhpcy5pZCA9IF9nZW5lcmF0ZUlkKClcbiAgICB0aGlzLm5vZGUuaWQgPSB0aGlzLmlkXG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgYXBwSWQ6IHRoaXMuaWQsXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgYnVuZGxlVXJsOiB0aGlzLnNvdXJjZSxcbiAgICAgIGxvYWRlcjogdGhpcy5sb2FkZXIsXG4gICAgICBqc29ucENhbGxiYWNrOiB0aGlzLmpzb25wQ2FsbGJhY2ssXG4gICAgICB3aWR0aDogdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuICAgICAgcm9vdElkOiB0aGlzLmlkLFxuICAgICAgZW1iZWQ6IHRydWVcbiAgICB9XG4gICAgd2luZG93LndlZXguaW5pdChjb25maWcpXG4gIH0sXG5cbiAgZGVzdHJveVdlZXggKCkge1xuICAgIHRoaXMuaWQgJiYgd2luZG93LmRlc3Ryb3lJbnN0YW5jZSh0aGlzLmlkKVxuICAgIC8vIFRPRE86IHVuYmluZCBldmVudHMgYW5kIGNsZWFyIGRvbXMuXG4gICAgdGhpcy5ub2RlLmlubmVySFRNTCA9ICcnXG4gIH0sXG5cbiAgcmVsb2FkV2VleCAoKSB7XG4gICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgIHRoaXMuZGVzdHJveVdlZXgoKVxuICAgICAgdGhpcy5pZCA9IG51bGxcbiAgICAgIHRoaXMubm9kZS5pZCA9IG51bGxcbiAgICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJ1xuICAgIH1cbiAgICB0aGlzLmluaXRXZWV4KClcbiAgfVxufVxuXG4vLyBub3QgcmVjb21tZW5kZWQsIGJlY2F1c2Ugb2YgdGhlIGxlYWsgb2YgbWVtb3J5LlxuY29uc3QgYXR0ciA9IHtcbiAgc3JjOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHZhbHVlXG4gICAgdGhpcy5yZWxvYWRXZWV4KClcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG4gIGdldFJhbmRvbSA9IFdlZXgudXRpbHMuZ2V0UmFuZG9tXG5cbiAgZnVuY3Rpb24gRW1iZWQgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgY29uc3QgYXR0ciA9IGRhdGEuYXR0clxuICAgIGlmIChhdHRyKSB7XG4gICAgICB0aGlzLnNvdXJjZSA9IGF0dHIuc3JjXG4gICAgICB0aGlzLmxvYWRlciA9IGF0dHIubG9hZGVyIHx8ICd4aHInXG4gICAgICB0aGlzLmpzb25wQ2FsbGJhY2sgPSBhdHRyLmpzb25wQ2FsbGJhY2tcbiAgICB9XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSwgbm9kZVR5cGUpXG4gIH1cblxuICBFbWJlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChFbWJlZC5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoRW1iZWQucHJvdG90eXBlLCB7IGF0dHIgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdlbWJlZCcsIEVtYmVkKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2VtYmVkLmpzXG4gKiovIiwiLyogZ2xvYmFsIENTU1J1bGUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4vc3Bpbm5lci5jc3MnKVxuXG5sZXQgbG9vcEFycmF5LCBnZXRSZ2JcblxuZnVuY3Rpb24gZ2V0U3R5bGVTaGVldCAoc3Bpbm5lcikge1xuICBpZiAoc3Bpbm5lci5zdHlsZVNoZWV0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc3R5bGVzID0gZG9jdW1lbnQuc3R5bGVTaGVldHNcbiAgbGV0IGksIGwsIGosIG1cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tbGFiZWxzICovXG4gIG91dGVyOiBmb3IgKGkgPSAwLCBsID0gc3R5bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHJ1bGVzID0gc3R5bGVzW2ldLnJ1bGVzXG4gICAgZm9yIChqID0gMCwgbSA9IHJ1bGVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgY29uc3QgaXRlbSA9IHJ1bGVzLml0ZW0oailcbiAgICAgIGlmIChcbiAgICAgICAgKGl0ZW0udHlwZSA9PT0gQ1NTUnVsZS5LRVlGUkFNRVNfUlVMRVxuICAgICAgICAgIHx8IGl0ZW0udHlwZSA9PT0gQ1NTUnVsZS5XRUJLSVRfS0VZRlJBTUVTX1JVTEUpXG4gICAgICAgICYmIGl0ZW0ubmFtZSA9PT0gJ3NwaW5uZXInKSB7XG4gICAgICAgIGJyZWFrIG91dGVyXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tbGFiZWxzICovXG4gIHNwaW5uZXIuc3R5bGVTaGVldCA9IHN0eWxlc1tpXVxufVxuXG5mdW5jdGlvbiBzZXRLZXlmcmFtZUNvbG9yIChzcGlubmVyLCB2YWwpIHtcbiAgZ2V0U3R5bGVTaGVldChzcGlubmVyKVxuICBjb25zdCBrZXlmcmFtZVJ1bGVzID0gY29tcHV0ZUtleUZyYW1lUnVsZXModmFsKVxuICBjb25zdCBydWxlcyA9IHNwaW5uZXIuc3R5bGVTaGVldC5ydWxlc1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBydWxlcy5pdGVtKGkpXG4gICAgaWYgKChpdGVtLnR5cGUgPT09IENTU1J1bGUuS0VZRlJBTUVTX1JVTEVcbiAgICAgICAgICB8fCBpdGVtLnR5cGUgPT09IENTU1J1bGUuV0VCS0lUX0tFWUZSQU1FU19SVUxFKVxuICAgICAgICAmJiBpdGVtLm5hbWUgPT09ICdzcGlubmVyJykge1xuICAgICAgY29uc3QgY3NzUnVsZXMgPSBpdGVtLmNzc1J1bGVzXG4gICAgICBmb3IgKGxldCBqID0gMCwgbSA9IGNzc1J1bGVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGNzc1J1bGVzW2pdXG4gICAgICAgIGlmIChrZXlmcmFtZS50eXBlID09PSBDU1NSdWxlLktFWUZSQU1FX1JVTEVcbiAgICAgICAgICB8fCBrZXlmcmFtZS50eXBlID09PSBDU1NSdWxlLldFQktJVF9LRVlGUkFNRV9SVUxFKSB7XG4gICAgICAgICAga2V5ZnJhbWUuc3R5bGUuYm94U2hhZG93ID0ga2V5ZnJhbWVSdWxlc1tqXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVLZXlGcmFtZVJ1bGVzIChyZ2IpIHtcbiAgaWYgKCFyZ2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBzY2FsZUFyciA9IFtcbiAgICAnMGVtIC0yLjZlbSAwZW0gMGVtJyxcbiAgICAnMS44ZW0gLTEuOGVtIDAgMGVtJyxcbiAgICAnMi41ZW0gMGVtIDAgMGVtJyxcbiAgICAnMS43NWVtIDEuNzVlbSAwIDBlbScsXG4gICAgJzBlbSAyLjVlbSAwIDBlbScsXG4gICAgJy0xLjhlbSAxLjhlbSAwIDBlbScsXG4gICAgJy0yLjZlbSAwZW0gMCAwZW0nLFxuICAgICctMS44ZW0gLTEuOGVtIDAgMGVtJ11cbiAgY29uc3QgY29sb3JBcnIgPSBbXG4gICAgJzEnLFxuICAgICcwLjInLFxuICAgICcwLjInLFxuICAgICcwLjInLFxuICAgICcwLjInLFxuICAgICcwLjInLFxuICAgICcwLjUnLFxuICAgICcwLjcnXS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAncmdiYSgnICsgcmdiLnIgKyAnLCcgKyByZ2IuZyArICcsJyArIHJnYi5iICsgJywnICsgZSArICcpJ1xuICAgIH0pXG4gIGNvbnN0IHJ1bGVzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2FsZUFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRtcENvbG9yQXJyID0gbG9vcEFycmF5KGNvbG9yQXJyLCBpLCAncicpXG4gICAgcnVsZXMucHVzaChzY2FsZUFyci5tYXAoZnVuY3Rpb24gKHNjYWxlU3RyLCBpKSB7XG4gICAgICByZXR1cm4gc2NhbGVTdHIgKyAnICcgKyB0bXBDb2xvckFycltpXVxuICAgIH0pLmpvaW4oJywgJykpXG4gIH1cbiAgcmV0dXJuIHJ1bGVzXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnd2VleC1zcGlubmVyLXdyYXAnKVxuICAgIHRoaXMuc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5zcGlubmVyLmNsYXNzTGlzdC5hZGQoJ3dlZXgtZWxlbWVudCcsICd3ZWV4LXNwaW5uZXInKVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zcGlubmVyKVxuICAgIHJldHVybiBub2RlXG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIGNvbG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgY29uc3QgcmdiID0gZ2V0UmdiKHZhbClcbiAgICBpZiAoIXJnYikge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1t3ZWItcmVuZGVyXSBpbnZhbGlkIGNvbG9yIHZhbHVlOicsIHZhbClcbiAgICB9XG4gICAgc2V0S2V5ZnJhbWVDb2xvcih0aGlzLCByZ2IpXG4gIH1cbn1cblxuLy8gU3Bpbm5lci5wcm90b3R5cGUudXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbi8vICAgQXRvbWljLnByb3RvdHlwZS51cGRhdGVTdHlsZS5jYWxsKHRoaXMsIHN0eWxlKVxuLy8gICBpZiAoc3R5bGUgJiYgc3R5bGUuY29sb3IpIHtcbi8vICAgICB0aGlzLnNldEtleWZyYW1lQ29sb3IoZ2xvYmFsLndlZXgudXRpbHMuZ2V0UmdiKHRoaXMubm9kZS5zdHlsZS5jb2xvcikpXG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuICBnZXRSZ2IgPSBXZWV4LnV0aWxzLmdldFJnYlxuICBsb29wQXJyYXkgPSBXZWV4LnV0aWxzLmxvb3BBcnJheVxuXG4gIGZ1bmN0aW9uIFNwaW5uZXIgKGRhdGEpIHtcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFNwaW5uZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoU3Bpbm5lci5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoU3Bpbm5lci5wcm90b3R5cGUsIHtcbiAgICBzdHlsZTogZXh0ZW5kKE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSksIHN0eWxlKVxuICB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3NwaW5uZXInLCBTcGlubmVyKVxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdsb2FkaW5nLWluZGljYXRvcicsIFNwaW5uZXIpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3Bpbm5lci9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3Bpbm5lci5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3Bpbm5lci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zcGlubmVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud2VleC1zcGlubmVyLXdyYXAge1xcbiAgd2lkdGg6IDEuMDEzMzMzcmVtOyAvKiA3NnB4ICovXFxuICBoZWlnaHQ6IDEuMDEzMzMzcmVtO1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLndlZXgtc3Bpbm5lciB7XFxuICBmb250LXNpemU6IDAuMTZyZW07IC8qIDEycHggKi9cXG4gIHdpZHRoOiAxZW07XFxuICBoZWlnaHQ6IDFlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRleHQtaW5kZW50OiAtOTk5OWVtO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IHNwaW5uZXIgMS4xcyBpbmZpbml0ZSBlYXNlO1xcbiAgYW5pbWF0aW9uOiBzcGlubmVyIDEuMXMgaW5maW5pdGUgZWFzZTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcXG59XFxuQC13ZWJraXQta2V5ZnJhbWVzIHNwaW5uZXIge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtICNmZmZmZmYsIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxuICB9XFxuICAxMi41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDEuOGVtIC0xLjhlbSAwIDBlbSAjZmZmZmZmLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbiAgfVxcbiAgMjUlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMi41ZW0gMGVtIDAgMGVtICNmZmZmZmYsIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICAzNy41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gI2ZmZmZmZiwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDBlbSAyLjVlbSAwIDBlbSAjZmZmZmZmLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICA2Mi41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMS44ZW0gMS44ZW0gMCAwZW0gI2ZmZmZmZiwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNzUlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0yLjZlbSAwZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICA4Ny41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIC0xLjhlbSAwIDBlbSAjZmZmZmZmO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIHNwaW5uZXIge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtICNmZmZmZmYsIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxuICB9XFxuICAxMi41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDEuOGVtIC0xLjhlbSAwIDBlbSAjZmZmZmZmLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbiAgfVxcbiAgMjUlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgMi41ZW0gMGVtIDAgMGVtICNmZmZmZmYsIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICAzNy41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gI2ZmZmZmZiwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDBlbSAyLjVlbSAwIDBlbSAjZmZmZmZmLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICA2Mi41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMS44ZW0gMS44ZW0gMCAwZW0gI2ZmZmZmZiwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNzUlIHtcXG4gICAgYm94LXNoYWRvdzogMGVtIC0yLjZlbSAwZW0gMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0yLjZlbSAwZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICB9XFxuICA4Ny41JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMi42ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIC0xLjhlbSAwIDBlbSAjZmZmZmZmO1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zcGlubmVyL3NwaW5uZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxubGV0IGlzQXJyYXlcblxuZnVuY3Rpb24gaGFuZGxlTXNnICh3ZWIsIGV2dCkge1xuICBsZXQgbXNnID0gZXZ0LmRhdGFcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG1zZyA9IEpTT04ucGFyc2UobXNnKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge31cbiAgfVxuICBpZiAoIW1zZykge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtc2cudHlwZSA9PT0gJ3dlZXgnKSB7XG4gICAgaWYgKCFpc0FycmF5KG1zZy5jb250ZW50KSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIHdlZXggbXNnIHJlY2VpdmVkIGJ5IHdlYiBjb21wb25lbnQuJ1xuICAgICAgICArICcgbXNnLmNvbnRlbnQgc2hvdWxkIGJlIGEgYXJyYXk6JywgbXNnLmNvbnRlbnQpXG4gICAgfVxuICAgIGNhbGxOYXRpdmUod2ViLmdldENvbXBvbmVudE1hbmFnZXIoKS5pbnN0YW5jZUlkLCBtc2cuY29udGVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm90byAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZSAoKSB7XG4gICAgICAvLyBJZnJhbWUncyBkZWZlY3Q6IGNhbid0IHVzZSBwb3NpdGlvbjphYnNvbHV0ZSBhbmQgdG9wLCBsZWZ0LCByaWdodCxcbiAgICAgIC8vIGJvdHRvbSBhbGwgc2V0dGluZyB0byB6ZXJvIGFuZCB1c2UgbWFyZ2luIHRvIGxlYXZlIHNwZWNpZmllZFxuICAgICAgLy8gaGVpZ2h0IGZvciBhIGJsYW5rIGFyZWEsIGFuZCBoYXZlIHRvIHVzZSAxMDAlIHRvIGZpbGwgdGhlIHBhcmVudFxuICAgICAgLy8gY29udGFpbmVyLCBvdGhlcndpc2UgaXQgd2lsbCB1c2UgYSB1bndhbnRlZCBkZWZhdWx0IHNpemUgaW5zdGVhZC5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGRpdiBhcyBhIGlmcmFtZSB3cmFwcGVyIGlzIG5lZWRlZCBoZXJlLlxuICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJylcbiAgICAgIHRoaXMud2ViID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy53ZWIpXG4gICAgICB0aGlzLndlYi5jbGFzc0xpc3QuYWRkKCd3ZWV4LWVsZW1lbnQnKVxuICAgICAgdGhpcy53ZWIuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgIHRoaXMud2ViLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgdGhpcy53ZWIuc3R5bGUuYm9yZGVyID0gJ25vbmUnXG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0sXG5cbiAgICBiaW5kRXZlbnRzIChldnRzKSB7XG4gICAgICBBdG9taWMucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzLCBldnRzKVxuICAgICAgY29uc3QgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMud2ViLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQoJ3BhZ2VmaW5pc2gnLCB7XG4gICAgICAgICAgdXJsOiB0aGF0LndlYi5zcmNcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1zZy5iaW5kKG51bGwsIHRoaXMpKVxuICAgIH0sXG5cbiAgICBnb0JhY2sgKCkge1xuICAgICAgdGhpcy53ZWIuY29udGVudFdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICAgIH0sXG5cbiAgICBnb0ZvcndhcmQgKCkge1xuICAgICAgdGhpcy53ZWIuY29udGVudFdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKVxuICAgIH0sXG5cbiAgICByZWxvYWQgKCkge1xuICAgICAgdGhpcy53ZWIuY29udGVudFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBzcmM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLndlYi5zcmMgPSB2YWxcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncGFnZXN0YXJ0JywgeyB1cmw6IHZhbCB9KVxuICAgIH0uYmluZCh0aGlzKSwgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG4gIGlzQXJyYXkgPSBXZWV4LnV0aWxzLmlzQXJyYXlcblxuICAvLyBBIGNvbXBvbmVudCB0byBpbXBvcnQgd2ViIHBhZ2VzLCB3aGljaCB3b3JrcyBsaWtlXG4gIC8vIGEgaWZyYW1lIGVsZW1lbnQgb3IgYSB3ZWJ2aWV3LlxuICAvLyBhdHRyczpcbiAgLy8gICAtIHNyY1xuICAvLyBldmVudHM6XG4gIC8vICAgLSBwYWdlc3RhcnRcbiAgLy8gICAtIHBhZ2VmaW5pc2hcbiAgLy8gICAtIGVycm9yXG4gIGZ1bmN0aW9uIFdlYiAoZGF0YSkge1xuICAgIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgV2ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKFdlYi5wcm90b3R5cGUsIGdldFByb3RvKFdlZXgpKVxuICBleHRlbmQoV2ViLnByb3RvdHlwZSwgeyBhdHRyIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnd2ViJywgV2ViKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3dlYi5qc1xuICoqLyIsImltcG9ydCBkb20gZnJvbSAnLi9kb20nXG5pbXBvcnQgZXZlbnQgZnJvbSAnLi9ldmVudCdcbmltcG9ydCBwYWdlSW5mbyBmcm9tICcuL3BhZ2VJbmZvJ1xuaW1wb3J0IHN0cmVhbSBmcm9tICcuL3N0cmVhbSdcbmltcG9ydCBtb2RhbCBmcm9tICcuL21vZGFsJ1xuaW1wb3J0IGFuaW1hdGlvbiBmcm9tICcuL2FuaW1hdGlvbidcbmltcG9ydCB3ZWJ2aWV3IGZyb20gJy4vd2Vidmlldydcbi8vIGltcG9ydCB0aW1lciBmcm9tICcuL3RpbWVyJ1xuaW1wb3J0IG5hdmlnYXRvciBmcm9tICcuL25hdmlnYXRvcidcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSdcbmltcG9ydCBjbGlwYm9hcmQgZnJvbSAnLi9jbGlwYm9hcmQnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4Lmluc3RhbGwoZG9tKVxuICAgIFdlZXguaW5zdGFsbChldmVudClcbiAgICBXZWV4Lmluc3RhbGwocGFnZUluZm8pXG4gICAgV2VleC5pbnN0YWxsKHN0cmVhbSlcbiAgICBXZWV4Lmluc3RhbGwobW9kYWwpXG4gICAgV2VleC5pbnN0YWxsKGFuaW1hdGlvbilcbiAgICBXZWV4Lmluc3RhbGwod2VidmlldylcbiAgICAvLyBXZWV4Lmluc3RhbGwodGltZXIpXG4gICAgV2VleC5pbnN0YWxsKG5hdmlnYXRvcilcbiAgICBXZWV4Lmluc3RhbGwoc3RvcmFnZSlcbiAgICBXZWV4Lmluc3RhbGwoY2xpcGJvYXJkKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgc2Nyb2xsIGZyb20gJ3Njcm9sbC10bydcblxuY29uc3QgZG9tID0ge1xuICAvKipcbiAgICogc2Nyb2xsVG9FbGVtZW50XG4gICAqIEBwYXJhbSAge3N0cmluZ30gcmVmXG4gICAqIEBwYXJhbSAge29ian0gb3B0aW9ucyB7b2Zmc2V0Ok51bWJlcn1cbiAgICogICBwczogc2Nyb2xsLXRvIGhhcyAnZWFzZScgYW5kICdkdXJhdGlvbicobXMpIGFzIG9wdGlvbnMuXG4gICAqL1xuICBzY3JvbGxUb0VsZW1lbnQ6IGZ1bmN0aW9uIChyZWYsIG9wdGlvbnMpIHtcbiAgICAhb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KVxuICAgIGNvbnN0IG9mZnNldCA9IChOdW1iZXIob3B0aW9ucy5vZmZzZXQpIHx8IDApICogdGhpcy5zY2FsZVxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRDb21wb25lbnQocmVmKVxuICAgIGlmICghZWxlbSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIGNvbXBvbmVudCBvZiByZWYgJHtyZWZ9IGRvZXNuXFwndCBleGlzdC5gKVxuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTY3JvbGxlciA9IGVsZW0uZ2V0UGFyZW50U2Nyb2xsZXIoKVxuICAgIGlmIChwYXJlbnRTY3JvbGxlcikge1xuICAgICAgcGFyZW50U2Nyb2xsZXIuc2Nyb2xsZXIuc2Nyb2xsVG9FbGVtZW50KGVsZW0ubm9kZSwgdHJ1ZSwgb2Zmc2V0KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGVsZW0ubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wXG4gICAgICBjb25zdCB0d2VlbiA9IHNjcm9sbCgwLCBvZmZzZXRUb3AgKyBvZmZzZXQsIG9wdGlvbnMpXG4gICAgICB0d2Vlbi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnc2Nyb2xsIGVuZC4nKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgZG9tOiBbe1xuICAgIG5hbWU6ICdzY3JvbGxUb0VsZW1lbnQnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdkb20nLCBkb20sIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2RvbS5qc1xuICoqLyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHdlZW4gPSByZXF1aXJlKCd0d2VlbicpO1xudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpO1xuXG4vKipcbiAqIEV4cG9zZSBgc2Nyb2xsVG9gLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gc2Nyb2xsVG87XG5cbi8qKlxuICogU2Nyb2xsIHRvIGAoeCwgeSlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzY3JvbGxUbyh4LCB5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHN0YXJ0IHBvc2l0aW9uXG4gIHZhciBzdGFydCA9IHNjcm9sbCgpO1xuXG4gIC8vIHNldHVwIHR3ZWVuXG4gIHZhciB0d2VlbiA9IFR3ZWVuKHN0YXJ0KVxuICAgIC5lYXNlKG9wdGlvbnMuZWFzZSB8fCAnb3V0LWNpcmMnKVxuICAgIC50byh7IHRvcDogeSwgbGVmdDogeCB9KVxuICAgIC5kdXJhdGlvbihvcHRpb25zLmR1cmF0aW9uIHx8IDEwMDApO1xuXG4gIC8vIHNjcm9sbFxuICB0d2Vlbi51cGRhdGUoZnVuY3Rpb24obyl7XG4gICAgd2luZG93LnNjcm9sbFRvKG8ubGVmdCB8IDAsIG8udG9wIHwgMCk7XG4gIH0pO1xuXG4gIC8vIGhhbmRsZSBlbmRcbiAgdHdlZW4ub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgYW5pbWF0ZSA9IGZ1bmN0aW9uKCl7fTtcbiAgfSk7XG5cbiAgLy8gYW5pbWF0ZVxuICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIHJhZihhbmltYXRlKTtcbiAgICB0d2Vlbi51cGRhdGUoKTtcbiAgfVxuXG4gIGFuaW1hdGUoKTtcbiAgXG4gIHJldHVybiB0d2Vlbjtcbn1cblxuLyoqXG4gKiBSZXR1cm4gc2Nyb2xsIHBvc2l0aW9uLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgdmFyIHkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgdmFyIHggPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gIHJldHVybiB7IHRvcDogeSwgbGVmdDogeCB9O1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2Nyb2xsLXRvL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciBjbG9uZSA9IHJlcXVpcmUoJ2Nsb25lJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUnKTtcbnZhciBlYXNlID0gcmVxdWlyZSgnZWFzZScpO1xuXG4vKipcbiAqIEV4cG9zZSBgVHdlZW5gLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHdlZW47XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVHdlZW5gIHdpdGggYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBUd2VlbihvYmopIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFR3ZWVuKSkgcmV0dXJuIG5ldyBUd2VlbihvYmopO1xuICB0aGlzLl9mcm9tID0gb2JqO1xuICB0aGlzLmVhc2UoJ2xpbmVhcicpO1xuICB0aGlzLmR1cmF0aW9uKDUwMCk7XG59XG5cbi8qKlxuICogTWl4aW4gZW1pdHRlci5cbiAqL1xuXG5FbWl0dGVyKFR3ZWVuLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUmVzZXQgdGhlIHR3ZWVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHdlZW4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5pc0FycmF5ID0gJ2FycmF5JyA9PT0gdHlwZSh0aGlzLl9mcm9tKTtcbiAgdGhpcy5fY3VyciA9IGNsb25lKHRoaXMuX2Zyb20pO1xuICB0aGlzLl9kb25lID0gZmFsc2U7XG4gIHRoaXMuX3N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFR3ZWVuIHRvIGBvYmpgIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cbiAqXG4gKiAgICB0d2Vlbi50byh7IHg6IDUwLCB5OiAxMDAgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcmV0dXJuIHtUd2Vlbn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ud2Vlbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbihvYmope1xuICB0aGlzLnJlc2V0KCk7XG4gIHRoaXMuX3RvID0gb2JqO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGR1cmF0aW9uIHRvIGBtc2AgWzUwMF0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtUd2Vlbn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ud2Vlbi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihtcyl7XG4gIHRoaXMuX2R1cmF0aW9uID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZWFzaW5nIGZ1bmN0aW9uIHRvIGBmbmAuXG4gKlxuICogICAgdHdlZW4uZWFzZSgnaW4tb3V0LXNpbmUnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBmblxuICogQHJldHVybiB7VHdlZW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblR3ZWVuLnByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24oZm4pe1xuICBmbiA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIGZuID8gZm4gOiBlYXNlW2ZuXTtcbiAgaWYgKCFmbikgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlYXNpbmcgZnVuY3Rpb24nKTtcbiAgdGhpcy5fZWFzZSA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcCB0aGUgdHdlZW4gYW5kIGltbWVkaWF0ZWx5IGVtaXQgXCJzdG9wXCIgYW5kIFwiZW5kXCIuXG4gKlxuICogQHJldHVybiB7VHdlZW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblR3ZWVuLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnc3RvcCcpO1xuICB0aGlzLmVtaXQoJ2VuZCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhIHN0ZXAuXG4gKlxuICogQHJldHVybiB7VHdlZW59IHNlbGZcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblR3ZWVuLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2RvbmUpIHJldHVybjtcblxuICAvLyBkdXJhdGlvblxuICB2YXIgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gIHZhciBkZWx0YSA9IG5vdyAtIHRoaXMuX3N0YXJ0O1xuICB2YXIgZG9uZSA9IGRlbHRhID49IGR1cmF0aW9uO1xuXG4gIC8vIGNvbXBsZXRlXG4gIGlmIChkb25lKSB7XG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX3RvO1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl90byk7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHR3ZWVuXG4gIHZhciBmcm9tID0gdGhpcy5fZnJvbTtcbiAgdmFyIHRvID0gdGhpcy5fdG87XG4gIHZhciBjdXJyID0gdGhpcy5fY3VycjtcbiAgdmFyIGZuID0gdGhpcy5fZWFzZTtcbiAgdmFyIHAgPSAobm93IC0gdGhpcy5fc3RhcnQpIC8gZHVyYXRpb247XG4gIHZhciBuID0gZm4ocCk7XG5cbiAgLy8gYXJyYXlcbiAgaWYgKHRoaXMuaXNBcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJvbS5sZW5ndGg7ICsraSkge1xuICAgICAgY3VycltpXSA9IGZyb21baV0gKyAodG9baV0gLSBmcm9tW2ldKSAqIG47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKGN1cnIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gb2JqZWNoXG4gIGZvciAodmFyIGsgaW4gZnJvbSkge1xuICAgIGN1cnJba10gPSBmcm9tW2tdICsgKHRvW2tdIC0gZnJvbVtrXSkgKiBuO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKGN1cnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHVwZGF0ZSBmdW5jdGlvbiB0byBgZm5gIG9yXG4gKiB3aGVuIG5vIGFyZ3VtZW50IGlzIGdpdmVuIHRoaXMgcGVyZm9ybXNcbiAqIGEgXCJzdGVwXCIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1R3ZWVufSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblR3ZWVuLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihmbil7XG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLnN0ZXAoKTtcbiAgdGhpcy5fdXBkYXRlID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR5cGU7XG50cnkge1xuICB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgdHlwZSA9IHJlcXVpcmUoJ3R5cGUnKTtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENsb25lcyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFueSBvYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY2xvbmUob2JqKXtcbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdmFyIGNvcHkgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29weVtrZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvcHlbaV0gPSBjbG9uZShvYmpbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG5cbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgLy8gZnJvbSBtaWxsZXJtZWRlaXJvcy9hbWQtdXRpbHMgLSBNSVRcbiAgICAgIHZhciBmbGFncyA9ICcnO1xuICAgICAgZmxhZ3MgKz0gb2JqLm11bHRpbGluZSA/ICdtJyA6ICcnO1xuICAgICAgZmxhZ3MgKz0gb2JqLmdsb2JhbCA/ICdnJyA6ICcnO1xuICAgICAgZmxhZ3MgKz0gb2JqLmlnbm9yZUNhc2UgPyAnaScgOiAnJztcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iai5zb3VyY2UsIGZsYWdzKTtcblxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpO1xuXG4gICAgZGVmYXVsdDogLy8gc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIOKAplxuICAgICAgcmV0dXJuIG9iajtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2Nyb2xsLXRvL34vY29tcG9uZW50LXR3ZWVuL34vY29tcG9uZW50LWNsb25lL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIHRvU3RyaW5nIHJlZi5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpe1xuICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6IHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuICB2YWwgPSB2YWwudmFsdWVPZlxuICAgID8gdmFsLnZhbHVlT2YoKVxuICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbClcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vfi9jb21wb25lbnQtdHlwZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4vLyBlYXNpbmcgZnVuY3Rpb25zIGZyb20gXCJUd2Vlbi5qc1wiXG5cbmV4cG9ydHMubGluZWFyID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuO1xufTtcblxuZXhwb3J0cy5pblF1YWQgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRRdWFkID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICogKDIgLSBuKTtcbn07XG5cbmV4cG9ydHMuaW5PdXRRdWFkID0gZnVuY3Rpb24obil7XG4gIG4gKj0gMjtcbiAgaWYgKG4gPCAxKSByZXR1cm4gMC41ICogbiAqIG47XG4gIHJldHVybiAtIDAuNSAqICgtLW4gKiAobiAtIDIpIC0gMSk7XG59O1xuXG5leHBvcnRzLmluQ3ViZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiAqIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRDdWJlID0gZnVuY3Rpb24obil7XG4gIHJldHVybiAtLW4gKiBuICogbiArIDE7XG59O1xuXG5leHBvcnRzLmluT3V0Q3ViZSA9IGZ1bmN0aW9uKG4pe1xuICBuICo9IDI7XG4gIGlmIChuIDwgMSkgcmV0dXJuIDAuNSAqIG4gKiBuICogbjtcbiAgcmV0dXJuIDAuNSAqICgobiAtPSAyICkgKiBuICogbiArIDIpO1xufTtcblxuZXhwb3J0cy5pblF1YXJ0ID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICogbiAqIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRRdWFydCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtICgtLW4gKiBuICogbiAqIG4pO1xufTtcblxuZXhwb3J0cy5pbk91dFF1YXJ0ID0gZnVuY3Rpb24obil7XG4gIG4gKj0gMjtcbiAgaWYgKG4gPCAxKSByZXR1cm4gMC41ICogbiAqIG4gKiBuICogbjtcbiAgcmV0dXJuIC0wLjUgKiAoKG4gLT0gMikgKiBuICogbiAqIG4gLSAyKTtcbn07XG5cbmV4cG9ydHMuaW5RdWludCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiAqIG4gKiBuICogbiAqIG47XG59XG5cbmV4cG9ydHMub3V0UXVpbnQgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIC0tbiAqIG4gKiBuICogbiAqIG4gKyAxO1xufVxuXG5leHBvcnRzLmluT3V0UXVpbnQgPSBmdW5jdGlvbihuKXtcbiAgbiAqPSAyO1xuICBpZiAobiA8IDEpIHJldHVybiAwLjUgKiBuICogbiAqIG4gKiBuICogbjtcbiAgcmV0dXJuIDAuNSAqICgobiAtPSAyKSAqIG4gKiBuICogbiAqIG4gKyAyKTtcbn07XG5cbmV4cG9ydHMuaW5TaW5lID0gZnVuY3Rpb24obil7XG4gIHJldHVybiAxIC0gTWF0aC5jb3MobiAqIE1hdGguUEkgLyAyICk7XG59O1xuXG5leHBvcnRzLm91dFNpbmUgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIE1hdGguc2luKG4gKiBNYXRoLlBJIC8gMik7XG59O1xuXG5leHBvcnRzLmluT3V0U2luZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBuKSk7XG59O1xuXG5leHBvcnRzLmluRXhwbyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMCA9PSBuID8gMCA6IE1hdGgucG93KDEwMjQsIG4gLSAxKTtcbn07XG5cbmV4cG9ydHMub3V0RXhwbyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSA9PSBuID8gbiA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBuKTtcbn07XG5cbmV4cG9ydHMuaW5PdXRFeHBvID0gZnVuY3Rpb24obil7XG4gIGlmICgwID09IG4pIHJldHVybiAwO1xuICBpZiAoMSA9PSBuKSByZXR1cm4gMTtcbiAgaWYgKChuICo9IDIpIDwgMSkgcmV0dXJuIC41ICogTWF0aC5wb3coMTAyNCwgbiAtIDEpO1xuICByZXR1cm4gLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChuIC0gMSkpICsgMik7XG59O1xuXG5leHBvcnRzLmluQ2lyYyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gbiAqIG4pO1xufTtcblxuZXhwb3J0cy5vdXRDaXJjID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLW4gKiBuKSk7XG59O1xuXG5leHBvcnRzLmluT3V0Q2lyYyA9IGZ1bmN0aW9uKG4pe1xuICBuICo9IDJcbiAgaWYgKG4gPCAxKSByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIG4gKiBuKSAtIDEpO1xuICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKG4gLT0gMikgKiBuKSArIDEpO1xufTtcblxuZXhwb3J0cy5pbkJhY2sgPSBmdW5jdGlvbihuKXtcbiAgdmFyIHMgPSAxLjcwMTU4O1xuICByZXR1cm4gbiAqIG4gKiAoKCBzICsgMSApICogbiAtIHMpO1xufTtcblxuZXhwb3J0cy5vdXRCYWNrID0gZnVuY3Rpb24obil7XG4gIHZhciBzID0gMS43MDE1ODtcbiAgcmV0dXJuIC0tbiAqIG4gKiAoKHMgKyAxKSAqIG4gKyBzKSArIDE7XG59O1xuXG5leHBvcnRzLmluT3V0QmFjayA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgaWYgKCAoIG4gKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiAoIG4gKiBuICogKCAoIHMgKyAxICkgKiBuIC0gcyApICk7XG4gIHJldHVybiAwLjUgKiAoICggbiAtPSAyICkgKiBuICogKCAoIHMgKyAxICkgKiBuICsgcyApICsgMiApO1xufTtcblxuZXhwb3J0cy5pbkJvdW5jZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtIGV4cG9ydHMub3V0Qm91bmNlKDEgLSBuKTtcbn07XG5cbmV4cG9ydHMub3V0Qm91bmNlID0gZnVuY3Rpb24obil7XG4gIGlmICggbiA8ICggMSAvIDIuNzUgKSApIHtcbiAgICByZXR1cm4gNy41NjI1ICogbiAqIG47XG4gIH0gZWxzZSBpZiAoIG4gPCAoIDIgLyAyLjc1ICkgKSB7XG4gICAgcmV0dXJuIDcuNTYyNSAqICggbiAtPSAoIDEuNSAvIDIuNzUgKSApICogbiArIDAuNzU7XG4gIH0gZWxzZSBpZiAoIG4gPCAoIDIuNSAvIDIuNzUgKSApIHtcbiAgICByZXR1cm4gNy41NjI1ICogKCBuIC09ICggMi4yNSAvIDIuNzUgKSApICogbiArIDAuOTM3NTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gNy41NjI1ICogKCBuIC09ICggMi42MjUgLyAyLjc1ICkgKSAqIG4gKyAwLjk4NDM3NTtcbiAgfVxufTtcblxuZXhwb3J0cy5pbk91dEJvdW5jZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAobiA8IC41KSByZXR1cm4gZXhwb3J0cy5pbkJvdW5jZShuICogMikgKiAuNTtcbiAgcmV0dXJuIGV4cG9ydHMub3V0Qm91bmNlKG4gKiAyIC0gMSkgKiAuNSArIC41O1xufTtcblxuLy8gYWxpYXNlc1xuXG5leHBvcnRzWydpbi1xdWFkJ10gPSBleHBvcnRzLmluUXVhZDtcbmV4cG9ydHNbJ291dC1xdWFkJ10gPSBleHBvcnRzLm91dFF1YWQ7XG5leHBvcnRzWydpbi1vdXQtcXVhZCddID0gZXhwb3J0cy5pbk91dFF1YWQ7XG5leHBvcnRzWydpbi1jdWJlJ10gPSBleHBvcnRzLmluQ3ViZTtcbmV4cG9ydHNbJ291dC1jdWJlJ10gPSBleHBvcnRzLm91dEN1YmU7XG5leHBvcnRzWydpbi1vdXQtY3ViZSddID0gZXhwb3J0cy5pbk91dEN1YmU7XG5leHBvcnRzWydpbi1xdWFydCddID0gZXhwb3J0cy5pblF1YXJ0O1xuZXhwb3J0c1snb3V0LXF1YXJ0J10gPSBleHBvcnRzLm91dFF1YXJ0O1xuZXhwb3J0c1snaW4tb3V0LXF1YXJ0J10gPSBleHBvcnRzLmluT3V0UXVhcnQ7XG5leHBvcnRzWydpbi1xdWludCddID0gZXhwb3J0cy5pblF1aW50O1xuZXhwb3J0c1snb3V0LXF1aW50J10gPSBleHBvcnRzLm91dFF1aW50O1xuZXhwb3J0c1snaW4tb3V0LXF1aW50J10gPSBleHBvcnRzLmluT3V0UXVpbnQ7XG5leHBvcnRzWydpbi1zaW5lJ10gPSBleHBvcnRzLmluU2luZTtcbmV4cG9ydHNbJ291dC1zaW5lJ10gPSBleHBvcnRzLm91dFNpbmU7XG5leHBvcnRzWydpbi1vdXQtc2luZSddID0gZXhwb3J0cy5pbk91dFNpbmU7XG5leHBvcnRzWydpbi1leHBvJ10gPSBleHBvcnRzLmluRXhwbztcbmV4cG9ydHNbJ291dC1leHBvJ10gPSBleHBvcnRzLm91dEV4cG87XG5leHBvcnRzWydpbi1vdXQtZXhwbyddID0gZXhwb3J0cy5pbk91dEV4cG87XG5leHBvcnRzWydpbi1jaXJjJ10gPSBleHBvcnRzLmluQ2lyYztcbmV4cG9ydHNbJ291dC1jaXJjJ10gPSBleHBvcnRzLm91dENpcmM7XG5leHBvcnRzWydpbi1vdXQtY2lyYyddID0gZXhwb3J0cy5pbk91dENpcmM7XG5leHBvcnRzWydpbi1iYWNrJ10gPSBleHBvcnRzLmluQmFjaztcbmV4cG9ydHNbJ291dC1iYWNrJ10gPSBleHBvcnRzLm91dEJhY2s7XG5leHBvcnRzWydpbi1vdXQtYmFjayddID0gZXhwb3J0cy5pbk91dEJhY2s7XG5leHBvcnRzWydpbi1ib3VuY2UnXSA9IGV4cG9ydHMuaW5Cb3VuY2U7XG5leHBvcnRzWydvdXQtYm91bmNlJ10gPSBleHBvcnRzLm91dEJvdW5jZTtcbmV4cG9ydHNbJ2luLW91dC1ib3VuY2UnXSA9IGV4cG9ydHMuaW5PdXRCb3VuY2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vfi9lYXNlLWNvbXBvbmVudC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCBmYWxsYmFjaztcblxuLyoqXG4gKiBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG52YXIgcHJldiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgdmFyIGN1cnIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgdmFyIG1zID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyciAtIHByZXYpKTtcbiAgdmFyIHJlcSA9IHNldFRpbWVvdXQoZm4sIG1zKTtcbiAgcHJldiA9IGN1cnI7XG4gIHJldHVybiByZXE7XG59XG5cbi8qKlxuICogQ2FuY2VsLlxuICovXG5cbnZhciBjYW5jZWwgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG5leHBvcnRzLmNhbmNlbCA9IGZ1bmN0aW9uKGlkKXtcbiAgY2FuY2VsLmNhbGwod2luZG93LCBpZCk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2Nyb2xsLXRvL34vY29tcG9uZW50LXJhZi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV2ZW50ID0ge1xuICAvKipcbiAgICogb3BlblVybFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgb3BlblVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgIGxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgfVxuXG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIGV2ZW50OiBbe1xuICAgIG5hbWU6ICdvcGVuVVJMJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdldmVudCcsIGV2ZW50LCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9ldmVudC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYWdlSW5mbyA9IHtcblxuICBzZXRUaXRsZTogZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgdGl0bGUgPSB0aXRsZSB8fCAnV2VleCBIVE1MNSdcbiAgICB0cnkge1xuICAgICAgdGl0bGUgPSBkZWNvZGVVUklDb21wb25lbnQodGl0bGUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGVcbiAgfVxufVxuXG5jb25zdCBtZXRhID0ge1xuICBwYWdlSW5mbzogW3tcbiAgICBuYW1lOiAnc2V0VGl0bGUnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ3BhZ2VJbmZvJywgcGFnZUluZm8sIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL3BhZ2VJbmZvLmpzXG4gKiovIiwiLyogZ2xvYmFsIGxpYiwgWE1MSHR0cFJlcXVlc3QgKi9cbi8qIGRlcHM6IGh0dHB1cmwgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmxldCB1dGlsc1xuXG5pbXBvcnQgJ2h0dHB1cmwnXG5cbmxldCBqc29ucENudCA9IDBcbmNvbnN0IEVSUk9SX1NUQVRFID0gLTFcblxuY29uc3QgVFlQRV9KU09OID0gJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCdcbmNvbnN0IFRZUEVfRk9STSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG5cbmNvbnN0IFJFR19GT1JNID0gL14oPzpbXiY9XSs9W14mPV0rKSg/OiZbXiY9XSs9W14mPV0rKSokL1xuXG5mdW5jdGlvbiBfanNvbnAgKGNvbmZpZywgY2FsbGJhY2ssIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgY29uc3QgY2JOYW1lID0gJ2pzb25wXycgKyAoKytqc29ucENudClcbiAgbGV0IHVybFxuXG4gIGlmICghY29uZmlnLnVybCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIGNvbmZpZy51cmwgc2hvdWxkIGJlIHNldCBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSS4nKVxuICB9XG5cbiAgZ2xvYmFsW2NiTmFtZV0gPSAoZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgY2FsbGJhY2socmVzcG9uc2UpXG4gICAgICBkZWxldGUgZ2xvYmFsW2NiXVxuICAgIH1cbiAgfSkoY2JOYW1lKVxuXG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gIHRyeSB7XG4gICAgdXJsID0gbGliLmh0dHB1cmwoY29uZmlnLnVybClcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gaW52YWxpZCBjb25maWcudXJsIGluIF9qc29ucCBmb3IgXFwnZmV0Y2hcXCcgQVBJOiAnXG4gICAgICArIGNvbmZpZy51cmwpXG4gIH1cbiAgdXJsLnBhcmFtcy5jYWxsYmFjayA9IGNiTmFtZVxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIHNjcmlwdC5zcmMgPSB1cmwudG9TdHJpbmcoKVxuICAvLyBzY3JpcHQub25lcnJvciBpcyBub3Qgd29ya2luZyBvbiBJRSBvciBzYWZhcmkuXG4gIC8vIGJ1dCB0aGV5IGFyZSBub3QgY29uc2lkZXJlZCBoZXJlLlxuICBzY3JpcHQub25lcnJvciA9IChmdW5jdGlvbiAoY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gdW5leHBlY3RlZCBlcnJvciBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSScsIGVycilcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIGRlbGV0ZSBnbG9iYWxbY2JdXG4gICAgfVxuICB9KShjYk5hbWUpXG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgbnVsbClcbn1cblxuZnVuY3Rpb24gX3hociAoY29uZmlnLCBjYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIucmVzcG9uc2VUeXBlID0gY29uZmlnLnR5cGVcbiAgeGhyLm9wZW4oY29uZmlnLm1ldGhvZCwgY29uZmlnLnVybCwgdHJ1ZSlcblxuICBjb25zdCBoZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge31cbiAgZm9yIChjb25zdCBrIGluIGhlYWRlcnMpIHtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrLCBoZWFkZXJzW2tdKVxuICB9XG5cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBjYWxsYmFjayh7XG4gICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICBvazogeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCxcbiAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgZGF0YTogeGhyLnJlc3BvbnNlLFxuICAgICAgaGVhZGVyczogeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KCdcXG4nKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChvYmosIGhlYWRlclN0cikge1xuICAgICAgICAgIGNvbnN0IGhlYWRlckFyciA9IGhlYWRlclN0ci5tYXRjaCgvKC4rKTogKC4rKS8pXG4gICAgICAgICAgaWYgKGhlYWRlckFycikge1xuICAgICAgICAgICAgb2JqW2hlYWRlckFyclsxXV0gPSBoZWFkZXJBcnJbMl1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9LCB7fSlcbiAgICB9KVxuICB9XG5cbiAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBwcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgcmVhZHlTdGF0ZTogeGhyLnJlYWR5U3RhdGUsXG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgbGVuZ3RoOiBlLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGUudG90YWwsXG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAob2JqLCBoZWFkZXJTdHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckFyciA9IGhlYWRlclN0ci5tYXRjaCgvKC4rKTogKC4rKS8pXG4gICAgICAgICAgICBpZiAoaGVhZGVyQXJyKSB7XG4gICAgICAgICAgICAgIG9ialtoZWFkZXJBcnJbMV1dID0gaGVhZGVyQXJyWzJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfSwge30pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIHVuZXhwZWN0ZWQgZXJyb3IgaW4gX3hociBmb3IgXFwnZmV0Y2hcXCcgQVBJJywgZXJyKVxuICAgIGNhbGxiYWNrKHtcbiAgICAgIHN0YXR1czogRVJST1JfU1RBVEUsXG4gICAgICBvazogZmFsc2UsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGRhdGE6ICcnLFxuICAgICAgaGVhZGVyczoge31cbiAgICB9KVxuICB9XG5cbiAgeGhyLnNlbmQoY29uZmlnLmJvZHkpXG59XG5cbmNvbnN0IHN0cmVhbSA9IHtcblxuICAvKipcbiAgICogc2VuZEh0dHBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogTm90ZTogVGhpcyBBUEkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBzdHJlYW0uZmV0Y2ggaW5zdGVhZC5cbiAgICogc2VuZCBhIGh0dHAgcmVxdWVzdCB0aHJvdWdoIFhIUi5cbiAgICogQHBhcmFtICB7b2JqfSBwYXJhbXNcbiAgICogIC0gbWV0aG9kOiAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURScgfCAnSEVBRCcgfCAnUEFUQ0gnLFxuICAgKiAgLSB1cmw6IHVybCByZXF1ZXN0ZWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjYWxsYmFja0lkXG4gICAqL1xuICBzZW5kSHR0cDogZnVuY3Rpb24gKHBhcmFtLCBjYWxsYmFja0lkKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcmFtID0gSlNPTi5wYXJzZShwYXJhbSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcmFtICE9PSAnb2JqZWN0JyB8fCAhcGFyYW0udXJsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1toNS1yZW5kZXJdIGludmFsaWQgY29uZmlnIG9yIGludmFsaWQgY29uZmlnLnVybCBmb3Igc2VuZEh0dHAgQVBJJylcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGNvbnN0IG1ldGhvZCA9IHBhcmFtLm1ldGhvZCB8fCAnR0VUJ1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgeGhyLm9wZW4obWV0aG9kLCBwYXJhbS51cmwsIHRydWUpXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgdGhpcy5yZXNwb25zZVRleHQpXG4gICAgfVxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gdW5leHBlY3RlZCBlcnJvciBpbiBzZW5kSHR0cCBBUEknLCBlcnJvcilcbiAgICAgIC8vIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soXG4gICAgICAvLyAgIGNhbGxiYWNrSWQsXG4gICAgICAvLyAgIG5ldyBFcnJvcigndW5leHBlY3RlZCBlcnJvciBpbiBzZW5kSHR0cCBBUEknKVxuICAgICAgLy8gKVxuICAgIH1cbiAgICB4aHIuc2VuZCgpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGZldGNoXG4gICAqIHVzZSBzdHJlYW0uZmV0Y2ggdG8gcmVxdWVzdCBmb3IgYSBqc29uIGZpbGUsIGEgcGxhaW4gdGV4dCBmaWxlIG9yXG4gICAqIGEgYXJyYXlidWZmZXIgZm9yIGEgZmlsZSBzdHJlYW0uIChZb3UgY2FuIHVzZSBCbG9iIGFuZCBGaWxlUmVhZGVyXG4gICAqIEFQSSBpbXBsZW1lbnRlZCBieSBtb3N0IG1vZGVybiBicm93c2VycyB0byByZWFkIGEgYXJyYXlidWZmZXIuKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgY29uZmlnIG9wdGlvbnNcbiAgICogICAtIG1ldGhvZDogJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdERUxFVEUnIHwgJ0hFQUQnIHwgJ1BBVENIJ1xuICAgKiAgIC0gaGVhZGVycyB7b2JqfVxuICAgKiAgIC0gdXJsIHtzdHJpbmd9XG4gICAqICAgLSBtb2RlIHtzdHJpbmd9ICdjb3JzJyB8ICduby1jb3JzJyB8ICdzYW1lLW9yaWdpbicgfCAnbmF2aWdhdGUnXG4gICAqICAgLSBib2R5XG4gICAqICAgLSB0eXBlIHtzdHJpbmd9ICdqc29uJyB8ICdqc29ucCcgfCAndGV4dCdcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjYWxsYmFja0lkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcHJvZ3Jlc3NDYWxsYmFja0lkXG4gICAqL1xuICBmZXRjaDogZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrSWQsIHByb2dyZXNzQ2FsbGJhY2tJZCkge1xuICAgIGNvbnN0IERFRkFVTFRfTUVUSE9EID0gJ0dFVCdcbiAgICBjb25zdCBERUZBVUxUX01PREUgPSAnY29ycydcbiAgICBjb25zdCBERUZBVUxUX1RZUEUgPSAndGV4dCdcblxuICAgIGNvbnN0IG1ldGhvZE9wdGlvbnMgPSBbJ0dFVCcsICdQT1NUJywgJ1BVVCcsICdERUxFVEUnLCAnSEVBRCcsICdQQVRDSCddXG4gICAgY29uc3QgbW9kZU9wdGlvbnMgPSBbJ2NvcnMnLCAnbm8tY29ycycsICdzYW1lLW9yaWdpbicsICduYXZpZ2F0ZSddXG4gICAgY29uc3QgdHlwZU9wdGlvbnMgPSBbJ3RleHQnLCAnanNvbicsICdqc29ucCcsICdhcnJheWJ1ZmZlciddXG5cbiAgICAvLyBjb25zdCBmYWxsYmFjayA9IGZhbHNlICAvLyBmYWxsYmFjayBmcm9tICdmZXRjaCcgQVBJIHRvIFhIUi5cbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuXG4gICAgY29uc3QgY29uZmlnID0gdXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zKVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy5tZXRob2RcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5tZXRob2QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcubWV0aG9kID0gREVGQVVMVF9NRVRIT0RcbiAgICAgIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gb3B0aW9ucy5tZXRob2QgZm9yIFxcJ2ZldGNoXFwnIEFQSSBoYXMgYmVlbiBzZXQgdG8gJ1xuICAgICAgICArICdkZWZhdWx0IHZhbHVlIFxcJycgKyBjb25maWcubWV0aG9kICsgJ1xcJycpXG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGhvZE9wdGlvbnMuaW5kZXhPZigoY29uZmlnLm1ldGhvZCArICcnKVxuICAgICAgICAudG9VcHBlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy5tZXRob2QgXFwnJ1xuICAgICAgICArIGNvbmZpZy5tZXRob2RcbiAgICAgICAgKyAnXFwnIGZvciBcXCdmZXRjaFxcJyBBUEkgc2hvdWxkIGJlIG9uZSBvZiAnXG4gICAgICAgICsgbWV0aG9kT3B0aW9ucyArICcuJylcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zLnVybFxuICAgIGlmICghY29uZmlnLnVybCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIG9wdGlvbnMudXJsIHNob3VsZCBiZSBzZXQgZm9yIFxcJ2ZldGNoXFwnIEFQSS4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMubW9kZVxuICAgIGlmICh0eXBlb2YgY29uZmlnLm1vZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcubW9kZSA9IERFRkFVTFRfTU9ERVxuICAgIH1cbiAgICBlbHNlIGlmIChtb2RlT3B0aW9ucy5pbmRleE9mKChjb25maWcubW9kZSArICcnKS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBvcHRpb25zLm1vZGUgXFwnJ1xuICAgICAgICArIGNvbmZpZy5tb2RlXG4gICAgICAgICsgJ1xcJyBmb3IgXFwnZmV0Y2hcXCcgQVBJIHNob3VsZCBiZSBvbmUgb2YgJ1xuICAgICAgICArIG1vZGVPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMudHlwZVxuICAgIGlmICh0eXBlb2YgY29uZmlnLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcudHlwZSA9IERFRkFVTFRfVFlQRVxuICAgICAgY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSBvcHRpb25zLnR5cGUgZm9yIFxcJ2ZldGNoXFwnIEFQSSBoYXMgYmVlbiBzZXQgdG8gJ1xuICAgICAgICArICdkZWZhdWx0IHZhbHVlIFxcJycgKyBjb25maWcudHlwZSArICdcXCcuJylcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZU9wdGlvbnMuaW5kZXhPZigoY29uZmlnLnR5cGUgKyAnJykudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy50eXBlIFxcJydcbiAgICAgICAgICArIGNvbmZpZy50eXBlXG4gICAgICAgICAgKyAnXFwnIGZvciBcXCdmZXRjaFxcJyBBUEkgc2hvdWxkIGJlIG9uZSBvZiAnXG4gICAgICAgICAgKyB0eXBlT3B0aW9ucyArICcuJylcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zLmhlYWRlcnNcbiAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICAgaWYgKCF1dGlscy5pc1BsYWluT2JqZWN0KGNvbmZpZy5oZWFkZXJzKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIG9wdGlvbnMuaGVhZGVycyBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3QnKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMuYm9keVxuICAgIGNvbnN0IGJvZHkgPSBjb25maWcuYm9keVxuICAgIGlmICghY29uZmlnLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICYmIGJvZHkpIHtcbiAgICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgIC8vIGlzIGEganNvbiBkYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uZmlnLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IFRZUEVfSlNPTlxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRpbHMuZ2V0VHlwZShib2R5KSA9PT0gJ3N0cmluZycgJiYgYm9keS5tYXRjaChSRUdfRk9STSkpIHtcbiAgICAgICAgLy8gaXMgZm9ybS1kYXRhXG4gICAgICAgIGNvbmZpZy5ib2R5ID0gZW5jb2RlVVJJKGJvZHkpXG4gICAgICAgIGNvbmZpZy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IFRZUEVfRk9STVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMudGltZW91dFxuICAgIGNvbmZpZy50aW1lb3V0ID0gcGFyc2VJbnQoY29uZmlnLnRpbWVvdXQsIDEwKSB8fCAyNTAwXG5cbiAgICBjb25zdCBfY2FsbEFyZ3MgPSBbY29uZmlnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHJlcylcbiAgICB9XVxuICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrSWQpIHtcbiAgICAgIF9jYWxsQXJncy5wdXNoKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgLy8gU2V0ICdrZWVwQWxpdmUnIHRvIHRydWUgZm9yIHNlbmRpbmcgY29udGludW91cyBjYWxsYmFja3NcbiAgICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhwcm9ncmVzc0NhbGxiYWNrSWQsIHJlcywgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy50eXBlID09PSAnanNvbnAnKSB7XG4gICAgICBfanNvbnAuYXBwbHkodGhpcywgX2NhbGxBcmdzKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF94aHIuYXBwbHkodGhpcywgX2NhbGxBcmdzKVxuICAgIH1cbiAgfVxuXG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIHN0cmVhbTogW3tcbiAgICBuYW1lOiAnc2VuZEh0dHAnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdmZXRjaCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nLCAnZnVuY3Rpb24nXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgdXRpbHMgPSBXZWV4LnV0aWxzXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnc3RyZWFtJywgc3RyZWFtLCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9zdHJlYW0uanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IG1vZGFsIGZyb20gJ21vZGFscydcblxuY29uc3QgbXNnID0ge1xuXG4gIC8vIGR1cmF0aW9uOiBkZWZhdWx0IGlzIDAuOCBzZWNvbmRzLlxuICB0b2FzdDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIG1vZGFsLnRvYXN0KGNvbmZpZy5tZXNzYWdlLCBjb25maWcuZHVyYXRpb24pXG4gIH0sXG5cbiAgLy8gY29uZmlnOlxuICAvLyAgLSBtZXNzYWdlOiBzdHJpbmdcbiAgLy8gIC0gb2tUaXRsZTogdGl0bGUgb2Ygb2sgYnV0dG9uXG4gIC8vICAtIGNhbGxiYWNrXG4gIGFsZXJ0OiBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFja0lkKSB7XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQpXG4gICAgfVxuICAgIG1vZGFsLmFsZXJ0KGNvbmZpZylcbiAgfSxcblxuICAvLyBjb25maWc6XG4gIC8vICAtIG1lc3NhZ2U6IHN0cmluZ1xuICAvLyAgLSBva1RpdGxlOiB0aXRsZSBvZiBvayBidXR0b25cbiAgLy8gIC0gY2FuY2VsVGl0bGU6IHRpdGxlIG9mIGNhbmNlbCBidXR0b25cbiAgLy8gIC0gY2FsbGJhY2tcbiAgY29uZmlybTogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgY29uZmlnLmNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB2YWwpXG4gICAgfVxuICAgIG1vZGFsLmNvbmZpcm0oY29uZmlnKVxuICB9LFxuXG4gIC8vIGNvbmZpZzpcbiAgLy8gIC0gbWVzc2FnZTogc3RyaW5nXG4gIC8vICAtIG9rVGl0bGU6IHRpdGxlIG9mIG9rIGJ1dHRvblxuICAvLyAgLSBjYW5jZWxUaXRsZTogdGl0bGUgb2YgY2FuY2VsIGJ1dHRvblxuICAvLyAgLSBjYWxsYmFja1xuICBwcm9tcHQ6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrSWQpIHtcbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGNvbmZpZy5jYWxsYmFjayA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgdmFsKVxuICAgIH1cbiAgICBtb2RhbC5wcm9tcHQoY29uZmlnKVxuICB9XG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIG1vZGFsOiBbe1xuICAgIG5hbWU6ICd0b2FzdCcsXG4gICAgYXJnczogWydvYmplY3QnXVxuICB9LCB7XG4gICAgbmFtZTogJ2FsZXJ0JyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnY29uZmlybScsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ3Byb21wdCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnbW9kYWwnLCBtc2csIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL21vZGFsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBBbGVydCA9IHJlcXVpcmUoJy4vYWxlcnQnKVxudmFyIENvbmZpcm0gPSByZXF1aXJlKCcuL2NvbmZpcm0nKVxudmFyIFByb21wdCA9IHJlcXVpcmUoJy4vcHJvbXB0JylcbnZhciB0b2FzdCA9IHJlcXVpcmUoJy4vdG9hc3QnKVxuXG52YXIgbW9kYWwgPSB7XG5cbiAgdG9hc3Q6IGZ1bmN0aW9uIChtc2csIGR1cmF0aW9uKSB7XG4gICAgdG9hc3QucHVzaChtc2csIGR1cmF0aW9uKVxuICB9LFxuXG4gIGFsZXJ0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbmV3IEFsZXJ0KGNvbmZpZykuc2hvdygpXG4gIH0sXG5cbiAgcHJvbXB0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbmV3IFByb21wdChjb25maWcpLnNob3coKVxuICB9LFxuXG4gIGNvbmZpcm06IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBuZXcgQ29uZmlybShjb25maWcpLnNob3coKVxuICB9XG5cbn1cblxuIXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSlcbndpbmRvdy5saWIubW9kYWwgPSBtb2RhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGFsXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4vbW9kYWwnKVxucmVxdWlyZSgnLi4vc3R5bGVzL2FsZXJ0LmNzcycpXG5cbnZhciBDT05URU5UX0NMQVNTID0gJ2NvbnRlbnQnXG52YXIgTVNHX0NMQVNTID0gJ2NvbnRlbnQtbXNnJ1xudmFyIEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG52YXIgQlVUVE9OX0NMQVNTID0gJ2J0bidcblxuZnVuY3Rpb24gQWxlcnQoY29uZmlnKSB7XG4gIHRoaXMubXNnID0gY29uZmlnLm1lc3NhZ2UgfHwgJydcbiAgdGhpcy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFja1xuICB0aGlzLm9rVGl0bGUgPSBjb25maWcub2tUaXRsZSB8fCAnT0snXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtYWxlcnQnKVxufVxuXG5BbGVydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGFsLnByb3RvdHlwZSlcblxuQWxlcnQucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChDT05URU5UX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGVudClcblxuICB2YXIgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICB2YXIgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQlVUVE9OX0NMQVNTLCAnYWxlcnQtb2snKVxuICBidXR0b24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5va1RpdGxlKSlcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnV0dG9uKVxufVxuXG5BbGVydC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgTW9kYWwucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzKVxuICB2YXIgYnV0dG9uID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTKVxuICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soKVxuICB9LmJpbmQodGhpcykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWxlcnRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zcmMvYWxlcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuLi9zdHlsZXMvbW9kYWwuY3NzJylcblxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBpbnN0YW5jZSBvZiBtb2RhbC5cbnZhciBNT0RBTF9XUkFQX0NMQVNTID0gJ2FtZmUtbW9kYWwtd3JhcCdcbnZhciBNT0RBTF9OT0RFX0NMQVNTID0gJ2FtZmUtbW9kYWwtbm9kZSdcblxuZnVuY3Rpb24gTW9kYWwoKSB7XG4gIHRoaXMud3JhcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTU9EQUxfV1JBUF9DTEFTUylcbiAgdGhpcy5ub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihNT0RBTF9OT0RFX0NMQVNTKVxuICBpZiAoIXRoaXMud3JhcCkge1xuICAgIHRoaXMuY3JlYXRlV3JhcCgpXG4gIH1cbiAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICB0aGlzLmNyZWF0ZU5vZGUoKVxuICB9XG4gIHRoaXMuY2xlYXJOb2RlKClcbiAgdGhpcy5jcmVhdGVOb2RlQ29udGVudCgpXG4gIHRoaXMuYmluZEV2ZW50cygpXG59XG5cbk1vZGFsLnByb3RvdHlwZSA9IHtcblxuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMud3JhcClcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubm9kZSlcbiAgICB0aGlzLndyYXAgPSBudWxsXG4gICAgdGhpcy5ub2RlID0gbnVsbFxuICB9LFxuXG4gIGNyZWF0ZVdyYXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMud3JhcC5jbGFzc05hbWUgPSBNT0RBTF9XUkFQX0NMQVNTXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLndyYXApXG4gIH0sXG5cbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoTU9EQUxfTk9ERV9DTEFTUywgJ2hpZGUnKVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICB9LFxuXG4gIGNsZWFyTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJ1xuICB9LFxuXG4gIGNyZWF0ZU5vZGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBkbyBub3RoaW5nLlxuICAgIC8vIGNoaWxkIGNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICB9LFxuXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGFsXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3JjL21vZGFsLmpzXG4gKiogbW9kdWxlIGlkID0gMjA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9kYWwuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2RhbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21vZGFsLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3N0eWxlcy9tb2RhbC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1tb2RhbC13cmFwIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgb3BhY2l0eTogMC41O1xcbn1cXG5cXG4uYW1mZS1tb2RhbC1ub2RlIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHdpZHRoOiA2LjY2NjY2N3JlbTtcXG4gIG1pbi1oZWlnaHQ6IDIuNjY2NjY3cmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMC4wNjY2NjdyZW07XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbn1cXG4uYW1mZS1tb2RhbC1ub2RlLmhpZGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmFtZmUtbW9kYWwtbm9kZSAuY29udGVudCB7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtaW4taGVpZ2h0OiAxLjg2NjY2N3JlbTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBmb250LXNpemU6IDAuMzJyZW07XFxuICBsaW5lLWhlaWdodDogMC40MjY2NjdyZW07XFxuICBwYWRkaW5nOiAwLjIxMzMzM3JlbTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbn1cXG4uYW1mZS1tb2RhbC1ub2RlIC5idG4tZ3JvdXAge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDAuOHJlbTtcXG4gIGZvbnQtc2l6ZTogMC4zNzMzMzNyZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG4uYW1mZS1tb2RhbC1ub2RlIC5idG4tZ3JvdXAgLmJ0biB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgaGVpZ2h0OiAwLjhyZW07XFxuICBsaW5lLWhlaWdodDogMC44cmVtO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L21vZGFscy9zdHlsZXMvbW9kYWwuY3NzXG4gKiogbW9kdWxlIGlkID0gMjA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYWxlcnQuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hbGVydC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2FsZXJ0LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1hbGVydCAuYW1mZS1hbGVydC1vayB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgTW9kYWwgPSByZXF1aXJlKCcuL21vZGFsJylcbnJlcXVpcmUoJy4uL3N0eWxlcy9jb25maXJtLmNzcycpXG5cbnZhciBDT05URU5UX0NMQVNTID0gJ2NvbnRlbnQnXG52YXIgTVNHX0NMQVNTID0gJ2NvbnRlbnQtbXNnJ1xudmFyIEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG52YXIgQlVUVE9OX0NMQVNTID0gJ2J0bidcblxuZnVuY3Rpb24gQ29uZmlybShjb25maWcpIHtcbiAgdGhpcy5tc2cgPSBjb25maWcubWVzc2FnZSB8fCAnJ1xuICB0aGlzLmNhbGxiYWNrID0gY29uZmlnLmNhbGxiYWNrXG4gIHRoaXMub2tUaXRsZSA9IGNvbmZpZy5va1RpdGxlIHx8ICdPSydcbiAgdGhpcy5jYW5jZWxUaXRsZSA9IGNvbmZpZy5jYW5jZWxUaXRsZSB8fCAnQ2FuY2VsJ1xuICBNb2RhbC5jYWxsKHRoaXMpXG4gIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdhbWZlLWNvbmZpcm0nKVxufVxuXG5Db25maXJtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kYWwucHJvdG90eXBlKVxuXG5Db25maXJtLnByb3RvdHlwZS5jcmVhdGVOb2RlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBjb250ZW50LmNsYXNzTGlzdC5hZGQoQ09OVEVOVF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpXG5cbiAgdmFyIG1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG1zZy5jbGFzc0xpc3QuYWRkKE1TR19DTEFTUylcbiAgbXNnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubXNnKSlcbiAgY29udGVudC5hcHBlbmRDaGlsZChtc2cpXG5cbiAgdmFyIGJ1dHRvbkdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnV0dG9uR3JvdXAuY2xhc3NMaXN0LmFkZChCVVRUT05fR1JPVVBfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChidXR0b25Hcm91cClcbiAgdmFyIGJ0bk9rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnRuT2suYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5va1RpdGxlKSlcbiAgYnRuT2suY2xhc3NMaXN0LmFkZCgnYnRuLW9rJywgQlVUVE9OX0NMQVNTKVxuICB2YXIgYnRuQ2FuY2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnRuQ2FuY2VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY2FuY2VsVGl0bGUpKVxuICBidG5DYW5jZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWNhbmNlbCcsIEJVVFRPTl9DTEFTUylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuT2spXG4gIGJ1dHRvbkdyb3VwLmFwcGVuZENoaWxkKGJ0bkNhbmNlbClcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxufVxuXG5Db25maXJtLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBNb2RhbC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMpXG4gIHZhciBidG5PayA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCcuJyArIEJVVFRPTl9DTEFTUyArICcuYnRuLW9rJylcbiAgdmFyIGJ0bkNhbmNlbCA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCcuJyArIEJVVFRPTl9DTEFTUyArICcuYnRuLWNhbmNlbCcpXG4gIGJ0bk9rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrKHRoaXMub2tUaXRsZSlcbiAgfS5iaW5kKHRoaXMpKVxuICBidG5DYW5jZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2sodGhpcy5jYW5jZWxUaXRsZSlcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpcm1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zcmMvY29uZmlybS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvbmZpcm0uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jb25maXJtLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29uZmlybS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zdHlsZXMvY29uZmlybS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1jb25maXJtIC5idG4tZ3JvdXAgLmJ0biB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA1MCU7XFxufVxcbi5hbWZlLWNvbmZpcm0gLmJ0bi1ncm91cCAuYnRuLmJ0bi1vayB7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzXG4gKiogbW9kdWxlIGlkID0gMjExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIE1vZGFsID0gcmVxdWlyZSgnLi9tb2RhbCcpXG5yZXF1aXJlKCcuLi9zdHlsZXMvcHJvbXB0LmNzcycpXG5cbnZhciBDT05URU5UX0NMQVNTID0gJ2NvbnRlbnQnXG52YXIgTVNHX0NMQVNTID0gJ2NvbnRlbnQtbXNnJ1xudmFyIEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG52YXIgQlVUVE9OX0NMQVNTID0gJ2J0bidcbnZhciBJTlBVVF9XUkFQX0NMQVNTID0gJ2lucHV0LXdyYXAnXG52YXIgSU5QVVRfQ0xBU1MgPSAnaW5wdXQnXG5cbmZ1bmN0aW9uIFByb21wdChjb25maWcpIHtcbiAgdGhpcy5tc2cgPSBjb25maWcubWVzc2FnZSB8fCAnJ1xuICB0aGlzLmRlZmF1bHRNc2cgPSBjb25maWcuZGVmYXVsdCB8fCAnJ1xuICB0aGlzLmNhbGxiYWNrID0gY29uZmlnLmNhbGxiYWNrXG4gIHRoaXMub2tUaXRsZSA9IGNvbmZpZy5va1RpdGxlIHx8ICdPSydcbiAgdGhpcy5jYW5jZWxUaXRsZSA9IGNvbmZpZy5jYW5jZWxUaXRsZSB8fCAnQ2FuY2VsJ1xuICBNb2RhbC5jYWxsKHRoaXMpXG4gIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdhbWZlLXByb21wdCcpXG59XG5cblByb21wdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGFsLnByb3RvdHlwZSlcblxuUHJvbXB0LnByb3RvdHlwZS5jcmVhdGVOb2RlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChDT05URU5UX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGVudClcblxuICB2YXIgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICB2YXIgaW5wdXRXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgaW5wdXRXcmFwLmNsYXNzTGlzdC5hZGQoSU5QVVRfV1JBUF9DTEFTUylcbiAgY29udGVudC5hcHBlbmRDaGlsZChpbnB1dFdyYXApXG4gIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgaW5wdXQuY2xhc3NMaXN0LmFkZChJTlBVVF9DTEFTUylcbiAgaW5wdXQudHlwZSA9ICd0ZXh0J1xuICBpbnB1dC5hdXRvZm9jdXMgPSB0cnVlXG4gIGlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5kZWZhdWx0TXNnXG4gIGlucHV0V3JhcC5hcHBlbmRDaGlsZChpbnB1dClcblxuICB2YXIgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdmFyIGJ0bk9rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnRuT2suYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5va1RpdGxlKSlcbiAgYnRuT2suY2xhc3NMaXN0LmFkZCgnYnRuLW9rJywgQlVUVE9OX0NMQVNTKVxuICB2YXIgYnRuQ2FuY2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnRuQ2FuY2VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY2FuY2VsVGl0bGUpKVxuICBidG5DYW5jZWwuY2xhc3NMaXN0LmFkZCgnYnRuLWNhbmNlbCcsIEJVVFRPTl9DTEFTUylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuT2spXG4gIGJ1dHRvbkdyb3VwLmFwcGVuZENoaWxkKGJ0bkNhbmNlbClcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxufVxuXG5Qcm9tcHQucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIE1vZGFsLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcylcbiAgdmFyIGJ0bk9rID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tb2snKVxuICB2YXIgYnRuQ2FuY2VsID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tY2FuY2VsJylcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIGJ0bk9rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soe1xuICAgICAgcmVzdWx0OiB0aGF0Lm9rVGl0bGUsXG4gICAgICBkYXRhOiB2YWxcbiAgICB9KVxuICB9LmJpbmQodGhpcykpXG4gIGJ0bkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZVxuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrKHtcbiAgICAgIHJlc3VsdDogdGhhdC5jYW5jZWxUaXRsZSxcbiAgICAgIGRhdGE6IHZhbFxuICAgIH0pXG4gIH0uYmluZCh0aGlzKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9tcHRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zcmMvcHJvbXB0LmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvbXB0LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvbXB0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvbXB0LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3N0eWxlcy9wcm9tcHQuY3NzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFtZmUtcHJvbXB0IC5pbnB1dC13cmFwIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbi10b3A6IDAuMTMzMzMzcmVtO1xcbiAgLy8gcGFkZGluZzogMC4yNHJlbSAwLjIxMzMzM3JlbSAwLjIxMzMzM3JlbTtcXG4gIGhlaWdodDogMC45NnJlbTtcXG59XFxuLmFtZmUtcHJvbXB0IC5pbnB1dC13cmFwIC5pbnB1dCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDAuNTZyZW07XFxuICBsaW5lLWhlaWdodDogMC41NnJlbTtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxufVxcbi5hbWZlLXByb21wdCAuYnRuLWdyb3VwIC5idG4ge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogNTAlO1xcbn1cXG4uYW1mZS1wcm9tcHQgLmJ0bi1ncm91cCAuYnRuLmJ0bi1vayB7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZGRkO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuLi9zdHlsZXMvdG9hc3QuY3NzJylcblxudmFyIHF1ZXVlID0gW11cbnZhciB0aW1lclxudmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlXG52YXIgdG9hc3RXaW5cbnZhciBUT0FTVF9XSU5fQ0xBU1NfTkFNRSA9ICdhbWZlLXRvYXN0J1xuXG52YXIgREVGQVVMVF9EVVJBVElPTiA9IDAuOFxuXG5mdW5jdGlvbiBzaG93VG9hc3RXaW5kb3cobXNnLCBjYWxsYmFjaykge1xuICB2YXIgaGFuZGxlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2FzdFdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gIH1cbiAgaWYgKCF0b2FzdFdpbikge1xuICAgIHRvYXN0V2luID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0b2FzdFdpbi5jbGFzc0xpc3QuYWRkKFRPQVNUX1dJTl9DTEFTU19OQU1FLCAnaGlkZScpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b2FzdFdpbilcbiAgfVxuICB0b2FzdFdpbi5pbm5lckhUTUwgPSBtc2dcbiAgdG9hc3RXaW4uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZVRyYW5zaXRpb25FbmQpXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRvYXN0V2luLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxuICB9LCAwKVxufVxuXG5mdW5jdGlvbiBoaWRlVG9hc3RXaW5kb3coY2FsbGJhY2spIHtcbiAgdmFyIGhhbmRsZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9hc3RXaW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZVRyYW5zaXRpb25FbmQpXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICB9XG4gIGlmICghdG9hc3RXaW4pIHtcbiAgICByZXR1cm5cbiAgfVxuICB0b2FzdFdpbi5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgdG9hc3RXaW4uY2xhc3NMaXN0LmFkZCgnaGlkZScpXG59XG5cbnZhciB0b2FzdCA9IHtcblxuICBwdXNoOiBmdW5jdGlvbiAobXNnLCBkdXJhdGlvbikge1xuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgbXNnOiBtc2csXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgREVGQVVMVF9EVVJBVElPTlxuICAgIH0pXG4gICAgdGhpcy5zaG93KClcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAvLyBBbGwgbWVzc2FnZXMgaGFkIGJlZW4gdG9hc3RlZCBhbHJlYWR5LCBzbyByZW1vdmUgdGhlIHRvYXN0IHdpbmRvdyxcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgdG9hc3RXaW4gJiYgdG9hc3RXaW4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2FzdFdpbilcbiAgICAgIHRvYXN0V2luID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gdGhlIHByZXZpb3VzIHRvYXN0IGlzIG5vdCBlbmRlZCB5ZXQuXG4gICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlzUHJvY2Vzc2luZyA9IHRydWVcblxuICAgIHZhciB0b2FzdEluZm8gPSBxdWV1ZS5zaGlmdCgpXG4gICAgc2hvd1RvYXN0V2luZG93KHRvYXN0SW5mby5tc2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVyID0gbnVsbFxuICAgICAgICBoaWRlVG9hc3RXaW5kb3coZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgICAgICAgdGhhdC5zaG93KClcbiAgICAgICAgfSlcbiAgICAgIH0sIHRvYXN0SW5mby5kdXJhdGlvbiAqIDEwMDApXG4gICAgfSlcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwdXNoOiB0b2FzdC5wdXNoLmJpbmQodG9hc3QpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3JjL3RvYXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdG9hc3QuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi90b2FzdC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3RvYXN0LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS10b2FzdCB7XFxuICBmb250LXNpemU6IDAuMzJyZW07XFxuICBsaW5lLWhlaWdodDogMC40MjY2NjdyZW07XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgbWF4LXdpZHRoOiA4MCU7XFxuICBib3R0b206IDIuNjY2NjY3cmVtO1xcbiAgbGVmdDogNTAlO1xcbiAgcGFkZGluZzogMC4yMTMzMzNyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgY29sb3I6ICNmZmY7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvcGFjaXR5OiAwLjY7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMDY2NjY3cmVtO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcblxcbi5hbWZlLXRvYXN0LmhpZGUge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyB0cmFuc2l0aW9uT25jZSB9IGZyb20gJy4vbGliJ1xuXG5jb25zdCBfZGF0YSA9IHt9XG5cbmNvbnN0IGFuaW1hdGlvbiA9IHtcblxuICAvKipcbiAgICogdHJhbnNpdGlvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJlZiAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtvYmp9IGNvbmZpZyAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWQgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKHJlZiwgY29uZmlnLCBjYWxsYmFja0lkKSB7XG4gICAgbGV0IHJlZkRhdGEgPSBfZGF0YVtyZWZdXG4gICAgY29uc3Qgc3R5bGVzS2V5ID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnLnN0eWxlcylcbiAgICBjb25zdCB3ZWV4SW5zdGFuY2UgPSB0aGlzXG4gICAgLy8gSWYgdGhlIHNhbWUgY29tcG9uZW50IHBlcmZvcm0gYSBhbmltYXRpb24gd2l0aCBleGFjdGx5IHRoZSBzYW1lXG4gICAgLy8gc3R5bGVzIGluIGEgc2VxdWVuY2Ugd2l0aCBzbyBzaG9ydCBpbnRlcnZhbCB0aGF0IHRoZSBwcmV2IGFuaW1hdGlvblxuICAgIC8vIGlzIHN0aWxsIGluIHBsYXlpbmcsIHRoZW4gdGhlIG5leHQgYW5pbWF0aW9uIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIGlmIChyZWZEYXRhICYmIHJlZkRhdGFbc3R5bGVzS2V5XSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcmVmRGF0YSkge1xuICAgICAgcmVmRGF0YSA9IF9kYXRhW3JlZl0gPSB7fVxuICAgIH1cbiAgICByZWZEYXRhW3N0eWxlc0tleV0gPSB0cnVlXG5cbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRDb21wb25lbnQocmVmKVxuICAgIHJldHVybiB0cmFuc2l0aW9uT25jZShjb21wb25lbnQsIGNvbmZpZywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzdHlsZXNLZXkgaW4gcmVmRGF0YSBzbyB0aGF0IHRoZSBzYW1lIGFuaW1hdGlvblxuICAgICAgLy8gY2FuIGJlIHBsYXllZCBhZ2FpbiBhZnRlciBjdXJyZW50IGFuaW1hdGlvbiBpcyBhbHJlYWR5IGZpbmlzaGVkLlxuICAgICAgZGVsZXRlIHJlZkRhdGFbc3R5bGVzS2V5XVxuICAgICAgd2VleEluc3RhbmNlLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIGFuaW1hdGlvbjogW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4gICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ2FuaW1hdGlvbicsIGFuaW1hdGlvbiwgbWV0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvYW5pbWF0aW9uL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBjb25maWc6XG4gICAqICAgLSBzdHlsZXNcbiAgICogICAtIGR1cmF0aW9uIFtOdW1iZXJdIG1pbGxpc2Vjb25kcyhtcylcbiAgICogICAtIHRpbWluZ0Z1bmN0aW9uIFtzdHJpbmddXG4gICAqICAgLSBkZWFseSBbTnVtYmVyXSBtaWxsaXNlY29uZHMobXMpXG4gICAqL1xuICB0cmFuc2l0aW9uT25jZTogZnVuY3Rpb24gKGNvbXAsIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdHlsZXMgPSBjb25maWcuc3R5bGVzIHx8IHt9XG4gICAgY29uc3QgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb24gfHwgMTAwMCAvLyBtc1xuICAgIGNvbnN0IHRpbWluZ0Z1bmN0aW9uID0gY29uZmlnLnRpbWluZ0Z1bmN0aW9uIHx8ICdlYXNlJ1xuICAgIGNvbnN0IGRlbGF5ID0gY29uZmlnLmRlbGF5IHx8IDAgIC8vIG1zXG4gICAgY29uc3QgdHJhbnNpdGlvblZhbHVlID0gJ2FsbCAnICsgZHVyYXRpb24gKyAnbXMgJ1xuICAgICAgICArIHRpbWluZ0Z1bmN0aW9uICsgJyAnICsgZGVsYXkgKyAnbXMnXG4gICAgY29uc3QgZG9tID0gY29tcC5ub2RlXG4gICAgY29uc3QgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0cmFuc2l0aW9uRW5kSGFuZGxlcilcbiAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gICAgICBkb20uc3R5bGUudHJhbnNpdGlvbiA9ICcnXG4gICAgICBkb20uc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICAgIGRvbS5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvblZhbHVlXG4gICAgZG9tLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uVmFsdWVcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRyYW5zaXRpb25FbmRIYW5kbGVyKVxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gICAgY29tcC51cGRhdGVTdHlsZShzdHlsZXMpXG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvYW5pbWF0aW9uL2xpYi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB3ZWJ2aWV3ID0ge1xuXG4gIC8vIHJlZjogcmVmIG9mIHRoZSB3ZWIgY29tcG9uZW50LlxuICBnb0JhY2s6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICBjb25zdCB3ZWJDb21wID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKCkuZ2V0Q29tcG9uZW50KHJlZilcbiAgICBpZiAoIXdlYkNvbXAuZ29CYWNrKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogdGhlIHNwZWNpZmllZCBjb21wb25lbnQgaGFzIG5vIG1ldGhvZCBvZidcbiAgICAgICAgICArICcgZ29CYWNrLiBQbGVhc2UgbWFrZSBzdXJlIGl0IGlzIGEgd2VidmlldyBjb21wb25lbnQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB3ZWJDb21wLmdvQmFjaygpXG4gIH0sXG5cbiAgLy8gcmVmOiByZWYgb2YgdGhlIHdlYiBjb21wb25lbnQuXG4gIGdvRm9yd2FyZDogZnVuY3Rpb24gKHJlZikge1xuICAgIGNvbnN0IHdlYkNvbXAgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRDb21wb25lbnQocmVmKVxuICAgIGlmICghd2ViQ29tcC5nb0ZvcndhcmQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBoYXMgbm8gbWV0aG9kIG9mJ1xuICAgICAgICAgICsgJyBnb0ZvcndhcmQuIFBsZWFzZSBtYWtlIHN1cmUgaXQgaXMgYSB3ZWJ2aWV3IGNvbXBvbmVudC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdlYkNvbXAuZ29Gb3J3YXJkKClcbiAgfSxcblxuICAvLyByZWY6IHJlZiBvZiB0aGUgd2ViIGNvbXBvbmVudC5cbiAgcmVsb2FkOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgY29uc3Qgd2ViQ29tcCA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLmdldENvbXBvbmVudChyZWYpXG4gICAgaWYgKCF3ZWJDb21wLnJlbG9hZCkge1xuICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IHRoZSBzcGVjaWZpZWQgY29tcG9uZW50IGhhcyBubyBtZXRob2Qgb2YnXG4gICAgICAgICAgKyAnIHJlbG9hZC4gUGxlYXNlIG1ha2Ugc3VyZSBpdCBpcyBhIHdlYnZpZXcgY29tcG9uZW50LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgd2ViQ29tcC5yZWxvYWQoKVxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgd2VidmlldzogW3tcbiAgICBuYW1lOiAnZ29CYWNrJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH0sIHtcbiAgICBuYW1lOiAnZ29Gb3J3YXJkJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH0sIHtcbiAgICBuYW1lOiAncmVsb2FkJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCd3ZWJ2aWV3Jywgd2VidmlldywgbWV0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvd2Vidmlldy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuYXZpZ2F0b3IgPSB7XG5cbiAgLy8gY29uZmlnXG4gIC8vICAtIHVybDogdGhlIHVybCB0byBwdXNoXG4gIC8vICAtIGFuaW1hdGVkOiB0aGlzIGNvbmZpZ3VyYXRpb24gaXRlbSBpcyBuYXRpdmUgb25seVxuICAvLyAgY2FsbGJhY2sgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgcHVzaDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY29uZmlnLnVybFxuICAgIHRoaXMuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxuICB9LFxuXG4gIC8vIGNvbmZpZ1xuICAvLyAgLSBhbmltYXRlZDogdGhpcyBjb25maWd1cmF0aW9uIGl0ZW0gaXMgbmF0aXZlIG9ubHlcbiAgLy8gIGNhbGxiYWNrIGlzIG5vdGUgY3VycmVudGx5IHN1cHBvcnRlZFxuICBwb3A6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrSWQpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgICB0aGlzLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZClcbiAgfVxuXG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIG5hdmlnYXRvcjogW3tcbiAgICBuYW1lOiAncHVzaCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ3BvcCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnbmF2aWdhdG9yJywgbmF2aWdhdG9yLCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9uYXZpZ2F0b3IuanNcbiAqKi8iLCIvKiBnbG9iYWwgbG9jYWxTdG9yYWdlICovXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgc3VwcG9ydExvY2FsU3RvcmFnZSA9IHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnXG5jb25zdCBTVUNDRVNTID0gJ3N1Y2Nlc3MnXG5jb25zdCBGQUlMRUQgPSAnZmFpbGVkJ1xuY29uc3QgSU5WQUxJRF9QQVJBTSA9ICdpbnZhbGlkX3BhcmFtJ1xuY29uc3QgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCdcblxuY29uc3Qgc3RvcmFnZSA9IHtcblxuICAvKipcbiAgICogV2hlbiBwYXNzZWQgYSBrZXkgbmFtZSBhbmQgdmFsdWUsIHdpbGwgYWRkIHRoYXQga2V5IHRvIHRoZSBzdG9yYWdlLFxuICAgKiBvciB1cGRhdGUgdGhhdCBrZXkncyB2YWx1ZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tJZFxuICAgKi9cbiAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNhbGxiYWNrSWQpIHtcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3lvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydCBsb2NhbFN0b3JhZ2UgeWV0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBpZiAoIWtleSB8fCAhdmFsdWUpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6ICdmYWlsZWQnLFxuICAgICAgICBkYXRhOiBJTlZBTElEX1BBUkFNXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogU1VDQ0VTUyxcbiAgICAgICAgZGF0YTogVU5ERUZJTkVEXG4gICAgICB9KVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gYWNjZXB0IGFueSBleGNlcHRpb24gdGhyb3duIGR1cmluZyBhIHN0b3JhZ2UgYXR0ZW1wdCBhcyBhIHF1b3RhIGVycm9yXG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiBGQUlMRUQsXG4gICAgICAgIGRhdGE6IFVOREVGSU5FRFxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gcGFzc2VkIGEga2V5IG5hbWUsIHdpbGwgcmV0dXJuIHRoYXQga2V5J3MgdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tJZFxuICAgKi9cbiAgZ2V0SXRlbTogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2tJZCkge1xuICAgIGlmICghc3VwcG9ydExvY2FsU3RvcmFnZSkge1xuICAgICAgY29uc29sZS5lcnJvcigneW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0IGxvY2FsU3RvcmFnZSB5ZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGlmICgha2V5KSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiBGQUlMRUQsXG4gICAgICAgIGRhdGE6IElOVkFMSURfUEFSQU1cbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgdmFsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgcmVzdWx0OiB2YWwgPyBTVUNDRVNTIDogRkFJTEVELFxuICAgICAgZGF0YTogdmFsIHx8IFVOREVGSU5FRFxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqV2hlbiBwYXNzZWQgYSBrZXkgbmFtZSwgd2lsbCByZW1vdmUgdGhhdCBrZXkgZnJvbSB0aGUgc3RvcmFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja0lkKSB7XG4gICAgaWYgKCFzdXBwb3J0TG9jYWxTdG9yYWdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd5b3VyIGJyb3dzZXIgaXMgbm90IHN1cHBvcnQgbG9jYWxTdG9yYWdlIHlldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6IEZBSUxFRCxcbiAgICAgICAgZGF0YTogSU5WQUxJRF9QQVJBTVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICByZXN1bHQ6IFNVQ0NFU1MsXG4gICAgICBkYXRhOiBVTkRFRklORURcbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgZGF0YSBpdGVtcyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBsZW5ndGg6IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgaWYgKCFzdXBwb3J0TG9jYWxTdG9yYWdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd5b3VyIGJyb3dzZXIgaXMgbm90IHN1cHBvcnQgbG9jYWxTdG9yYWdlIHlldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgY29uc3QgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aFxuICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgcmVzdWx0OiBTVUNDRVNTLFxuICAgICAgZGF0YTogbGVuXG4gICAgfSlcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBrZXlzIHN0b3JlZCBpbiBTdG9yYWdlIG9iamVjdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tJZFxuICAgKi9cbiAgZ2V0QWxsS2V5czogZnVuY3Rpb24gKGNhbGxiYWNrSWQpIHtcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3lvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydCBsb2NhbFN0b3JhZ2UgeWV0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBjb25zdCBfYXJyID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgX2Fyci5wdXNoKGxvY2FsU3RvcmFnZS5rZXkoaSkpXG4gICAgfVxuICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgcmVzdWx0OiBTVUNDRVNTLFxuICAgICAgZGF0YTogX2FyclxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgc3RvcmFnZTogW3tcbiAgICBuYW1lOiAnc2V0SXRlbScsXG4gICAgYXJnczogWydzdHJpbmcnLCAnc3RyaW5nJywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdnZXRJdGVtJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAncmVtb3ZlSXRlbScsXG4gICAgYXJnczogWydzdHJpbmcnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgYXJnczogWydmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnZ2V0QWxsS2V5cycsXG4gICAgYXJnczogWydmdW5jdGlvbiddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdzdG9yYWdlJywgc3RvcmFnZSwgbWV0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvc3RvcmFnZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vKipcblxuQVVDVElPTjpcbnRhc2tRdWV1ZVxuQ2xpcGJvYXJkLnNldFN0cmluZygpICBOT1cgbm90IHdvcmtzLCBmYWNpbmcgdG8gdXNlci1hY3QgbG9zZSBvZiB0YXNrUXVldWUuXG5cbndvcmtzIGluIENocm9tZSBGaXJlZm94IE9wZXJhLiBidXQgbm90IGluIFNhZmFyaS5cbkBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2V4ZWNDb21tYW5kI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuXG5DbGlwYm9hcmQuZ2V0U3RyaW5nKCkgdW5pbXBsZW1lbnRlZC4gVGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gZG8gcGFzdGUgZnJvbSBjbGlwYm9hcmQgdG8ganMgdmFyaWFibGUuXG5cblNvIGxvb2sgb3V0IHlvdXIgYXBwIGJlaGF2aW9yLCB3aGVuIGRvd25ncmFkZSB0byBodG1sNSByZW5kZXIuXG5BbnkgaWRlYSBpcyB3ZWxjb21lLlxuKiovXG5cbmNvbnN0IFdFRVhfQ0xJUEJPQVJEX0lEID0gJ19fd2VleF9jbGlwYm9hcmRfaWRfXydcblxuY29uc3QgY2xpcGJvYXJkID0ge1xuXG4gIGdldFN0cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrSWQpIHtcbiAgICAvLyBub3Qgc3VwcG9ydGVkIGluIGh0bWw1XG4gICAgY29uc29sZS5sb2coJ2NsaXBib2FyZC5nZXRTdHJpbmcoKSBpcyBub3Qgc3VwcG9ydGVkIG5vdy4nKVxuICB9LFxuXG4gIHNldFN0cmluZzogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBub3Qgc3VwcG9ydCBzYWZhcmlcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnICYmIHRleHQgIT09ICcnICYmIGRvY3VtZW50LmV4ZWNDb21tYW5kKSB7XG4gICAgICBjb25zdCB0ZW1wSW5wdXQgPSBlbGVtZW50KClcbiAgICAgIHRlbXBJbnB1dC52YWx1ZSA9IHRleHRcblxuICAgICAgdGVtcElucHV0LnNlbGVjdCgpXG4gICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpXG4gICAgICAvLyB2YXIgb3V0ID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiZXhlY0NvbW1hbmQgb3V0IGlzIFwiICsgb3V0KTtcbiAgICAgIHRlbXBJbnB1dC52YWx1ZSA9ICcnXG4gICAgICB0ZW1wSW5wdXQuYmx1cigpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ29ubHkgc3VwcG9ydCBzdHJpbmcgaW5wdXQgbm93JylcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBlbGVtZW50ICgpIHtcbiAgbGV0IHRlbXBJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFdFRVhfQ0xJUEJPQVJEX0lEKVxuICBpZiAodGVtcElucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0ZW1wSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgdGVtcElucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBXRUVYX0NMSVBCT0FSRF9JRClcbiAgICB0ZW1wSW5wdXQuc3R5bGUuY3NzVGV4dCA9ICdoZWlnaHQ6MXB4O3dpZHRoOjFweDtib3JkZXI6bm9uZTsnXG4gICAgLy8gdGVtcElucHV0LnN0eWxlLmNzc1RleHQgPSBcImhlaWdodDo0MHB4O3dpZHRoOjMwMHB4O2JvcmRlcjpzb2xpZDtcIlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcElucHV0KVxuICB9XG4gIHJldHVybiB0ZW1wSW5wdXRcbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgY2xpcGJvYXJkOiBbe1xuICAgIG5hbWU6ICdnZXRTdHJpbmcnLFxuICAgIGFyZ3M6IFsnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ3NldFN0cmluZycsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnY2xpcGJvYXJkJywgY2xpcGJvYXJkLCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9jbGlwYm9hcmQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9
module.exports = global.weex;
